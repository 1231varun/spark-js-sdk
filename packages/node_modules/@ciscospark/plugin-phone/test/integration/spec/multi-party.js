/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/plugin-phone';

import {assert} from '@ciscospark/test-helper-chai';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import handleErrorEvent from '../lib/handle-error-event';
import {
  browserOnly,
  maxWaitForEvent
} from '@ciscospark/test-helper-mocha';
import {
  expectCallIncomingEvent,
  expectChangeActiveParticipantsCountEvent,
  expectChangeLocusEvent,
  expectChangeStateEvent
} from '../lib/event-expectations';

if (process.env.NODE_ENV !== `test`) {
  throw new Error(`Cannot run the plugin-phone test suite without NODE_ENV === "test"`);
}

browserOnly(describe)(`plugin-phone`, function() {
  this.timeout(120000);

  describe(`Phone`, () => {
    const users = {
      mccoy: null,
      spock: null
    };
    let mccoy, spock;

    before(`create users and register`, () => testUsers.create({count: Object.keys(users).length})
      .then((created) => Promise.all(Object.keys(users).map((name, index) => {
        const user = users[name] = created[index];
        user.spark = new CiscoSpark({
          credentials: {
            authorization: user.token
          }
        });

        return user.spark.phone.register();
      })))
      .then(() => {
        mccoy = users.mccoy;
        spock = users.spock;
      }));

    beforeEach(`enable group calling`, () => Object.values(users).forEach((user) => {
      user.spark.config.phone.enableExperimentalGroupCallingSupport = true;
    }));

    afterEach(`disable group calling`, () => Object.values(users).forEach((user) => {
      user.spark.config.phone.enableExperimentalGroupCallingSupport = false;
    }));

    after(`unregister users`, () => Promise.all(Object.keys(users).map((name) => {
      const user = users[name];
      return user && user.spark.phone.deregister()
        .catch((reason) => console.warn(`could not unregister ${user}`, reason));
    })));

    describe(`#dial()`, () => {
      let room;
      beforeEach(`create room via hydra`, () => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `rooms`,
        body: {
          title: `Call Test`
        }
      })
        .then((res) => {
          room = res.body;
        }));

      beforeEach(`add mccoy to room via hydra`, () => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `memberships`,
        body: {
          personId: mccoy.id,
          roomId: room.id
        }
      }));

      beforeEach(`refresh room details from hydra`, () => spock.spark.request({
        method: `GET`,
        service: `hydra`,
        resource: `rooms/${room.id}`
      })
        .then((res) => {
          room = res.body;
        }));

      it(`calls a room by hydra room id`, () => handleErrorEvent(spock.spark.phone.dial(room.id), (call) => {
        let mccoyCall;
        assert.isUndefined(call.state);
        return Promise.all([
          Promise.resolve()
            .then(() => call.locus || expectChangeLocusEvent(call))
            .then(() => call.state === `active` || expectChangeStateEvent(call))
            .then(() => assert.equal(call.state, `active`)),
          expectCallIncomingEvent(mccoy.spark.phone)
        ])
          // eslint-disable-next-line no-unused-vars
          .then(([_, mc]) => {
            mccoyCall = mc;

            assert.isFalse(mccoyCall.isCall, `McCoy sees the Call as a MEETING`);

            assert.isDefined(mccoyCall.locus, `McCoy's call has a locus`);
            assert.equal(mccoyCall.state, `active`, `McCoy's view of the call is active`);
            return Promise.all([
              mccoyCall.activeParticipantsCount === 2 || expectChangeActiveParticipantsCountEvent(mccoyCall),
              call.activeParticipantsCount === 2 || expectChangeActiveParticipantsCountEvent(call),
              mccoyCall.answer()
            ]);
          })
          .then(() => {
            // The find statements here are taking advantage of the fact
            // that this is, in fact, a two-party call
            assert.equal(call.memberships.find((m) => m._self).state, `connected`, `Spock sees Spock as connected`);
            assert.equal(mccoyCall.memberships.find((m) => m._self).state, `connected`, `McCoy sees McCoy as connected`);

            assert.equal(call.memberships.find((m) => !m._self).state, `connected`, `Spock sees McCoy as connected`);
            assert.equal(mccoyCall.memberships.find((m) => !m._self).state, `connected`, `McCoy sees Spock as connected`);

            assert.lengthOf(call.memberships, 2);
            assert.equal(call.activeParticipantsCount, 2);
            assert.lengthOf(mccoyCall.memberships, 2);
            assert.equal(mccoyCall.activeParticipantsCount, 2);
          })
          .then(() => Promise.all([
            maxWaitForEvent(5000, `change:activeParticipantsCount`, mccoyCall),
            maxWaitForEvent(5000, `change:activeParticipantsCount`, call),
            call.hangup()
          ]))
          .then(() => {
            assert.lengthOf(call.memberships, 2);
            assert.equal(call.activeParticipantsCount, 1);
            assert.lengthOf(mccoyCall.memberships, 2);
            assert.equal(mccoyCall.activeParticipantsCount, 1);

            assert.equal(call.state, `active`, `Spock sees the call as active after Spock leaves`);
            assert.equal(mccoyCall.state, `active`, `McCoy sees the call as active after Spock leaves`);
            return Promise.all([
              maxWaitForEvent(5000, `inactive`, call),
              maxWaitForEvent(5000, `inactive`, mccoyCall),
              mccoyCall.hangup()
            ]);
          })
          .then(() => {
            assert.lengthOf(call.memberships, 2);
            assert.equal(call.activeParticipantsCount, 0);
            assert.lengthOf(mccoyCall.memberships, 2);
            assert.equal(mccoyCall.activeParticipantsCount, 0);

            assert.equal(call.state, `inactive`, `Spock sees the call as inactive after McCoy leaves`);
            assert.equal(mccoyCall.state, `inactive`, `McCoy sees the call as inactive after McCoy leaves`);
          });
      }));
    });
  });
});
