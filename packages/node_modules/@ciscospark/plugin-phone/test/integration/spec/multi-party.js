/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/plugin-phone';

import {assert} from '@ciscospark/test-helper-chai';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import handleErrorEvent from '../lib/handle-error-event';
import {
  browserOnly,
  expectNEvents,
  maxWaitForEvent
} from '@ciscospark/test-helper-mocha';
import {
  expectCallIncomingEvent,
  expectChangeActiveParticipantsCountEvent,
  expectChangeLocusEvent,
  expectChangeStateEvent,
  expectInactiveEvent,
  expectMembershipEvent,
  expectMembershipConnectedEvent,
  expectMembershipDeclinedEvent,
  expectMembershipDisconnectedEvent,
  expectDisconnectedEvent
} from '../lib/event-expectations';

if (process.env.NODE_ENV !== `test`) {
  throw new Error(`Cannot run the plugin-phone test suite without NODE_ENV === "test"`);
}

browserOnly(describe)(`plugin-phone`, function() {
  this.timeout(120000);

  describe(`Phone`, () => {
    const users = {
      chekov: null,
      mccoy: null,
      spock: null,
      uhura: null
    };
    let chekov, mccoy, spock, uhura;

    before(`create users and register`, () => testUsers.create({count: Object.keys(users).length})
      .then((created) => Promise.all(Object.keys(users).map((name, index) => {
        const user = users[name] = created[index];
        user.spark = new CiscoSpark({
          credentials: {
            authorization: user.token
          }
        });

        return user.spark.phone.register();
      })))
      .then(() => {
        chekov = users.chekov;
        mccoy = users.mccoy;
        spock = users.spock;
        uhura = users.uhura;
      }));

    beforeEach(`enable group calling`, () => Object.values(users).forEach((user) => {
      user.spark.config.phone.enableExperimentalGroupCallingSupport = true;
    }));

    afterEach(`disable group calling`, () => Object.values(users).forEach((user) => {
      user.spark.config.phone.enableExperimentalGroupCallingSupport = false;
    }));

    after(`unregister users`, () => Promise.all(Object.keys(users).map((name) => {
      const user = users[name];
      return user && user.spark.phone.deregister()
        .catch((reason) => console.warn(`could not unregister ${user}`, reason));
    })));

    describe(`#dial()`, () => {
      let room;
      beforeEach(`create room via hydra`, () => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `rooms`,
        body: {
          title: `Call Test`
        }
      })
        .then((res) => {
          room = res.body;
        }));

      beforeEach(`add mccoy to room via hydra`, () => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `memberships`,
        body: {
          personId: mccoy.id,
          roomId: room.id
        }
      }));

      beforeEach(`refresh room details from hydra`, () => spock.spark.request({
        method: `GET`,
        service: `hydra`,
        resource: `rooms/${room.id}`
      })
        .then((res) => {
          room = res.body;
        }));

      it(`calls a room by hydra room id`, () => handleErrorEvent(spock.spark.phone.dial(room.id), (call) => {
        let mccoyCall;
        assert.isUndefined(call.state);
        return Promise.all([
          Promise.resolve()
            .then(() => call.locus || expectChangeLocusEvent(call))
            .then(() => call.state === `active` || expectChangeStateEvent(call))
            .then(() => assert.equal(call.state, `active`)),
          expectCallIncomingEvent(mccoy.spark.phone)
        ])
          // eslint-disable-next-line no-unused-vars
          .then(([_, mc]) => {
            mccoyCall = mc;

            assert.isFalse(mccoyCall.isCall, `McCoy sees the Call as a MEETING`);

            assert.isDefined(mccoyCall.locus, `McCoy's call has a locus`);
            assert.equal(mccoyCall.state, `active`, `McCoy's view of the call is active`);
            return Promise.all([
              mccoyCall.activeParticipantsCount === 2 || expectChangeActiveParticipantsCountEvent(mccoyCall),
              call.activeParticipantsCount === 2 || expectChangeActiveParticipantsCountEvent(call),
              mccoyCall.answer()
            ]);
          })
          .then(() => {
            // The find statements here are taking advantage of the fact
            // that this is, in fact, a two-party call
            assert.equal(call.memberships.find((m) => m._self).state, `connected`, `Spock sees Spock as connected`);
            assert.equal(mccoyCall.memberships.find((m) => m._self).state, `connected`, `McCoy sees McCoy as connected`);

            assert.equal(call.memberships.find((m) => !m._self).state, `connected`, `Spock sees McCoy as connected`);
            assert.equal(mccoyCall.memberships.find((m) => !m._self).state, `connected`, `McCoy sees Spock as connected`);

            assert.lengthOf(call.memberships, 2);
            assert.equal(call.activeParticipantsCount, 2);
            assert.lengthOf(mccoyCall.memberships, 2);
            assert.equal(mccoyCall.activeParticipantsCount, 2);
          })
          .then(() => Promise.all([
            maxWaitForEvent(5000, `change:activeParticipantsCount`, mccoyCall),
            maxWaitForEvent(5000, `change:activeParticipantsCount`, call),
            call.hangup()
          ]))
          .then(() => {
            assert.lengthOf(call.memberships, 2);
            assert.equal(call.activeParticipantsCount, 1);
            assert.lengthOf(mccoyCall.memberships, 2);
            assert.equal(mccoyCall.activeParticipantsCount, 1);

            assert.equal(call.state, `active`, `Spock sees the call as active after Spock leaves`);
            assert.equal(mccoyCall.state, `active`, `McCoy sees the call as active after Spock leaves`);
            return Promise.all([
              maxWaitForEvent(5000, `inactive`, call),
              maxWaitForEvent(5000, `inactive`, mccoyCall),
              mccoyCall.hangup()
            ]);
          })
          .then(() => {
            assert.lengthOf(call.memberships, 2);
            assert.equal(call.activeParticipantsCount, 0);
            assert.lengthOf(mccoyCall.memberships, 2);
            assert.equal(mccoyCall.activeParticipantsCount, 0);

            assert.equal(call.state, `inactive`, `Spock sees the call as inactive after McCoy leaves`);
            assert.equal(mccoyCall.state, `inactive`, `McCoy sees the call as inactive after McCoy leaves`);
          });
      }));

      it(`calls a room by sip uri`, () => handleErrorEvent(spock.spark.phone.dial(room.sipAddress), (call) => Promise.all([
        // Spock's view of the call
        expectMembershipConnectedEvent(call, mccoy.id, `spock expects mccoy to connect`)
          .then(() => expectMembershipDisconnectedEvent(call, spock.id, `spock expects mccoy to disconnect`))
          .then(() => Promise.all([
            call.hangup(),
            expectInactiveEvent(call, `spock expects the call to go inactive`)
          ])),

        // McCoy's view of the call
        expectCallIncomingEvent(mccoy.spark.phone, `mccoy expects an incoming call`)
          .then((mc) => Promise.all([
            expectMembershipConnectedEvent(mc, mccoy.id, `mccoy expects his own connection event`),
            mc.answer()
          ])
            .then(() => mc.hangup()))
      ])));
    });

    describe(`group calling events model`, () => {
      let room;

      // Reminder: this is a before each because of hangup latency in locus's
      // eventual consistency
      beforeEach(() => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `rooms`,
        body: {
          title: `Call Test`
        }
      })
        .then((res) => {
          room = res.body;
        })
        .then(() => spock.spark.request({
          method: `POST`,
          service: `hydra`,
          resource: `memberships`,
          body: {
            roomId: room.id,
            personId: mccoy.id
          }
        }))
        .then(() => spock.spark.request({
          method: `POST`,
          service: `hydra`,
          resource: `memberships`,
          body: {
            roomId: room.id,
            personId: chekov.id
          }
        }))
        .then(() => spock.spark.request({
          method: `POST`,
          service: `hydra`,
          resource: `memberships`,
          body: {
            roomId: room.id,
            personId: uhura.id
          }
        })));

      // So, yea, I'm breaking my rule on "don't use async yet" until we can
      // stop compiling it, but wow, this stabilizes these coordinated event
      // tests.
      it(`async: proceeds through a seriees of events`, () => handleErrorEvent(spock.spark.phone.dial(room.id), async (call) => {
        if (call.locus) {
          assert.equal(call.state, `active`);
          assert.equal(call.me.state, `connected`);
        }

        const [mc, cc, uc] = await Promise.all([
          expectCallIncomingEvent(mccoy.spark.phone, `mccoy expects a group call`),
          expectCallIncomingEvent(chekov.spark.phone, `chekov expects a group call`),
          expectCallIncomingEvent(uhura.spark.phone, `uhura expects a group call`),
          call.locus || expectChangeLocusEvent(call, `spock expects to receive a locus`)
            .then(() => {
              assert.equal(call.state, `active`);
              assert.equal(call.me.state, `connected`);
            })
        ]);

        assert.equal(call.me.state, `connected`);

        await Promise.all([
          expectMembershipDeclinedEvent(call, chekov.id, `spock expects chekov to decline the call`),
          expectMembershipDeclinedEvent(mc, chekov.id, `mccoy expects chekov to decline the call`),
          expectMembershipDeclinedEvent(uc, chekov.id, `uhura expects chekov to decline the call`),
          expectNEvents(20000, 2, `membership:connected`, call),
          expectMembershipConnectedEvent(mc, uhura.id, `mccoy expects uhura to join`),
          expectMembershipConnectedEvent(uc, mccoy.id, `uhura expects mccoy to join`),
          // FIXME the connected event seems really flaky
          // Consider the possibility that we're already connected?
          // expectConnectedEvent(mc, `mccoy expects to join`),
          // expectConnectedEvent(uc, `uhura expects to join`),
          mc.answer(),
          cc.decline(),
          uc.answer()
        ]);

        assert.equal(call.me.state, `connected`);

        await Promise.all([
          expectMembershipEvent(`membership:change`, call, mccoy.id, `spock expects mccoy to mute`)
            .then((membership) => {
              assert.equal(membership.personUuid, mccoy.id);
              assert.isTrue(membership.audioMuted, `spock sees mccoy's audio as muted`);
            }),
          expectMembershipEvent(`membership:change`, uc, mccoy.id, `uhura expects mccoy to mute`)
            .then((membership) => {
              assert.equal(membership.personUuid, mccoy.id);
              assert.isTrue(membership.audioMuted, `uhura sees mccoy's audio as muted`);
            }),
          mc.toggleSendingAudio()
        ]);

        assert.equal(call.me.state, `connected`);

        await Promise.all([
          expectMembershipEvent(`membership:disconnected`, call, uhura.id, `spock expects uhura to hangup`),
          expectMembershipEvent(`membership:disconnected`, mc, uhura.id, `mccoy expects uhura to hangup`),
          // expectDisconnectedEvent(uc, `uhura expects to disconnect`),
          uc.hangup()
        ]);

        assert.equal(call.me.state, `connected`);

        await Promise.all([
          expectDisconnectedEvent(mc, `mccoy expects to disconnect`),
          mc.hangup()
        ]);

        await call.hangup();
      }));
    });
  });
});
