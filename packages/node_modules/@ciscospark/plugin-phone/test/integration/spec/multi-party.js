/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/plugin-phone';

import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import handleErrorEvent from '../lib/handle-error-event';
import {browserOnly, maxWaitForEvent} from '@ciscospark/test-helper-mocha';

if (process.env.NODE_ENV !== `test`) {
  throw new Error(`Cannot run the plugin-phone test suite without NODE_ENV === "test"`);
}

browserOnly(describe)(`plugin-phone`, function() {
  this.timeout(60000);

  describe(`Phone`, () => {
    let mccoy, spock;
    before(`create users and register`, () => testUsers.create({count: 2})
      .then((users) => {
        [mccoy, spock] = users;
        spock.spark = new CiscoSpark({
          credentials: {
            authorization: spock.token
          }
        });

        mccoy.spark = new CiscoSpark({
          credentials: {
            authorization: mccoy.token
          }
        });

        return Promise.all([
          spock.spark.phone.register(),
          mccoy.spark.phone.register()
        ]);
      }));

    let ringMccoy;

    beforeEach(() => {
      ringMccoy = sinon.spy();
      mccoy.spark.phone.on(`call:incoming`, ringMccoy);
    });

    beforeEach(() => {
      spock.spark.config.phone.enableExperimentalGroupCallingSupport = true;
      mccoy.spark.config.phone.enableExperimentalGroupCallingSupport = true;
    });

    afterEach(() => {
      spock.spark.config.phone.enableExperimentalGroupCallingSupport = false;
      mccoy.spark.config.phone.enableExperimentalGroupCallingSupport = false;
    });

    after(`unregister spock and mccoy`, () => Promise.all([
      spock && spock.spark.phone.deregister()
        .catch((reason) => console.warn(`could not disconnect spock from mercury`, reason)),
      mccoy && mccoy.spark.phone.deregister()
        .catch((reason) => console.warn(`could not disconnect mccoy from mercury`, reason))
    ]));


    describe(`#dial()`, () => {
      it(`calls a room by hydra room id`, () => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `rooms`,
        body: {
          title: `Call Test`
        }
      })
        .then((res) => {
          const room = res.body;

          return spock.spark.request({
            method: `POST`,
            service: `hydra`,
            resource: `memberships`,
            body: {
              roomId: room.id,
              personId: mccoy.id
            }
          })
            .then(() => handleErrorEvent(spock.spark.phone.dial(room.id),
              (call) => {
                call.on(`all`, (e) => console.log(e));
                let mccoyCall;
                assert.isUndefined(call.state);
                return Promise.all([
                  maxWaitForEvent(5000, `change:locus`, call)
                    .then(() => {
                      assert.isDefined(call.locus);
                      return maxWaitForEvent(1000, `change:state`, call);
                    })
                    .then(() => assert.equal(call.state, `active`)),
                  mccoy.spark.phone.when(`call:incoming`)
                ])
                  // eslint-disable-next-line no-unused-vars
                  .then(([_, [mc]]) => {
                    mccoyCall = mc;

                    // assert.isFalse(call.isCall);
                    assert.isFalse(mccoyCall.isCall, `McCoy sees the Call as a MEETING`);

                    assert.isDefined(mccoyCall.locus, `McCoy's call has a locus`);
                    assert.equal(mccoyCall.state, `active`, `McCoy's view of the call is active`);
                    return Promise.all([
                      maxWaitForEvent(5000, `change:activeParticipantsCount`, mccoyCall),
                      maxWaitForEvent(5000, `change:activeParticipantsCount`, call),
                      mccoyCall.answer()
                    ]);
                  })
                  .then(() => {
                    // The find statements here are taking advantage of the fact
                    // that this is, in fact, a two-party call
                    assert.equal(call.memberships.find((m) => m._self).state, `connected`, `Spock sees Spock as connected`);
                    assert.equal(mccoyCall.memberships.find((m) => m._self).state, `connected`, `McCoy sees McCoy as connected`);

                    assert.equal(call.memberships.find((m) => !m._self).state, `connected`, `Spock sees McCoy as connected`);
                    assert.equal(mccoyCall.memberships.find((m) => !m._self).state, `connected`, `McCoy sees Spock as connected`);

                    assert.lengthOf(call.memberships, 2);
                    assert.equal(call.activeParticipantsCount, 2);
                    assert.lengthOf(mccoyCall.memberships, 2);
                    assert.equal(mccoyCall.activeParticipantsCount, 2);
                  })
                  .then(() => Promise.all([
                    maxWaitForEvent(5000, `change:activeParticipantsCount`, mccoyCall),
                    maxWaitForEvent(5000, `change:activeParticipantsCount`, call),
                    call.hangup()
                  ]))
                  .then(() => {
                    assert.lengthOf(call.memberships, 2);
                    assert.equal(call.activeParticipantsCount, 1);
                    assert.lengthOf(mccoyCall.memberships, 2);
                    assert.equal(mccoyCall.activeParticipantsCount, 1);

                    assert.equal(call.state, `active`, `Spock sees the call as active after Spock leaves`);
                    assert.equal(mccoyCall.state, `active`, `McCoy sees the call as active after Spock leaves`);
                    return Promise.all([
                      maxWaitForEvent(5000, `inactive`, call),
                      maxWaitForEvent(5000, `inactive`, mccoyCall),
                      mccoyCall.hangup()
                    ]);
                  })
                  .then(() => {
                    assert.lengthOf(call.memberships, 2);
                    assert.equal(call.activeParticipantsCount, 0);
                    assert.lengthOf(mccoyCall.memberships, 2);
                    assert.equal(mccoyCall.activeParticipantsCount, 0);

                    assert.equal(call.state, `inactive`, `Spock sees the call as inactive after McCoy leaves`);
                    assert.equal(mccoyCall.state, `inactive`, `McCoy sees the call as inactive after McCoy leaves`);
                  });
              }));

        }));
    });
  });
});
