/**!
 *
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 * @private
 */

import {browserOnly, nodeOnly} from '@ciscospark/test-helper-mocha';
import {assert} from '@ciscospark/test-helper-chai';
import testUsers from '@ciscospark/test-helper-test-users';
import Spark from '../../../..';

/* eslint camelcase: [0] */

describe(`spark-core`, () => {
  describe(`Credentials`, () => {
    describe(`Token`, () => {
      let spark, user;
      before(() => testUsers.create({count: 1})
        .then(([u]) => {
          user = u;
        }));

      describe(`#downscope()`, () => {
        it(`retrieves an access token with a subset of scopes`, () => {
          spark = new Spark({credentials: user.token});
          return spark.credentials.supertoken.downscope(`spark:kms`)
            .then((token2) => token2.validate())
            .then((result) => assert.deepEqual(result.scope, [`spark:kms`]));
        });
      });

      describe(`#refresh()`, () => {
        nodeOnly(it)(`refreshes the token, returning a new Token instance`, () => {
          spark = new Spark({credentials: user.token});
          return spark.credentials.supertoken.refresh()
            .then((token2) => {
              assert.notEqual(token2.access_token, spark.credentials.supertoken.access_token);
              assert.equal(token2.refresh_token, spark.credentials.supertoken.refresh_token);
            });
        });

        browserOnly(it)(`refreshes the token, returning a new Token instance`, () => {
          spark = new Spark({
            credentials: user.token,
            config: {
              credentials: {
                refreshCallback(s, token) {
                  return s.request({
                    method: `POST`,
                    uri: s.config.credentials.tokenUrl,
                    form: {
                      grant_type: `refresh_token`,
                      redirect_uri: s.config.credentials.redirect_uri,
                      refresh_token: token.refresh_token
                    },
                    auth: {
                      user: s.config.credentials.client_id,
                      pass: s.config.credentials.client_secret,
                      sendImmediately: true
                    },
                    shouldRefreshAccessToken: false
                  })
                    .then(({body}) => body);
                }
              }
            }
          });

          return spark.credentials.supertoken.refresh()
            .then((token2) => {
              assert.notEqual(token2.access_token, spark.credentials.supertoken.access_token);
              assert.equal(token2.refresh_token, spark.credentials.supertoken.refresh_token);
            });
        });
      });

      describe(`#revoke()`, () => {
        it(`revokes the token`, () => {
          spark = new Spark({credentials: user.token});
          return spark.credentials.supertoken.revoke()
            .then(() => {
              assert.isUndefined(spark.credentials.supertoken.access_token);
              assert.isDefined(spark.credentials.supertoken.refresh_token);
              assert.isUndefined(spark.credentials.supertoken.expires_in);
            });
        });
      });
    });
  });
});
