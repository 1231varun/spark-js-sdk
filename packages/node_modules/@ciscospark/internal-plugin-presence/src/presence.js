/**!
 *
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 * @private
 */
import '@ciscospark/internal-plugin-wdm';

import {SparkPlugin} from '@ciscospark/spark-core';
import {transformSingleStatusResponse, transformStatusResponses} from './transforms';

const defaultSubscriptionTtl = 600;

/**
 * @class
 * @extends SparkPlugin
 */
const Presence = SparkPlugin.extend({
  namespace: `Presence`,

  /**
   * Gets the current presence status of a given person id
   * @param {string} personId
   * @returns {Promise}
   */
  get(personId) {
    if (!personId) {
      return Promise.reject(new Error(`A person id is required`));
    }
    return this.postCompositions([personId]);
  },

  /**
   * Gets the current presence status of a given array of person ids
   * @param {Array} personIds
   * @returns {Promise}
   */
  list(personIds) {
    if (!personIds || !Array.isArray(personIds)) {
      return Promise.reject(new Error(`An array of people ids is required`));
    }
    return this.postCompositions(personIds);
  },

  /**
   * Subscribes to a person's presence status updates
   * Updates are sent via mercury events `apheleia.subscription_update`
   * @param {string} personId
   * @param {number} subscriptionTtl - Requested length of subscriptions in seconds.
   * @returns {Promise}
   */
  subscribe(personId, subscriptionTtl = defaultSubscriptionTtl) {
    if (!personId) {
      return Promise.reject(new Error(`A person id is required`));
    }
    return this.postSubscriptions([personId], subscriptionTtl)
      .then((response) => transformStatusResponses(response.body.responses));
  },

  /**
   * Subscribes to a list of people's presence status updates
   * Updates are sent via mercury events `apheleia.subscription_update`
   * @param {Array} personIds
   * @param {number} subscriptionTtl - Requested length of subscriptions in seconds.
   * @returns {Promise}
   */
  subscribeList(personIds, subscriptionTtl = defaultSubscriptionTtl) {
    if (!personIds || !Array.isArray(personIds)) {
      return Promise.reject(new Error(`An array of people ids is required`));
    }
    return this.postSubscriptions(personIds, subscriptionTtl)
      .then((response) => transformStatusResponses(response.body.responses));
  },

  /**
   * Unsubscribes from a single person's presence subscription
   * @param {string} personId
   * @returns {Promise}
   */
  unsubscribe(personId) {
    if (!personId) {
      return Promise.reject(new Error(`A person id is required`));
    }
    return this.postSubscriptions([personId], 0);
  },

  /**
   * Unsubscribes from a group of people's presence subscription
   * @param {Array} personIds
   * @returns {Promise}
   */
  unsubscribeList(personIds) {
    if (!personIds || !Array.isArray(personIds)) {
      return Promise.reject(new Error(`An array of people ids is required`));
    }
    return this.postSubscriptions(personIds, 0);
  },

  /**
   * Sets the status of the current user
   * @param {string} status - active | inactive | ooo | dnd
   * @param {number} ttl - Time To Live for the event in seconds.
   * @returns {Promise}
   */
  setStatus(status, ttl) {
    if (!status) {
      return Promise.reject(new Error(`A status is required`));
    }
    return this.spark.request({
      method: `POST`,
      api: `apheleia`,
      resource: `events`,
      body: {
        subject: this.spark.internal.device.userId,
        eventType: status,
        ttl
      }
    })
      .then((response) => transformSingleStatusResponse(response.body));
  },

  postCompositions(subjects) {
    return this.spark.request({
      method: `POST`,
      service: `apheleia`,
      resource: `compositions`,
      body: {subjects}
    })
      .then((response) => transformStatusResponses(response.body.statusList));
  },

  postSubscriptions(subjects, subscriptionTtl) {
    return this.spark.request({
      method: `POST`,
      api: `apheleia`,
      resource: `subscriptions`,
      body: {
        subjects,
        subscriptionTtl,
        includeStatus: true
      }
    });
  }
});

export default Presence;
