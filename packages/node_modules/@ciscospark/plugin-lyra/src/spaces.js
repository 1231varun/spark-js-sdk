/**!
 *
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 * @private
 */

import {SparkPlugin} from '@ciscospark/spark-core';
import querystring from 'querystring';
import {base64} from '@ciscospark/common';

/**
 * @class
 * @extends {Lyra}
 * @memberof Lyra
 */
const Spaces = SparkPlugin.extend({
  namespace: `Lyra`,

  /**
   * Lists lyra spaces associated with user
   *
   * @returns {Promise<Array>} spaces
   */
  list() {
    return this.spark.request({
      method: `GET`,
      api: `lyra`,
      resource: `/spaces`
    })
      .then((res) => res.body);
  },

  /**
   * Retrieves a lyra space info
   * @param {Types~LyraSpace} space
   * @param {string} space.id
   * @param {string} space.identity.id
   * @returns {Promise<LyraSpace>} response body
   */
  get(space = {}) {
    const spaceId = space.id || space.identity && space.identity.id;
    if (!spaceId) {
      return Promise.reject(`space.id is required`);
    }

    return this.spark.request({
      method: `GET`,
      api: `lyra`,
      resource: `/spaces/${spaceId}`
    })
      .then((res) => res.body);
  },

  /**
   * Joins a lyra space, update every 10 minutes to keep alive for MANUAL
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {object} options
   * @param {string} options.passType
   * @returns {Promise}
   */
  joinSpace(space, options = {passType: `MANUAL`}) {
    const body = {
      pass: {
        type: options.passType
      },
      deviceUrl: this.spark.device.url
    };

    return this.spark.request({
      method: `PUT`,
      uri: `${space.url}/occupants/@me`,
      body
    });
  },

  /**
   * Leaves a lyra space
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {object} options
   * @param {boolean} options.removeAllDevices remove all devices of current user also
   * @returns {Promise}
   */
  leaveSpace(space, options = {}) {
    // all devices are removed by default (when deviceUrl is not supplied)
    let uri = `${space.url}/occupants/@me`;

    if (!options.removeAllDevices) {
      const params = {
        deviceUrl: base64.toBase64Url(this.spark.device.url)
      };
      uri += `?${querystring.stringify(params)}`;
    }

    return this.spark.request({
      method: `DELETE`,
      uri
    });
  },

  /**
   * Verifies a space occupant (to be used by the lyra device)
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {string} occupantId id of user to verify
   * @returns {Promise}
   */
  verifyOccupant(space, occupantId) {
    const body = {
      pass: {
        type: `VERIFICATION`
      }
    };

    return this.spark.request({
      method: `PUT`,
      uri: `${space.url}/occupants/${occupantId}`,
      body
    });
  },

  /**
   * Gets the state of bindings in this Lyra space
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @returns {Promise<LyraBindings>} bindings response body
   */
  getSpaceBindings(space) {
    return this.spark.request({
      method: `GET`,
      uri: `${space.url}/bindings`
    })
      .then((res) => res.body);
  },

  /**
   * Binds a conversation to lyra space
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {string} space.id
   * @param {string} space.identity.id
   * @param {Types~Conversation} conversation
   * @param {string} conversation.kmsResourceObjectUrl
   * @param {string} conversation.url
   * @returns {Promise<LyraBindings>} bindings response body
   */
  bindConversationToSpace(space = {}, conversation = {}) {
    const spaceId = space.id || space.identity && space.identity.id;

    if (!space.url) {
      return Promise.reject(`space.url is required`);
    }

    if (!spaceId) {
      return Promise.reject(`space.id is required`);
    }

    if (!conversation.kmsResourceObjectUrl) {
      return Promise.reject(`conversation.kmsResourceObjectUrl is required`);
    }

    if (!conversation.url) {
      return Promise.reject(`conversation.url is required`);
    }

    const body = {
      kmsMessage: {
        method: `create`,
        uri: `/authorizations`,
        resourceUri: `${conversation.kmsResourceObjectUrl}`,
        userIds: [spaceId]
      },
      conversationUrl: conversation.url
    };

    return this.spark.request({
      method: `POST`,
      uri: `${space.url}/bindings`,
      body
    })
      .then((res) => res.body);
  },

  /**
   * Removes binding between a conversation and a lyra space using conversation
   * url
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {string} space.id
   * @param {string} space.identity.id
   * @param {Types~Conversation} conversation
   * @param {string} conversation.kmsResourceObjectUrl
   * @param {string} conversation.url
   * @returns {Promise<LyraBindings>} bindings response body
   */
  unbindConversationFromSpace(space = {}, conversation) {
    const spaceId = space.id || space.identity && space.identity.id;

    if (!space.url) {
      return Promise.reject(`space.url is required`);
    }

    if (!spaceId) {
      return Promise.reject(`space.id is required`);
    }

    if (!conversation.url) {
      return Promise.reject(`conversation.url is required`);
    }

    if (!conversation.kmsResourceObjectUrl) {
      return Promise.reject(`conversation.kmsResourceObjectUrl is required`);
    }

    const parameters = {
      kmsMessage: {
        method: `delete`,
        uri: `${conversation.kmsResourceObjectUrl}/authorizations?${querystring.stringify({authId: spaceId})}`
      },
      conversationUrl: base64.toBase64Url(conversation.url)
    };

    return this.spark.encryption.kms.prepareRequest(parameters.kmsMessage)
      .then((req) => {
        parameters.kmsMessage = req.wrapped;

        return this.spark.request({
          method: `DELETE`,
          uri: `${space.url}/bindings?${querystring.stringify(parameters)}`
        });
      });
  },

  /**
   * Delete a binding using binding id
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {string} space.identity.id
   * @param {object} options
   * @param {string} options.kmsResourceObjectUrl
   * @param {string} options.bindingId
   * @returns {Promise<LyraBindings>} bindings response body
   */
  deleteBinding(space = {}, options = {}) {
    const spaceId = space.id || space.identity && space.identity.id;

    if (!space.url) {
      return Promise.reject(`space.url is required`);
    }

    if (!spaceId) {
      return Promise.reject(`space.id is required`);
    }

    if (!options.kmsResourceObjectUrl) {
      return Promise.reject(`options.kmsResourceObjectUrl is required`);
    }

    if (!options.bindingId) {
      return Promise.reject(`options.bindingId is required`);
    }

    const parameters = {
      kmsMessage: {
        method: `delete`,
        uri: `${options.kmsResourceObjectUrl}/authorizations?${querystring.stringify({authId: spaceId})}`
      }
    };

    return this.spark.encryption.kms.prepareRequest(parameters.kmsMessage)
      .then((req) => {
        parameters.kmsMessage = req.wrapped;

        return this.spark.request({
          method: `DELETE`,
          uri: `${space.url}/bindings/${options.bindingId}?${querystring.stringify(parameters)}`
        });
      });
  },

  /**
   * Gets the audio state of the device
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @returns {Promise<LyraAudioState>} {volume, microphones, url}
   */
  getAudioState(space) {
    return this.spark.request({
      method: `GET`,
      uri: `${space.url}/audio`
    })
      .then((res) => res.body);
  },

  /**
   * Updates audio state for lyra device, should be called every 10 minutes or
   * when mic or volume state is changed
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {Types~LyraAudioState} audioState
   * @param {object} audioState.volume optional
   * @param {boolean} audioState.volume.level
   * @param {object} audioState.microphones optional
   * @param {boolean} audioState.microphones.muted
   * @param {string} audioState.deviceUrl
   * @returns {Promise}
   */
  putAudioState(space, audioState = {}) {
    if (!audioState.deviceUrl) {
      return Promise.reject(`audioState.deviceUrl is required`);
    }

    return this.spark.request({
      method: `PUT`,
      uri: `${space.url}/audio`,
      body: audioState
    })
      .then((res) => res.body);
  },

  /**
   * Mutes lyra device
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @returns {Promise}
   */
  mute(space) {
    return this.spark.request({
      method: `POST`,
      uri: `${space.url}/audio/microphones/actions/mute/invoke`
    });
  },

  /**
   * Unmutes lyra device
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @returns {Promise}
   */
  unmute(space) {
    return this.spark.request({
      method: `POST`,
      uri: `${space.url}/audio/microphones/actions/un-mute/invoke`
    });
  },

  /**
   * Increases lyra device's volume
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @returns {Promise}
   */
  increaseVolume(space) {
    return this.spark.request({
      method: `POST`,
      uri: `${space.url}/audio/volume/actions/increase/invoke`
    });
  },

  /**
   * Decreases lyra device's volume
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @returns {Promise}
   */
  decreaseVolume(space) {
    return this.spark.request({
      method: `POST`,
      uri: `${space.url}/audio/volume/actions/decrease/invoke`
    });
  },

  /**
   * Sets lyra device's volume but should use increase and decrease api instead
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {integer} level to be set
   * @returns {Promise}
   */
  setVolume(space, level = 0) {
    return this.spark.request({
      method: `POST`,
      uri: `${space.url}/audio/volume/actions/set/invoke`,
      body: {
        level
      }
    });
  }

});

export default Spaces;
