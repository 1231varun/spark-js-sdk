/**!
 *
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '../..';

import {assert} from '@ciscospark/test-helper-chai';
import testUsers from '@ciscospark/test-helper-test-users';
import {generateRandomString} from '@ciscospark/test-users-legacy';
import CiscoSpark from '@ciscospark/spark-core';
import uuid from 'uuid';

describe(`plugin-lyra`, () => {
  describe(`Occupants`, () => {
    let participants;
    let lyraMachine;
    let spock;
    let conversation;

    before(`create lyra machine`, () => testUsers.create({
      count: 1,
      config: {
        machineType: `LYRA_SPACE`,
        type: `MACHINE`,
        password: `${generateRandomString(32)}d_wA*`
      }
    })
      .then((machines) => {
        lyraMachine = machines[0];
        lyraMachine.spark = new CiscoSpark({
          credentials: {
            authorization: lyraMachine.token
          }
        });

        // binding to conversation only works with spark board device
        lyraMachine.spark.device.config.defaults.deviceType = `SPARK_BOARD`;
        lyraMachine.spark.device.config.defaults.model = `SparkBoard Test`;
        lyraMachine.spark.device.config.defaults.localizedModel = `SparkJSSDKTest`;
        lyraMachine.spark.device.config.defaults.systemVersion = `SparkJSSDKTest`;
        lyraMachine.spark.device.config.defaults.systemName = `Darling`;

        return lyraMachine.spark.mercury.connect();
      })
      .then(() => lyraMachine.spark.lyra.spaces.get({id: lyraMachine.id}))
      .then((space) => {
        lyraMachine.space = space;
      }));

    before(`create users`, () => testUsers.create({count: 2})
      .then((users) => {
        participants = users;
        spock = participants[0];

        return Promise.all(Array.map(participants, (participant) => {
          participant.spark = new CiscoSpark({
            credentials: {
              authorization: participant.token
            }
          });

          return participant.spark.mercury.connect();
        }));
      }));

    before(`create conversation`, () => participants[0].spark.conversation.create({
      displayName: `Test Lyra Conversation`,
      participants
    })
      .then((c) => {
        conversation = c;
        return conversation;
      }));

    describe(`#join()`, () => {
      it(`adds the current user to lyra space`, () => spock.spark.lyra.occupants.join(lyraMachine.space)
          .then(() => lyraMachine.spark.lyra.spaces.get(lyraMachine.space))
          .then((lyraSpace) => {
            assert.lengthOf(lyraSpace.occupants.items, 1);
            assert.equal(lyraSpace.occupants.items[0].identity.id, spock.id);
          }));
    });

    describe(`#leaveSpace()`, () => {
      it(`allows the current user to leave lyra space`, () => spock.spark.lyra.occupants.join(lyraMachine.space)
          .then(() => spock.spark.lyra.occupants.leave(lyraMachine.space))
          .then(() => lyraMachine.spark.lyra.spaces.get(lyraMachine.space))
          .then((lyraSpace) => assert.lengthOf(lyraSpace.occupants.items, 0)));

      describe(`when a user has multiple devices in the space`, () => {
        before(`add another device`, () => {
          spock.spark2 = new CiscoSpark({
            credentials: {
              authorization: spock.token
            }
          });

          return spock.spark2.device.register()
            .then(() => spock.spark.lyra.occupants.join(lyraMachine.space))
            .then(() => spock.spark2.lyra.occupants.join(lyraMachine.space));
        });

        it(`removes all devices from lyra space`, () => spock.spark.lyra.occupants.leave(lyraMachine.space, {
          removeAllDevices: true
        })
          .then(() => lyraMachine.spark.lyra.spaces.get(lyraMachine.space))
          .then((lyraSpace) => assert.lengthOf(lyraSpace.occupants.items, 0)));
      });

    });

    describe(`#getAudioState`, () => {
      let audioState;

      before(`put audio state`, () => {
        audioState = {
          volume: {
            level: 2
          },
          microphones: {
            muted: false
          },
          deviceUrl: lyraMachine.spark.device.url
        };

        return lyraMachine.spark.lyra.occupants.putAudioState(lyraMachine.space, audioState);
      });

      it(`returns audio state`, () => lyraMachine.spark.lyra.occupants.getAudioState(lyraMachine.space)
          .then((res) => {
            assert.equal(res.microphones.muted, audioState.microphones.muted);
            assert.equal(res.volume.level, audioState.volume.level);
          }));
    });

    describe(`when a call is in progress`, () => {
      before(`ensure participant joined space`, () => spock.spark.lyra.occupants.join(lyraMachine.space)
        .then(() => lyraMachine.spark.lyra.spaces.verifyOccupant(lyraMachine.space, spock.id))
        .then(() => spock.spark.lyra.spaces.bindConversation(lyraMachine.space, conversation)));

      before(`make a call`, () => {
        const locus = {
          url: conversation.locusUrl,
          correlationId: uuid.v4()
        };

        return spock.spark.request({
          method: `POST`,
          uri: `${locus.url}/participant`,
          body: {
            correlationId: locus.correlationId,
            deviceUrl: spock.spark.device.url,
            localMedias: []
          }
        });
      });

      after(`remove binding`, () => spock.spark.lyra.spaces.unbindConversation(lyraMachine.space, conversation));

      it(`allows muting`, (done) => {
        lyraMachine.spark.mercury.once(`event:lyra.space_audio_microphones_mute_action`, (event) => {
          assert.equal(event.data.action, `mute`);
          done();
        });

        return spock.spark.lyra.occupants.mute(lyraMachine.space);
      });

      it(`allows unmuting`, (done) => {
        lyraMachine.spark.mercury.once(`event:lyra.space_audio_microphones_mute_action`, (event) => {
          assert.equal(event.data.action, `unMute`);
          done();
        });

        return spock.spark.lyra.occupants.unmute(lyraMachine.space);
      });

      it(`allows increasing volume`, (done) => {
        lyraMachine.spark.mercury.once(`event:lyra.space_audio_volume_change_action`, (event) => {
          assert.equal(event.data.action, `increase`);
          done();
        });

        return spock.spark.lyra.occupants.increaseVolume(lyraMachine.space);
      });

      it(`allows decreasing volume`, (done) => {
        lyraMachine.spark.mercury.once(`event:lyra.space_audio_volume_change_action`, (event) => {
          assert.equal(event.data.action, `decrease`);
          done();
        });

        return spock.spark.lyra.occupants.decreaseVolume(lyraMachine.space);
      });

      it(`allows setting volumne`, (done) => {
        lyraMachine.spark.mercury.once(`event:lyra.space_audio_volume_set_action`, (event) => {
          assert.equal(event.data.level, 2);
          done();
        });

        return spock.spark.lyra.occupants.setVolume(lyraMachine.space, 2);
      });
    });
  });
});
