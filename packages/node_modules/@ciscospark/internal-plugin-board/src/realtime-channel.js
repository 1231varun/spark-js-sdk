/**!
 *
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 * @private
 */

import {
  Socket,
  Mercury,
  NotAuthorized,
  BadRequest,
  Forbidden
} from '@ciscospark/internal-plugin-mercury';

const RealtimeChannel = Mercury.extend({
  namespace: `Board`,

  props: {
    channelId: {
      type: `string`,
      required: true
    },
    socketUrl: {
      type: `string`
    },
    binding: {
      type: `string`
    }
  },

  session: {
    isSharingMercury: {
      type: `boolean`,
      default: false
    },
    socket: {
      type: `object`
    }
  },

  send(data) {
    if (!this.socket) {
      return Promise.reject(`socket is undefined`);
    }
    return this.socket.send(data);
  },

  _getNewSocket() {
    return new Socket();
  },

  _attemptConnection(callback) {
    const socket = this._getNewSocket();
    socket.on(`close`, (...args) => this._onclose(...args));
    socket.on(`message`, (...args) => this._onmessage(...args));
    socket.on(`sequence-mismatch`, (...args) => this._emit(`sequence-mismatch`, ...args));
    Promise.all([this._prepareUrl(this.socketUrl), this.spark.credentials.getUserToken()])
      .then(([webSocketUrl, token]) => socket.open(webSocketUrl, {
        forceCloseDelay: this.config.forceCloseDelay,
        pingInterval: this.config.pingInterval,
        pongTimeout: this.config.pongTimeout,
        token: token.toString(),
        trackingId: `${this.spark.sessionId}_${Date.now()}`,
        logger: this.logger
      }))
      .then(() => {
        this.socket = socket;
        this.isSharingMercury = false;
        callback();
      })
      .catch((reason) => {
        // Suppress connection errors that appear to be network related. This
        // may end up suppressing metrics during outages, but we might not care
        // (especially since many of our outages happen in a way that client
        // metrics can't be trusted).
        if (reason.code !== 1006 && this.backoffCall && this.backoffCall.getNumRetries() > 0) {
          this._emit(`connection_failed`, reason, {retries: this.backoffCall.getNumRetries()});
        }
        this.logger.info(`board realtime: connection attempt failed`, reason);
        // NotAuthorized implies expired token
        if (reason instanceof NotAuthorized) {
          this.logger.info(`board realtime: received authorization error, reauthorizing`);
          return this.spark.credentials.refresh({force: true})
            .then(() => callback(reason));
        }
        // // NotFound implies expired web socket url
        // else if (reason instanceof NotFound) {
        //   this.logger.info(`mercury: received not found error, refreshing device registration`);
        //   return this.spark.device.refresh()
        //     .then(() => callback(reason));
        // }
        // BadRequest implies current credentials are for a Service Account
        // Forbidden implies current user is not entitle for Spark
        else if (reason instanceof BadRequest || reason instanceof Forbidden) {
          this.logger.warn(`board realtime: received unrecoverable response from mercury`);
          this.backoffCall.abort();
          return callback(reason);
        }
        return callback(reason);
      })
      .catch((reason) => {
        this.logger.error(`board realtime: failed to handle connection failured`, reason);
        callback(reason);
      });
  }
});

export default RealtimeChannel;

