/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-board';

import {assert} from '@ciscospark/test-helper-chai';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import {map} from 'lodash';
import uuid from 'uuid';

describe('plugin-board', () => {
  describe.skip('realtime - sharing mercury', () => {
    let board, conversation, participants;

    before('create users', () => testUsers.create({count: 2})
      .then((users) => {
        participants = users;

        return Promise.all(map(participants, (participant) => {
          participant.spark = new CiscoSpark({
            credentials: {
              authorization: participant.token
            }
          });
          return participant.spark.internal.device.register()
            .then(() => participant.spark.internal.feature.setFeature('developer', 'web-shared-mercury', true));
        }));
      }));

    before('create conversation', () => participants[0].spark.internal.conversation.create({
      displayName: 'Test Board Mercury',
      participants
    })
      .then((c) => {
        conversation = c;
        return conversation;
      }));

    before('create channel (board)', () => participants[0].spark.internal.board.createChannel(conversation)
      .then((channel) => {
        board = channel;
        return channel;
      }));

    beforeEach('connect to mercury channel', () => Promise.all(map(participants, (participant) => participant.spark.internal.mercury.connect())));

    afterEach(`disconnect mercury`, () => Promise.all(map(participants, (participant) => {
      return participant.spark.internal.mercury.disconnect();
    })));

    describe(`#publish()`, () => {
      describe(`string payload`, () => {
        let uniqueRealtimeData;
        let realtimeChannel0;
        let realtimeChannel1;

        before('open two connections', () => Promise.all([
          participants[0].spark.internal.board.realtime.connectToSharedMercury(board),
          participants[1].spark.internal.board.realtime.connectByOpenNewMercuryConnection(board)
        ]));

        after(() => {
          return Promise.all(map(participants, (participant) => {
            return participant.spark.internal.board.realtime.disconnectFromSharedMercury(board);
          }));
        });

        it('posts a message from shared connection to the specified board', (done) => {
          uniqueRealtimeData = uuid.v4();
          const data = {
            envelope: {
              channelId: board,
              roomId: conversation.id
            },
            payload: {
              msg: uniqueRealtimeData
            }
          };

          // participan 1 is going to listen for RT data and confirm that we
          // have the same data that was sent.
          realtimeChannel1.once(`event:board.activity`, ({data}) => {
            assert.equal(data.contentType, `STRING`);
            assert.equal(data.payload.msg, uniqueRealtimeData);
            done();
          });

          // confirm that both are connected.
          assert.isTrue(realtimeChannel0.isSharingMercury, `participant 0 is sharing mercury connection`);
          assert.isTrue(participants[0].spark.internal.mercury.connected, `participant 0 is connected`);
          assert.isFalse(realtimeChannel1.isSharingMercury, `participant 1 does not share mercury connection`);
          assert.isTrue(participants[1].spark.internal.mercury.connected, `participant 1 is connected`);

          // do not return promise because we want done() to be called on
          // board.activity
          assert.isFulfilled(participants[0].spark.internal.board.realtime.publish(board, data));
        });

        it('posts a message from separated socket connection to the specified board', (done) => {
          uniqueRealtimeData = uuid.v4();
          const data = {
            envelope: {
              channelId: board,
              roomId: conversation.id
            },
            payload: {
              msg: uniqueRealtimeData
            }
          };

          // participan 0 is going to listen for RT data and confirm that we
          // have the same data that was sent.
          participants[0].spark.internal.mercury.once('event:board.activity', ({data}) => {
            assert.equal(data.contentType, 'STRING');
            assert.equal(data.payload.msg, uniqueRealtimeData);
            done();
          });

          // confirm that both are connected.
          assert.isTrue(participants[0].spark.internal.mercury.connected, `participant 0 is connected`);
          assert.isTrue(realtimeChannel0.isSharingMercury, `participant 0 is sharing mercury connection`);
          assert.isTrue(participants[1].spark.internal.mercury.connected, `participant 1 is connected`);
          assert.isFalse(realtimeChannel1.isSharingMercury, `participant 1 does not share mercury connection`);

          // do not return promise because we want done() to be called on
          // board.activity
          participants[1].spark.internal.board.realtime.publish(board, data);
        });
      });
    });
  });
});
