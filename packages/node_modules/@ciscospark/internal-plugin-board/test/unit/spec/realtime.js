/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@ciscospark/test-helper-chai';
import MockSpark from '@ciscospark/test-helper-mock-spark';
import MockSocket from '@ciscospark/test-helper-mock-socket';
import sinon from '@ciscospark/test-helper-sinon';
import Board, {config, RealtimeChannel} from '@ciscospark/internal-plugin-board';
import uuid from 'uuid';

function delay(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}

describe('plugin-board', () => {
  describe('realtime', () => {
    let spark;
    let mockRealtimeChannel;
    let registrationRes;
    const encryptedData = `encryptedData`;
    const fakeURL = `fakeURL`;
    const mockSocket = new MockSocket();
    const channel = {
      channelId: `1234-channel-id`,
      defaultEncryptionKeyUrl: fakeURL
    };

    beforeEach(() => {
      spark = new MockSpark({
        children: {
          board: Board
        },
        config: {
          board: config.board
        }
      });
      Object.assign(spark.internal, {
        encryption: {
          encryptText: sinon.stub().returns(Promise.resolve(encryptedData))
        }
      });

      registrationRes = {
        id: `14d6abda-16de-4e02-bf7c-6d2a0e77ec38`,
        url: `https://mercury-api-a.wbx2.com/v1/apps/wx2/registrations/14d6abda-16de-4e02-bf7c-6d2a0e77ec38`,
        bindings: [`board.0609e520.a21a.11e6.912e.e9562ab65926`],
        webSocketUrl: `wss://mercury-connection-a.wbx2.com/v1/apps/wx2/registrations/14d6abda-16de-4e02-bf7c-6d2a0e77ec38/messages`,
        messageTtl: 900000
      };
      RealtimeChannel._getNewSocket = sinon.stub();

      // add mocked socket to collection
      mockRealtimeChannel = new RealtimeChannel({
        socketUrl: registrationRes.webSocketUrl,
        binding: registrationRes.bindings[0],
        channelId: channel.channelId
      });

      sinon.stub(mockRealtimeChannel, `_getNewSocket`).returns(mockSocket);
      mockRealtimeChannel.socket = mockSocket;
      spark.internal.board.realtime.realtimeChannels.add(mockRealtimeChannel);

      sinon.stub(spark.internal.board.realtime.realtimeChannels, `get`).returns(mockRealtimeChannel);
      sinon.stub(spark.internal.board.realtime.realtimeChannels, `add`);
      sinon.stub(spark.internal.board.realtime.realtimeChannels, `remove`);

      sinon.stub(spark.internal.board, `register`).returns(Promise.resolve(registrationRes));
    });

    afterEach(() => {
      spark.internal.board.realtime.realtimeChannels.get.restore();
      spark.internal.board.realtime.realtimeChannels.add.restore();
      spark.internal.board.realtime.realtimeChannels.remove.restore();
      mockSocket.open.reset();
    });

    describe('#publish()', () => {
      const message = {
        payload: {
          data: 'fake'
        },
        envelope: {
        }
      };

      beforeEach(() => {
        sinon.stub(uuid, 'v4').returns('stubbedUUIDv4');
        return spark.internal.board.realtime.publish(channel, message);
      });

      afterEach(() => {
        uuid.v4.restore();
        spark.internal.encryption.encryptText.reset();
      });

      it('sends encrypted data on the socket', () => {
        assert.calledOnce(spark.internal.encryption.encryptText);
        assert.calledWith(mockRealtimeChannel.socket.send, {
          id: uuid.v4(),
          type: 'publishRequest',
          recipients: [{
            alertType: `none`,
            route: mockRealtimeChannel.binding,
            headers: {}
          }],
          data: {
            eventType: 'board.activity',
            payload: 'encryptedData',
            envelope: {
              encryptionKeyUrl: `fakeURL`,
              channelId: mockRealtimeChannel.channelId
            },
            contentType: 'STRING'
          }
        });
      });
    });

    describe('#publishEncrypted()', () => {
      beforeEach(() => {
        sinon.stub(uuid, `v4`).returns(`stubbedUUIDv4`);
        return spark.internal.board.realtime.publishEncrypted(channel, {
          encryptedData: `encryptedData`,
          encryptedKeyUrl: `fakeURL`
        }, `STRING`);
      });

      afterEach(() => {
        spark.internal.board.realtime.boardBindings = [];
        uuid.v4.restore();
        spark.internal.encryption.encryptText.reset();
      });

      it(`sends encrypted data on the socket`, () => {
        assert.notCalled(spark.internal.encryption.encryptText);
        assert.calledWith(mockRealtimeChannel.socket.send, {
          id: uuid.v4(),
          type: 'publishRequest',
          recipients: [{
            alertType: 'none',
            headers: {},
            route: mockRealtimeChannel.binding
          }],
          data: {
            contentType: 'STRING',
            eventType: 'board.activity',
            envelope: {
              encryptionKeyUrl: `fakeURL`,
              channelId: channel.channelId
            },
            payload: 'encryptedData'
          }
        });
      });
    });

    describe(`#connectByOpenNewMercuryConnection()`, () => {
      it(`opens new connections using the provided socket urls`, () => {
        return spark.internal.board.realtime.connectByOpenNewMercuryConnection(channel)
          .then(() => {
            assert.calledWith(spark.internal.board.realtime.realtimeChannels.get, channel.channelId);
            assert.called(mockRealtimeChannel.socket.open);
          });
      });

      it(`creates new channel if realtime channel not found`, () => {
        spark.internal.board.realtime.realtimeChannels.get
          .onFirstCall().returns(null)
          .onSecondCall().returns(mockRealtimeChannel);

        return spark.internal.board.realtime.connectByOpenNewMercuryConnection(channel)
          .then(() => {
            assert.calledWith(spark.internal.board.realtime.realtimeChannels.add, {
              channelId: channel.channelId,
              socketUrl: registrationRes.webSocketUrl,
              binding: registrationRes.bindings[0]
            });

            assert.calledWith(spark.internal.board.realtime.realtimeChannels.get, channel.channelId);
            assert.called(mockRealtimeChannel.socket.open);
          });
      });
    });

    describe(`when trying to share mercury connection`, () => {
      let replaceBindingRes;
      let removeBindingRes;
      beforeEach(() => {
        replaceBindingRes = {
          mercuryConnectionServiceClusterUrl: 'https://mercury-connection-a5.wbx2.com/v1',
          binding: 'board.a85e2f70-528d-11e6-ad98-bd2acefef905',
          webSocketUrl: 'wss://mercury-connection-a.wbx2.com/v1/apps/wx2/registrations/14d6abda-16de-4e02-bf7c-6d2a0e77ec38/messages',
          sharedWebSocket: true,
          action: `ADD`
        };

        removeBindingRes = {
          binding: 'board.a85e2f70-528d-11e6-ad98-bd2acefef905',
          webSocketUrl: 'wss://mercury-connection-a.wbx2.com/v1/apps/wx2/registrations/14d6abda-16de-4e02-bf7c-6d2a0e77ec38/messages',
          sharedWebSocket: false,
          action: 'REMOVE'
        };

        sinon.stub(spark.internal.board, `registerToShareMercury`).returns(Promise.resolve(replaceBindingRes));
        sinon.stub(spark.internal.board, `unregisterFromSharedMercury`).returns(Promise.resolve(removeBindingRes));

      });

      afterEach(() => {
        spark.internal.board.registerToShareMercury.restore();
      });

      describe(`#connectToSharedMercury`, () => {
        it(`registers and gets board binding`, () => {
          return spark.internal.board.realtime.connectToSharedMercury(channel)
            .then((res) => {
              assert.isTrue(mockRealtimeChannel.isSharingMercury);
              assert.deepEqual(res, replaceBindingRes);
            });
        });

        describe('when connection cannot be shared', () => {
          it('opens a second socket with provided webSocketUrl', () => {
            replaceBindingRes.sharedWebSocket = false;
            return spark.internal.board.realtime.connectToSharedMercury(channel)
              .then((res) => {
                assert.isFalse(mockRealtimeChannel.isSharingMercury);
                assert.deepEqual(res, replaceBindingRes);
                assert.match(mockSocket.open.args[0][0], new RegExp(replaceBindingRes.webSocketUrl));
                assert.calledWith(mockSocket.open, sinon.match(replaceBindingRes.webSocketUrl), sinon.match.any);
              })
              .then(() => {
                const channel2 = Object.assign({}, channel, {
                  channelId: `channel2-id`
                });

                sinon.stub(mockRealtimeChannel, `connect`).returns(Promise.resolve());
                return spark.internal.board.realtime.connectToSharedMercury(channel2);
              })
              .then((res) => {
                assert.isFalse(mockRealtimeChannel.isSharingMercury);
                assert.deepEqual(res, replaceBindingRes);
                assert.called(mockRealtimeChannel.connect);
                mockRealtimeChannel.connect.restore();
              });
          });
        });
      });

      describe(`#disconnectFromSharedMercury()`, () => {
        it(`requests to remove board bindings`, () => {
          return spark.internal.board.realtime.connectToSharedMercury(channel)
            .then(() => {
              return spark.internal.board.realtime.disconnectFromSharedMercury(channel);
            })
            .then((res) => {
              assert.deepEqual(res, removeBindingRes);
              assert.called(spark.internal.board.realtime.realtimeChannels.remove);
            });
        });

        describe(`when a second connection is open`, () => {
          it(`disconnects the second socket`, () => {
            sinon.stub(mockRealtimeChannel, `disconnect`).returns(Promise.resolve());
            replaceBindingRes.sharedWebSocket = false;
            return spark.internal.board.realtime.connectToSharedMercury(channel)
              .then(() => {
                assert.isFalse(mockRealtimeChannel.isSharingMercury);
                return spark.internal.board.realtime.disconnectFromSharedMercury(channel);
              })
              .then(() => {
                assert.called(spark.internal.board.realtime.realtimeChannels.remove);
                assert.called(mockRealtimeChannel.disconnect);
                mockRealtimeChannel.disconnect.restore();
              });
          });
        });
      });
    });

    describe('#_boardChannelIdToMercuryBinding', () => {
      it('adds board. binding prefix', () => {
        assert.equal(spark.internal.board.realtime._boardChannelIdToMercuryBinding('test'), 'board.test');
      });

      it('replaces \'-\' with \'.\' and \'_\' with \'#\'', () => {
        assert.equal(spark.internal.board.realtime._boardChannelIdToMercuryBinding('abc-1234_bcd'), 'board.abc.1234#bcd');
      });

      it('leaves strings without - and _ alone', () => {
        assert.equal(spark.internal.board.realtime._boardChannelIdToMercuryBinding('abcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&*()+='), 'board.abcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&*()+=');
      });
    });

      it(`leaves strings without - and _ alone`, () => {
        assert.equal(spark.internal.board.realtime._boardChannelIdToMercuryBinding(`abcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&*()+=`), `board.abcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&*()+=`);
      });
    });

    describe(`#_onmessage`, () => {
      let fakeEvent;

      beforeEach(() => {
        fakeEvent = {
          id: uuid.v4(),
          data: {
            eventType: 'board.activity',
            actor: {
              id: 'actorId'
            },
            conversationId: uuid.v4()
          },
          timestamp: Date.now(),
          trackingId: `suffix_${uuid.v4()}_${Date.now()}`
        };
      });

      it('emits message', () => {
        const spy = sinon.spy();
        return spark.internal.board.realtime.createRealtimeChannel(channel)
          .then((realtimeChannel) => {
            realtimeChannel.on(`event:board.activity`, spy);
          })
          .then(() => spark.internal.board.realtime.connectByOpenNewMercuryConnection(channel))
          .then(() => {
            mockRealtimeChannel.socket.emit(`message`, {data: fakeEvent});
            return delay(0);
          })
          .then(() => {
            assert.called(spy);
          });
      });
    });
  });
});
