/**!
 *
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 * @ignore
 */

/* eslint camelcase: [0] */

import querystring from 'querystring';
import url from 'url';
import {base64, whileInFlight} from '@ciscospark/common';
import {grantErrors, SparkPlugin} from '@ciscospark/spark-core';
import {cloneDeep, omit} from 'lodash';
import uuid from 'uuid';

const OAUTH2_CSRF_TOKEN = `oauth2-csrf-token`;

/**
 * Browser support for OAuth2. Automatically parses the URL hash for an access
 * token
 * @class
 * @variation 3
 */
const Authorization = SparkPlugin.extend({
  derived: {
    /**
     * Alias of {@link Authorization(3)#isAuthorizing}
     * @instance
     * @memberof Authorization(3)
     * @type {boolean}
     */
    isAuthenticating: {
      deps: [`isAuthorizing`],
      fn() {
        return this.isAuthorizing;
      }
    }
  },

  session: {
    /**
     * Indicates if an Authorization Code exchange is inflight
     * @instance
     * @memberof Authorization(3)
     * @type {boolean}
     */
    isAuthorizing: {
      default: false,
      type: `boolean`
    },
    ready: {
      default: false,
      type: `boolean`
    }
  },

  namespace: `Credentials`,

  /**
   * Initializer
   * @instance
   * @memberof Authorization(3)
   * @private
   * @returns {Authorization}
   */
   // eslint-disable-next-line complexity
  initialize() {
    const location = url.parse(this.spark.getWindow().location.href, true);
    this._checkForErrors(location);

    let hash = location.hash;
    if (!hash) {
      this.ready = true;
      return;
    }
    if (hash.includes(`#`)) {
      hash = hash.substr(1);
    }
    hash = querystring.parse(hash);

    if (hash.state) {
      hash.state = JSON.parse(base64.decode(hash.state));
      this._verifySecurityToken(hash.state.csrf_token);
    }
    if (!hash.access_token) {
      this.ready = true;
      return;
    }
    if (hash.expires_in) {
      hash.expires_in = parseInt(hash.expires_in, 10);
    }
    if (hash.refresh_token_expires_in) {
      hash.refresh_token_expires_in = parseInt(hash.refresh_token_expires_in, 10);
    }

    const oauth = cloneDeep(hash);
    if (this.spark.getWindow().history && this.spark.getWindow().history.replaceState) {
      [
        `access_token`,
        `token_type`,
        `expires_in`,
        `refresh_token`,
        `refresh_token_expires_in`
      ].forEach((key) => Reflect.deleteProperty(hash, key));
      hash.state = base64.encode(JSON.stringify(omit(hash.state, `csrf_token`)));
      location.hash = querystring.stringify(hash);
      this.spark.getWindow().history.replaceState({}, null, url.format(location));
    }

    // Wait until nextTick in case `credentials` hasn't initialized yet
    process.nextTick(() => {
      this.spark.credentials.set({supertoken: oauth});
      this.ready = true;
    });
  },

  /**
   * Kicks off an oauth flow
   * @instance
   * @memberof Authorization(3)
   * @param {Object} options
   * @returns {Promise}
   */
  initiateLogin(options = {}) {
    options.state = options.state || {};
    options.state.csrf_token = this._generateSecurityToken();

    // If we're not explicitly a confidential client, assume we're a public
    // client
    if (this.config.clientType === `confidential`) {
      return this.initiateAuthorizationCodeGrant(options);
    }

    return this.initiateImplicitGrant(options);
  },

  @whileInFlight(`isAuthorizing`)
  /**
   * Kicks off the Authorization Code grant flow. Typically called via
   * {@link Authorization(3)#initiateLogin}
   * @instance
   * @memberof Authorization(3)
   * @param {Object} options
   * @returns {Promise}
   */
  initiateImplicitGrant(options) {
    this.logger.info(`authorization: initiating implicit grant flow`);
    this.spark.getWindow().location = this.spark.credentials.buildLoginUrl(Object.assign({response_type: `token`}, options));
    return Promise.resolve();
  },

  @whileInFlight(`isAuthorizing`)
  /**
   * Kicks off the Implicit Code grant flow. Typically called via
   * {@link Authorization(3)#initiateLogin}
   * @instance
   * @memberof Authorization(3)
   * @param {Object} options
   * @returns {Promise}
   */
  initiateAuthorizationCodeGrant(options) {
    this.logger.info(`authorization: initiating authorization code grant flow`);
    this.spark.getWindow().location = this.spark.credentials.buildLoginUrl(Object.assign({response_type: `code`}, options));
    return Promise.resolve();
  },

  /**
   * Called by {@link SparkCore#logout()}. Redirects to the logout page
   * @instance
   * @memberof Authorization(3)
   * @param {Object} options
   * @param {boolean} options.noRedirect if true, does not redirect
   * @returns {Promise}
   */
  logout(options = {}) {
    if (!options.noRedirect) {
      this.spark.getWindow().location = this.spark.credentials.buildLogoutUrl(options);
    }
  },

  /**
   * Checks if the result of the login redirect contains an error string
   * @instance
   * @memberof Authorization(3)
   * @param {Object} location
   * @private
   * @returns {Promise}
   */
  _checkForErrors(location) {
    const query = location.query;
    if (query && query.error) {
      const ErrorConstructor = grantErrors.select(query.error);
      throw new ErrorConstructor(query);
    }
  },

  /**
   * Generates a CSRF token and sticks in in sessionStorage
   * @instance
   * @memberof Authorization(3)
   * @private
   * @returns {Promise}
   */
  _generateSecurityToken() {
    this.logger.info(`authorization: generating csrf token`);

    const token = uuid.v4();
    this.spark.getWindow().sessionStorage.setItem(`oauth2-csrf-token`, token);
    return token;
  },


  /**
   * Checks if the CSRF token in sessionStorage is the same as the one returned
   * in the url.
   * @instance
   * @memberof Authorization(3)
   * @param {string} token
   * @private
   * @returns {Promise}
   */
  _verifySecurityToken(token) {
    const sessionToken = this.spark.getWindow().sessionStorage.getItem(OAUTH2_CSRF_TOKEN);
    this.spark.getWindow().sessionStorage.removeItem(OAUTH2_CSRF_TOKEN);
    if (!sessionToken) {
      return;
    }
    if (token !== sessionToken) {
      throw new Error(`CSRF token ${token} does not match stored token ${sessionToken}`);
    }
  }
});

export default Authorization;
