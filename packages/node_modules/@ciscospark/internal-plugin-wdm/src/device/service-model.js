/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import AmpState from 'ampersand-state';
import {defaults, isObject} from 'lodash';
import url from 'url';

const ServiceModel = AmpState.extend({
  props: {
    service: `string`,
    defaultUrl: `string`,
    availableHosts: {
      type: `array`,
      default() {
        return [];
      }
    }
  },

  session: {
    currentHostIndex: {
      type: `number`,
      default: 0
    }
  },

  derived: {
    url: {
      deps: [`defaultUrl`, `availableHosts`, `currentHostIndex`],
      fn() {
        if (this.availableHosts.length === 0) {
          return this.defaultUrl;
        }
        let host;
        if (this.currentHostIndex >= this.availableHosts.length) {
          host = this.availableHosts[this.availableHosts.length - 1];
        }
        else {
          host = this.availableHosts[this.currentHostIndex];
        }

        return this._changeUrlHost(this.defaultUrl, host.host);
      }
    }
  },

  constructor(attrs, options) {
    options = options || {};
    defaults(options, {parse: true});
    return Reflect.apply(AmpState.prototype.constructor, this, [attrs, options]);
  },

  idAttribute: `service`,

  serialize(...args) {
    const attrs = Reflect.apply(AmpState.prototype.serialize, this, args);
    attrs.url = this.url;
    return attrs;
  },

  parse(attrs) {
    if (!attrs) {
      return {};
    }

    if (attrs.availableHosts) {
      // ensure highest priority is at the top
      attrs.availableHosts.sort((a, b) => a.priority > b.priority);
    }

    return attrs;
  },

  // Override set to make sure we always run parse()
  // See https://github.com/AmpersandJS/ampersand-state/issues/146 for related
  // bug
  set(key, value, options) {
    let attrs;
    // Handle both `"key", value` and `{key: value}` -style arguments.
    // The next block is a direct copy from ampersand-state, so no need to test
    // both scenarios.
    /* istanbul ignore next */
    if (isObject(key) || key === null) {
      attrs = key;
      options = value;
    }
    else {
      attrs = {};
      attrs[key] = value;
    }

    attrs = this.parse(attrs, options);
    return Reflect.apply(AmpState.prototype.set, this, [attrs, options]);
  },

  markHostFailed() {
    const currentHost = this.getCurrentHost();
    currentHost.failed = true;
  },

  cycleHost() {
    this.currentHostIndex += 1;
    if (this.currentHostIndex >= this.availableHosts.length) {
      this.currentHostIndex = 0;
    }
  },

  getCurrentUrl() {
    return this.url;
  },

  setAndGetNextAvailableUrl() {
    this.cycleHost();
    return this.url;
  },

  getCurrentHost() {
    return this.availableHosts[this.currentHostIndex];
  },

  replaceUrlWithCurrentHost(uri) {
    return this._changeUrlHost(uri, this.getCurrentHost().host);
  },

  _changeUrlHost(currentUrl, host) {
    const urlObj = url.parse(currentUrl);
    urlObj.host = host;
    return url.format(urlObj);
  }
});

export default ServiceModel;
