/* eslint-disable */

/** ****************************************************************************************
 * EML format parser. EML is raw e-mail message header + body as returned by POP3 protocol.
 * RFC 822: http:// www.ietf.org/rfc/rfc0822.txt
 * RFC 1521: https:// www.ietf.org/rfc/rfc1521.txt
 ***************************************************************************************** */

/**
 * Generate a UUID
 * @returns {string}
 */
function guid() {
  return 'xxxxxxxxxxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  }).replace('-', '');
}

// Word-wrap the string 's' to 'i' chars per row
function wrap(s, i) {
  const a = [];
  do { a.push(s.substring(0, i)); }
  while ((s = s.substring(i, s.length)) !== '');
  return a.join('\r\n');
}

// Overridable properties and functions
var emlformat = {
  verbose: false,
  fileExtensions: {
    'text/plain': '.txt',
    'text/html': '.html',
    'image/png': '.png',
    'image/jpg': '.jpg',
    'image/jpeg': '.jpg'
  },
  // Gets file extension by mime type
  getFileExtension(mimeType) {
    return emlformat.fileExtensions[mimeType] || '';
  },
  // Gets the boundary name
  getBoundary(contentType) {
    const match = /boundary='?(.+?)'?(\s*;[\s\S]*)?$/g.exec(contentType);
    return match ? match[1] : undefined;
  },
  // Gets name and e-mail address from a string, e.g. 'PayPal' <noreply@paypal.com> => { name: 'PayPal', email: 'noreply@paypal.com' }
  getEmailAddress(raw) {
    const result = { };
    const regex = /^(.*?)(\s*\<(.*?)\>)$/g;
    const match = regex.exec(raw);
    if (match) {
      const name = emlformat.unquoteUTF8(match[1]).replace(/'/g, '').trim();
      if (name && name.length) {
        result.name = name;
      }
      result.email = match[3].trim();
    }
    else {
      result.email = raw;
    }
    return result;
  },
  // Builds e-mail address string, e.g. { name: 'PayPal', email: 'noreply@paypal.com' } => 'PayPal' <noreply@paypal.com>
  toEmailAddress(data) {
    let email = '';
    if (typeof data === 'undefined') {
      // No e-mail address
    }
    else if (typeof data === 'string') {
      email = data;
    }
    else {
      if (data.name) {
        email += `"${data.name}"`;
      }
      if (data.email) {
        email += `${email.length ? ' ' : ''}<${data.email}>`;
      }
    }
    return email;
  },
  // Decodes string like =?UTF-8?B?V2hhdOKAmXMgeW91ciBvbmxpbmUgc2hvcHBpbmcgc3R5bGU/?= or =?UTF-8?Q?...?=
  unquoteUTF8(s) {
    const regex = /=\?UTF\-8\?(B|Q)\?(.+?)(\?=)/gi;
    const match = regex.exec(s);
    if (match) {
      const type = match[1].toUpperCase();
      const value = match[2];
      if (type == 'B') { // Base64
        return Buffer.from(value.replace(/\r?\n/g, ''), 'base64').toString('utf8');
      }
      if (type == 'Q') { // Quoted printable
        return emlformat.unquotePrintable(value);
      }
    }
    return s;
  },
  // Decodes 'quoted-printable'
  unquotePrintable(s) {
    // Convert =0D to '\r', =20 to ' ', etc.
    return s
      .replace(/=([\w\d]{2})=([\w\d]{2})=([\w\d]{2})/gi, (matcher, p1, p2, p3, offset, string) => new Buffer([parseInt(p1, 16), parseInt(p2, 16), parseInt(p3, 16)]).toString('utf8'))
      .replace(/=([\w\d]{2})=([\w\d]{2})/gi, (matcher, p1, p2, offset, string) => new Buffer([parseInt(p1, 16), parseInt(p2, 16)]).toString('utf8'))
      .replace(/=([\w\d]{2})/gi, (matcher, p1, offset, string) => String.fromCharCode(parseInt(p1, 16)))
      .replace(/=\r?\n/gi, ''); // Join line
  }
};

/** ****************************************************************************************
 * Parses EML file content and return user-friendly object.
 * @params data        EML structure
 * @params options     EML build options
 * @params callback    Callback function(error, data)
 ***************************************************************************************** */
emlformat.build = function (data, options, callback) {
  // Shift arguments
  if (typeof options === 'function' && typeof callback === 'undefined') {
    callback = options;
    options = null;
  }

  if (typeof callback !== 'function') {
    callback = function (error, result) { };
  }

  let eml = '';
  const EOL = '\r\n'; // End-of-line

  try {
    if (!data || typeof data !== 'object') {
      throw new Error('Argument "data" expected to be an object!');
    }

    if (!data.headers) {
      data.headers = { };
    }

    if (typeof data.subject === 'string') {
      data.headers.Subject = data.subject;
    }

    if (typeof data.from !== 'undefined') {
      data.headers.From = (typeof data.from === 'string' ? data.from : emlformat.toEmailAddress(data.from));
    }

    if (typeof data.to !== 'undefined') {
      data.headers.To = (typeof data.to === 'string' ? data.to : emlformat.toEmailAddress(data.to));
    }

    if (!data.headers.To) {
      throw new Error('Missing "To" e-mail address!');
    }

    let boundary = `----=${guid()}`;
    if (typeof data.headers['Content-Type'] === 'undefined') {
      data.headers['Content-Type'] = `multipart/mixed;${EOL}boundary="${boundary}"`;
    }
    else {
      const name = emlformat.getBoundary(data.headers['Content-Type']);
      if (name) {
        boundary = name;
      }
    }

    // Build headers
    const keys = Object.keys(data.headers);
    for (var i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = data.headers[key];
      if (typeof value === 'undefined') {
        continue; // Skip missing headers
      }
      else if (typeof value === 'string') {
        eml += `${key}: ${value.replace(/\r?\n/g, `${EOL}  `)}${EOL}`;
      }
      else { // Array
        for (let j = 0; j < value.length; j++) {
          eml += `${key}: ${value[j].replace(/\r?\n/g, `${EOL}  `)}${EOL}`;
        }
      }
    }

    // Start the body
    eml += EOL;

    // Plain text content
    if (data.text) {
      eml += `--${boundary}${EOL}`;
      eml += `Content-Type: text/plain; charset=utf-8${EOL}`;
      eml += EOL;
      eml += data.text;
      eml += EOL + EOL;
    }

    // HTML content
    if (data.html) {
      eml += `--${boundary}${EOL}`;
      eml += `Content-Type: text/html; charset=utf-8${EOL}`;
      eml += EOL;
      eml += data.html;
      eml += EOL + EOL;
    }

    // Append attachments
    if (data.attachments) {
      for (var i = 0; i < data.attachments.length; i++) {
        const attachment = data.attachments[i];
        eml += `--${boundary}${EOL}`;
        eml += `Content-Type: ${attachment.contentType || 'application/octet-stream'}${EOL}`;
        eml += `Content-Transfer-Encoding: base64${EOL}`;
        eml += `Content-Disposition: ${attachment.inline ? 'inline' : 'attachment'}; filename="${attachment.filename || attachment.name || (`attachment_${i + 1}`)}"${EOL}`;
        eml += EOL;
        if (typeof attachment.data === 'string') {
          const content = Buffer.from(attachment.data).toString('base64');
          eml += wrap(content, 76) + EOL;
        }
        else { // Buffer
          const content = attachment.data.toString('base64');
          eml += wrap(content, 76) + EOL;
        }
        eml += EOL;
      }
    }

    // Finish the boundary
    eml += `--${boundary}--${EOL}`;

    callback(null, eml);
  }
  catch (e) {
    callback(e);
  }
};

module.exports = emlformat;
