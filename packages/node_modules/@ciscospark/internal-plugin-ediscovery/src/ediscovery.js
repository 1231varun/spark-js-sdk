/* eslint-disable prefer-template */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {waitForValue, SparkPlugin} from '@ciscospark/spark-core';
import reportRequest from './report-request';
import ReportGenerator from './report-generator';

const Ediscovery = SparkPlugin.extend({
  namespace: 'Ediscovery',

  @waitForValue('@')
  createReport(name, description, emails, keywords, spaceNames, spaceIds, range) {
    if (!emails || !keywords || !spaceNames || !spaceIds || !range) {
      throw Error('Invalid parameter(s)');
    }

    const self = this;
    const encryptionPromise = self._encryptRequestParams(name, description, keywords);
    const uuidPromise = self._asUUIDs(emails);

    return Promise.all([encryptionPromise, uuidPromise])
      .then((values) => {
        const body = reportRequest;
        body.name = values[0].encryptedName;
        body.description = values[0].encryptedDescription;
        body.keywords = values[0].encryptedKeywords;
        body.keywordEncryptionKeyUrl = values[0].encryptionkeyUrl;
        body.userIds = values[1];
        body.spaceNames = spaceNames;
        body.spaceIds = spaceIds;
        body.range = range;

        return self.request({
          method: 'POST',
          service: 'ediscovery',
          resource: 'reports',
          body
        })
          .then((res) => {
            self.logger.info('Create Report Response', res);
            return res;
          })
          .catch((reason) => {
            self.logger.error('Create Report Error', reason);
            return Promise.reject(reason);
          });
      });
  },

  /**
   * Retrieve the user UUID associated with each supplied email. If an email with no user
   * is found an error is thrown. If multiple such emails exist only the first encountered
   * throws an error.
   *
   * @param {Array.<String>} emails A list of emails to resolve
   * @returns {Promise} The UUIDs associated with the emails
   */
  _asUUIDs(emails) {
    if (!emails) {
      throw Error('Invalid parameter');
    }

    if (emails.length <= 0) {
      return Promise.resolve([]);
    }

    const promises = [];
    emails.forEach((userEmail) => {
      promises.push(
        // The people list API only supports a single email
        this.spark.people.list({email: userEmail})
          .then((result) => {
            if (result.items.length <= 0) {
              throw Error('Unable to find user with email ' + userEmail);
            }
            // User id is base64 encoded and of the format Y2lzY29zcGFyazovL3VzL1BFT1BMRS81ZDU5Yjc5NS02ZmEyLTQ2NTQtOGVjMi03NjlkYjE1YzBkOWU
            const decodedId = Buffer.from(result.items[0].id, 'base64').toString();
            // Decode and strip out the uuid ciscospark://us/PEOPLE/5d59b795-6fa2-4654-8ec2-769db15c0d9e
            const uuid = decodedId.substring(decodedId.lastIndexOf('/') + 1, decodedId.length);
            return uuid;
          })
          .catch((reason) => {
            this.logger.error('Error converting UUIDs: ', reason);
            return Promise.reject(reason);
          })
      );
    });
    return Promise.all(promises);
  },

  _encryptRequestParams(name, description, keywords) {
    const encryptedRequestInfo = {
      encryptedName: '',
      encryptedDescription: '',
      encryptedKeywords: [],
      encryptionkeyUrl: ''
    };
    if (!name && !description && keywords.length <= 0) {
      return Promise.resolve(encryptedRequestInfo);
    }

    return this.spark.internal.encryption.kms.createUnboundKeys({count: 1})
      .then((keys) => {
        const promises = [];
        if (keys && keys.length > 0 && keys[0]) {
          this.logger.info('Unbound key: ' + JSON.stringify(keys[0]));
          encryptedRequestInfo.encryptionkeyUrl = keys[0].uri;
          if (name) {
            promises.push(this.spark.internal.encryption.encryptText(keys[0], name)
              .then((encryptedName) => {
                encryptedRequestInfo.encryptedName = encryptedName;
              }));
          }
          if (description) {
            promises.push(this.spark.internal.encryption.encryptText(keys[0], description)
              .then((encryptedDescription) => {
                encryptedRequestInfo.encryptedDescription = encryptedDescription;
              }));
          }
          for (let i = 0; i < keywords.length; i += 1) {
            if (keywords[i]) {
              promises.push(this.spark.internal.encryption.encryptText(keys[0], keywords[i])
                .then((encryptedKeyword) => {
                  encryptedRequestInfo.encryptedKeywords.push(encryptedKeyword);
                }));
            }
          }
        }
        return Promise.all(promises)
          .then(() => encryptedRequestInfo);
      })
      .catch((reason) => {
        this.logger.error('Error encrypting request params: ', reason);
        return Promise.reject(reason);
      });
  },

  _decryptRequestParams(key, name, description, keywords) {
    if (!key || (!name && !description && !keywords)) {
      throw Error('Invalid parameter');
    }

    const decryptedRequestInfo = {
      decryptedName: '',
      decryptedDescription: '',
      decryptedKeywords: []
    };
    if (!name && !description && keywords.length <= 0) {
      return Promise.resolve(decryptedRequestInfo);
    }

    const promises = [];
    if (name) {
      promises.push(this.spark.internal.encryption.decryptText(key, name)
        .then((decryptedName) => {
          decryptedRequestInfo.decryptedName = decryptedName;
        })
        .catch((reason) => {
          this.logger.error('Error decrypting request name: ', reason);
        }));
    }
    if (description) {
      promises.push(this.spark.internal.encryption.decryptText(key, description)
        .then((decryptedDescription) => {
          decryptedRequestInfo.decryptedDescription = decryptedDescription;
        })
        .catch((reason) => {
          this.logger.error('Error decrypting request description: ', reason);
        }));
    }
    for (let i = 0; i < keywords.length; i += 1) {
      if (keywords[i]) {
        promises.push(this.spark.internal.encryption.decryptText(key, keywords[i])
          .then((decryptedKeyword) => {
            decryptedRequestInfo.decryptedKeywords.push(decryptedKeyword);
          })
          .catch((reason) => {
            this.logger.error('Error decrypting request keywords: ', reason);
          }));
      }
    }
    return Promise.all(promises)
      .then(() => decryptedRequestInfo);
  },

  @waitForValue('@')
  getReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports/' + id
    })
      .then((res) => {
        this.logger.info('Get Report Response', res);
        if (res.body.reportRequest && res.body.reportRequest.keywordEncryptionKeyUrl && res.body.reportRequest.keywords) {
          return this._decryptRequestParams(res.body.reportRequest.keywordEncryptionKeyUrl, res.body.reportRequest.name, res.body.reportRequest.description, res.body.reportRequest.keywords)
            .then((decryptedRequestInfo) => {
              res.body.reportRequest.name = decryptedRequestInfo.decryptedName;
              res.body.reportRequest.description = decryptedRequestInfo.decryptedDescription;
              res.body.reportRequest.keywords = decryptedRequestInfo.decryptedKeywords;
              return res;
            });
        }
        return res;
      })
      .catch((reason) => {
        this.logger.error('Get Report Error', reason);
        return reason;
      });
  },

  @waitForValue('@')
  getReports() {
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports'
    })
      .then((res) => {
        this.logger.info('Get Reports Response', res);
        const promises = [];
        for (let i = 0; i < res.body.length; i += 1) {
          if (res.body[i].reportRequest && res.body[i].reportRequest.keywordEncryptionKeyUrl && res.body[i].reportRequest.keywords) {
            promises.push(this._decryptRequestParams(res.body[i].reportRequest.keywordEncryptionKeyUrl, res.body[i].reportRequest.name, res.body[i].reportRequest.description, res.body[i].reportRequest.keywords)
              .then((decryptedRequestInfo) => {
                res.body[i].reportRequest.name = decryptedRequestInfo.decryptedName;
                res.body[i].reportRequest.description = decryptedRequestInfo.decryptedDescription;
                res.body[i].reportRequest.keywords = decryptedRequestInfo.decryptedKeywords;
              }));
          }
        }
        return Promise.all(promises)
          .then(() => res);
      })
      .catch((reason) => {
        this.logger.error('Get Reports Error', reason);
        return reason;
      });
  },

  @waitForValue('@')
  deleteReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'DELETE',
      service: 'ediscovery',
      resource: 'reports/' + id
    }).then((res) => {
      this.logger.info('Delete Report Response', res);
      return res;
    }).catch((reason) => {
      this.logger.error('Delete Report Error', reason);
      return reason;
    });
  },

  @waitForValue('@')
  restartReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'PUT',
      service: 'ediscovery',
      resource: 'reports/' + id
    }).then((res) => {
      this.logger.info('Restart Report Response', res);
      return res;
    }).catch((reason) => {
      this.logger.error('Restart Report Error', reason);
      return reason;
    });
  },


  /**
   * Retrieve the content summary for a specified report
   *
   * @param {UUID} The report id
   * @returns {Promise} The report content summary
   */
  @waitForValue('@')
  getContentSummary(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    const id = reportId;
    let offset = 0;
    const size = 10;
    let contentSummary = [];

    function getNextContentSummaryPage(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: 'reports/' + id + '/contents/summary',
        qs: {offset, size}
      }).then((res) => {
        plugin.logger.info(res);
        contentSummary = contentSummary.concat(res.body);
        if (res.body.length < size) {
          return contentSummary;
        }
        offset += size;
        return getNextContentSummaryPage(plugin);
      }).catch((reason) => {
        plugin.logger.error(reason);
        return reason;
      });
    }

    return getNextContentSummaryPage(this);
  },

  @waitForValue('@')
  getPagedContentSummary(reportId, offset, size) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports/' + id + '/contents/summary',
      qs: {offset, size}
    }).then((res) => {
      this.logger.info(res);
      return res;
    }).catch((reason) => {
      this.logger.error(reason);
      return reason;
    });
  },

  /**
   * Retrieve the content for a specified report
   *
   * @param {UUID} The report id
   * @returns {Promise} The report content
   */
  @waitForValue('@')
  getContent(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    const id = reportId;
    let offset = 0;
    const size = 10;
    let content = [];

    function getNextContentPage(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: 'reports/' + id + '/contents',
        qs: {offset, size}
      }).then((res) => {
        plugin.logger.info(res);
        content = content.concat(res.body);
        if (res.body.length < size) {
          return content;
        }
        offset += size;
        return getNextContentPage(plugin);
      }).catch((reason) => {
        plugin.logger.error(reason);
        return reason;
      });
    }

    return getNextContentPage(this);
  },

  @waitForValue('@')
  getPagedContent(reportId, offset, size) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports/' + id + '/contents',
      qs: {offset, size}
    }).then((res) => {
      this.logger.info(res);
      return res;
    }).catch((reason) => {
      this.logger.error(reason);
      return reason;
    });
  },

  @waitForValue('@')
  generateReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    return this.getReport(reportId)
      .then((reportResponse) => {
        if (!reportResponse) {
          throw Error('Unable to find report associated with id ' + reportId);
        }
        this.logger.info(reportResponse);

        let offset = 0;
        const size = 5;
        const reportGenerator = new ReportGenerator({reportId});

        function decryptNextActivities(plugin) {
          return plugin.request({
            method: 'GET',
            service: 'ediscovery',
            resource: 'reports/' + reportId + '/contents',
            qs: {offset, size}
          })
            .then((response) => {
              const contents = response.body;
              return plugin._decryptActivities(contents);
            })
            .then((activities) => {
              if (activities && Array.isArray(activities) && activities.length > 0) {
                reportGenerator.add(activities);
                if (activities.length < size) {
                  // No more activities to decrypt
                  return activities;
                }
                // Add activities to the report, increment and decrypt next activities
                offset += size;
                return decryptNextActivities(plugin);
              }
              return activities;
            })
            .catch((error) => {
              plugin.logger.error(error);
              return error;
            });
        }

        return decryptNextActivities(this).then(() => reportGenerator.saveAs());
      })
      .catch((error) => {
        this.logger.error(error);
        return error;
      });
  },

  /**
   * Decrypt the messages found on the activities.
   * @param {Object[]} activities An array of activities with encrypted messages
   * @returns {Promise<[any]>} The activities with their messages decrypted
   */
  _decryptActivities(activities) {
    const promises = [];
    for (let i = 0; i < activities.length; i += 1) {
      const activity = activities[i];
      if (activity.verb === 'post' && activity.objectDisplayName && activity.encryptionKeyUrl) {
        const textPromise = this.spark.internal.encryption.decryptText(activity.encryptionKeyUrl, activity.objectDisplayName, activity.actorId)
          .then((decryptedMessage) => {
            // Replace encrypted message with the decrypted version
            activity.objectDisplayName = decryptedMessage;
            return activity;
          })
          .catch((error) => {
            this.logger.error(`Unable to decrypt message due to error: ${error}`);
            return activity;
          });
        promises.push(textPromise);
      }
      else if (activity.verb === 'share' && activity.files && activity.files.length && activity.encryptionKeyUrl) {
        for (let i = 0; i < activity.files.length; i += 1) {
          const file = activity.files[i];
          if (file && file.displayName && file.scr) {
            const filenamePromise = this.spark.internal.encryption.decryptText(activity.encryptionKeyUrl, file.displayName, activity.actorId)
              .catch((error) => {
                this.logger.error(`Unable to decrypt filename due to error: ${error}`);
                return Promise.reject(error);
              });
            const fileContentPromise = this.spark.internal.encryption.decryptScr(activity.encryptionKeyUrl, file.scr, activity.actorId)
              .then((decryptedScr) => this.spark.internal.encryption.download(decryptedScr))
              .catch((error) => {
                this.logger.error(`Unable to download/decrypt file content due to error: ${error}`);
                return Promise.reject(error);
              });
            // Return once both promises have resolved
            const filePromise = Promise.all([filenamePromise, fileContentPromise])
              .then((values) => {
                file.name = values[0];
                file.content = values[1];
                return activity;
              })
              .catch(() => activity); // TODO: What should be done with the activity if the file download/decryption fails?
            promises.push(filePromise);
          }
        }
      }
      else {
        promises.push(Promise.resolve(activity));
      }
    }

    return Promise.all(promises);
  }

});

export default Ediscovery;
