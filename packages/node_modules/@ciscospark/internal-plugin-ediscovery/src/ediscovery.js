/* eslint-disable prefer-template */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {waitForValue, SparkPlugin} from '@ciscospark/spark-core';
import reportRequest from './report-request';
import ReportGenerator from './report-generator';

/**
 * @class Ediscovery is used by compliance officers to run compliance reports
 *
 */
const Ediscovery = SparkPlugin.extend({
  namespace: 'Ediscovery',

  /**
   * Creates a compliance report with a specific set of search parameters
   *
   * @param {String} name - A label to identify the report
   * @param {String} description - A textual summary of the reports purpose
   * @param {Array<String>} emails - A list of user emails relevant to the report
   * @param {Array<String>} keywords - A list of search terms relevant to the report
   * @param {Array<String>} spaceNames - A list of space names relevant to the report
   * @param {Array<String>} spaceIds - A list of space ids relevant to the report
   * @param {Object} range - Contains the start time and end time defining the search period
   * @returns {Promise<ResponseEntity>} Http response containing the new report record
   */
  @waitForValue('@')
  createReport(name, description, emails, keywords, spaceNames, spaceIds, range) {
    if (!emails || !keywords || !spaceNames || !spaceIds || !range) {
      throw Error('Invalid parameter(s)');
    }

    const self = this;
    const encryptionPromise = self._encryptRequestParams(name, description, keywords);
    const uuidPromise = self._asUUIDs(emails);

    return Promise.all([encryptionPromise, uuidPromise])
      .then((values) => {
        const body = reportRequest;
        body.name = values[0].encryptedName;
        body.description = values[0].encryptedDescription;
        body.keywords = values[0].encryptedKeywords;
        body.encryptionKeyUrl = values[0].encryptionkeyUrl;
        body.userIds = values[1];
        body.spaceNames = spaceNames;
        body.spaceIds = spaceIds;
        body.range = range;

        return self.request({
          method: 'POST',
          service: 'ediscovery',
          resource: 'reports',
          body
        })
          .then((res) => res)
          .catch((reason) => {
            self.logger.error(`Create Report Error ${reason}`);
            return Promise.reject(reason);
          });
      });
  },

  /**
   * Retrievse the user UUIDs associated with each supplied email. If an email with no user
   * is found an error is thrown. If multiple such emails exist only the first encountered
   * throws an error.
   *
   * @param {Array<String>} emails - A list of emails to resolve
   * @returns {Array<Promise<UUID>>} The UUIDs associated with the emails
   */
  _asUUIDs(emails) {
    if (!emails) {
      throw Error('Invalid parameter');
    }

    if (emails.length <= 0) {
      return Promise.resolve([]);
    }

    const promises = [];
    emails.forEach((userEmail) => {
      promises.push(
        // The people list API only supports a single email
        this.spark.people.list({email: userEmail})
          .then((res) => {
            if (res.items.length <= 0) {
              throw Error(`Unable to find user with email ${userEmail}`);
            }
            // User id is base64 encoded and of the format Y2lzY29zcGFyazovL3VzL1BFT1BMRS81ZDU5Yjc5NS02ZmEyLTQ2NTQtOGVjMi03NjlkYjE1YzBkOWU
            const decodedId = Buffer.from(res.items[0].id, 'base64').toString();
            // Decode and strip out the uuid ciscospark://us/PEOPLE/5d59b795-6fa2-4654-8ec2-769db15c0d9e
            const uuid = decodedId.substring(decodedId.lastIndexOf('/') + 1, decodedId.length);
            return uuid;
          })
          .catch((reason) => {
            this.logger.error(`Error converting UUIDs: ${reason}`);
            return Promise.reject(reason);
          })
      );
    });
    return Promise.all(promises);
  },

  /**
   * Encrypts any potentially sensitive information relating to the report request
   * The encrypted info is then sent to the eDiscovery service and only decrypted when retrieved again by the client
   *
   * @param {String} name - A label to identify the report
   * @param {String} description - A textual summary of the reports purpose
   * @param {Array<String>} keywords - A list of search terms relevant to the report
   * @returns {Promise<encryptedRequestInfo>} Object containing encrypted versions of the original parameters
   */
  _encryptRequestParams(name, description, keywords) {
    const encryptedRequestInfo = {
      encryptedName: '',
      encryptedDescription: '',
      encryptedKeywords: [],
      encryptionkeyUrl: ''
    };

    if (!name && !description && (!keywords || keywords.length <= 0)) {
      return Promise.resolve(encryptedRequestInfo);
    }

    return this.spark.internal.encryption.kms.createUnboundKeys({count: 1})
      .then((keys) => {
        if (keys && keys.length > 0 && keys[0]) {
          return this.spark.internal.encryption.kms.createResource({userIds: [keys[0].userId], keys})
            .then((resource) => {
              this.logger.info(`Created KRO: ${resource} with key: ${keys[0]}`);
              const promises = [];
              if (name) {
                promises.push(this.spark.internal.encryption.encryptText(keys[0], name)
                  .then((encryptedName) => {
                    encryptedRequestInfo.encryptedName = encryptedName;
                  }));
              }
              if (description) {
                promises.push(this.spark.internal.encryption.encryptText(keys[0], description)
                  .then((encryptedDescription) => {
                    encryptedRequestInfo.encryptedDescription = encryptedDescription;
                  }));
              }
              for (let i = 0; i < keywords.length; i += 1) {
                if (keywords[i]) {
                  promises.push(this.spark.internal.encryption.encryptText(keys[0], keywords[i])
                    .then((encryptedKeyword) => {
                      encryptedRequestInfo.encryptedKeywords.push(encryptedKeyword);
                    }));
                }
              }
              encryptedRequestInfo.encryptionkeyUrl = keys[0].uri;
              return Promise.all(promises)
                .then(() => encryptedRequestInfo);
            });
        }
        this.logger.error(`Empty list of unbound keys returned: ${keys}`);
        return Promise.reject(encryptedRequestInfo);
      })
      .catch((reason) => {
        this.logger.error(`Error encrypting request params: ${reason}`);
        return Promise.reject(reason);
      });
  },

  /**
   * Decrypts any encrypted information relating to the report request for display in the client
   *
   * @param {String} key - Used to decrypt the encrypted text
   * @param {String} name - A label to identify the report
   * @param {String} description - A textual summary of the reports purpose
   * @param {Array<String>} keywords - A list of search terms relevant to the report
   * @returns {Promise<decryptedRequestInfo>} Object containing decrypted versions of the encrypted strings
   */
  _decryptRequestParams(key, name, description, keywords) {
    if (!key || (!name && !description && (!keywords || keywords.length <= 0))) {
      throw Error('Invalid parameter');
    }

    const decryptedRequestInfo = {
      decryptedName: '',
      decryptedDescription: '',
      decryptedKeywords: []
    };

    if (!name && !description && keywords.length <= 0) {
      return Promise.resolve(decryptedRequestInfo);
    }

    const promises = [];
    if (name) {
      promises.push(this.spark.internal.encryption.decryptText(key, name)
        .then((decryptedName) => {
          decryptedRequestInfo.decryptedName = decryptedName;
        })
        .catch((reason) => {
          this.logger.error(`Error decrypting request name: ${reason}`);
        }));
    }
    if (description) {
      promises.push(this.spark.internal.encryption.decryptText(key, description)
        .then((decryptedDescription) => {
          decryptedRequestInfo.decryptedDescription = decryptedDescription;
        })
        .catch((reason) => {
          this.logger.error(`Error decrypting request description: ${reason}`);
        }));
    }
    for (let i = 0; i < keywords.length; i += 1) {
      if (keywords[i]) {
        promises.push(this.spark.internal.encryption.decryptText(key, keywords[i])
          .then((decryptedKeyword) => {
            decryptedRequestInfo.decryptedKeywords.push(decryptedKeyword);
          })
          .catch((reason) => {
            this.logger.error(`Error decrypting request keywords: ${reason}`);
          }));
      }
    }
    return Promise.all(promises)
      .then(() => decryptedRequestInfo);
  },

  /**
   * Retrieves information relating to a specified report
   *
   * @param {UUID} reportId - Id of the report being requested
   * @returns {Promise<ResponseEntity<ReportRecord>>} Http response containing the specified report record
   */
  @waitForValue('@')
  getReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    })
      .then((res) => {
        if (res.body.reportRequest && res.body.reportRequest.encryptionKeyUrl && res.body.reportRequest.keywords) {
          return this._decryptRequestParams(res.body.reportRequest.encryptionKeyUrl, res.body.reportRequest.name, res.body.reportRequest.description, res.body.reportRequest.keywords)
            .then((decryptedRequestInfo) => {
              res.body.reportRequest.name = decryptedRequestInfo.decryptedName;
              res.body.reportRequest.description = decryptedRequestInfo.decryptedDescription;
              res.body.reportRequest.keywords = decryptedRequestInfo.decryptedKeywords;
              return res;
            });
        }
        return res;
      })
      .catch((reason) => {
        this.logger.error(`Get Report Error ${reason}`);
        return reason;
      });
  },

  /**
   * Retrieves all the compliance officers reports
   *
   * @returns {Promise<ResponseEntity<Array<ReportRecord>>>} Http Response containing a list of report records
   */
  @waitForValue('@')
  getReports() {
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports'
    })
      .then((res) => {
        const promises = [];
        for (let i = 0; i < res.body.length; i += 1) {
          if (res.body[i].reportRequest && res.body[i].reportRequest.encryptionKeyUrl && res.body[i].reportRequest.keywords) {
            promises.push(this._decryptRequestParams(res.body[i].reportRequest.encryptionKeyUrl, res.body[i].reportRequest.name, res.body[i].reportRequest.description, res.body[i].reportRequest.keywords)
              .then((decryptedRequestInfo) => {
                res.body[i].reportRequest.name = decryptedRequestInfo.decryptedName;
                res.body[i].reportRequest.description = decryptedRequestInfo.decryptedDescription;
                res.body[i].reportRequest.keywords = decryptedRequestInfo.decryptedKeywords;
              }));
          }
        }
        return Promise.all(promises)
          .then(() => res);
      })
      .catch((reason) => {
        this.logger.error(`Get Reports Error ${reason}`);
        return reason;
      });
  },

  /**
   * Deletes a specified report
   *
   * @param {UUID} reportId - Id of the report being requested for deletion
   * @returns {Promise<ResponseEntity>} HttpResponse indicating if delete was successful
   */
  @waitForValue('@')
  deleteReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    return this.request({
      method: 'DELETE',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    })
      .then((res) => res)
      .catch((reason) => {
        this.logger.error(`Delete Report Error ${reason}`);
        return reason;
      });
  },

  /**
   * Restarts a completed or cancelled report so that it begins again from scratch
   *
   * @param {UUID} reportId - Id of the report being requested
   * @returns {Promise<ResponseEntity<ReportRecord>>} Http response containing the report record
   */
  @waitForValue('@')
  restartReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    return this.request({
      method: 'PUT',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    })
      .then((res) => res)
      .catch((reason) => {
        this.logger.error(`Restart Report Error ${reason}`);
        return reason;
      });
  },


  /**
   * Retrieves a list of the conversations relevant to a specified report
   *
   * @param {UUID} reportId - Id of the report being requested
   * @returns {Promise<ResponseEntity<ContentSummary>>} Http response containing the content summary
   */
  @waitForValue('@')
  getContentSummary(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    let offset = 0;
    const size = 100;
    let contentSummary = [];

    function getNextContentSummaryPage(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: `reports/${reportId}/contents/summary`,
        qs: {offset, size}
      })
        .then((res) => {
          plugin.logger.info(res);
          contentSummary = contentSummary.concat(res.body);
          if (res.body.length < size) {
            return contentSummary;
          }
          offset += size;
          return getNextContentSummaryPage(plugin);
        })
        .catch((reason) => {
          plugin.logger.error(reason);
          return reason;
        });
    }

    return getNextContentSummaryPage(this);
  },

  /**
   * Retrieves a list of the conversations relevant to a specified report, paged with a specified offset and size
   *
   * @param {UUID} reportId - Id of the report being requested
   * @param {long} offset - the starting index of the results the caller wants
   * @param {long} size - the number of conversations the caller wants
   * @returns {Promise<ResponseEntity<ContentSummary>>} Http response containing the specified content summary
   */
  @waitForValue('@')
  getPagedContentSummary(reportId, offset, size) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: `reports/${reportId}/contents/summary`,
      qs: {offset, size}
    })
      .then((res) => res)
      .catch((reason) => {
        this.logger.error(reason);
        return reason;
      });
  },

  /**
   * Generates the report content and triggers the download of the content
   *
   * @param {UUID} reportId - Id of the report being requested
   * @returns {List<Activities>} HttpResponse
   */
  @waitForValue('@')
  generateReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    let offset = 0;
    const size = 100;
    const reportGenerator = new ReportGenerator({reportId});

    function decryptNextActivities(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: `reports/${reportId}/contents`,
        qs: {offset, size}
      })
        .then((res) => {
          const contents = res.body;
          return plugin._decryptActivities(contents);
        })
        .then((activities) => {
          if (activities && Array.isArray(activities) && activities.length > 0) {
            reportGenerator.add(activities);
            if (activities.length < size) {
              // No more activities to decrypt
            }
            else {
              // Add activities to the report, increment and decrypt next activities
              offset += size;
              decryptNextActivities(plugin);
            }
          }
        })
        .catch((reason) => {
          plugin.logger.error(reason);
          return reason;
        });
    }

    return decryptNextActivities(this).then(() => reportGenerator.saveAs());
  },

  /**
   * Decrypt the activities found in the report content
   *
   * @param {Object[]} activities An array of activities with encrypted messages
   * @returns {Promise<[any]>} The activities with their messages decrypted
   */
  _decryptActivities(activities) {
    const promises = [];
    for (let i = 0; i < activities.length; i += 1) {
      const activity = activities[i];
      if (activity.verb === 'post' && activity.objectDisplayName && activity.encryptionKeyUrl) {
        const textPromise = this.spark.internal.encryption.decryptText(activity.encryptionKeyUrl, activity.objectDisplayName, activity.actorId)
          .then((decryptedMessage) => {
            // Replace encrypted message with the decrypted version
            activity.objectDisplayName = decryptedMessage;
            return activity;
          })
          .catch((reason) => {
            this.logger.error(`Unable to decrypt message due to error: ${reason}`);
            return activity;
          });
        promises.push(textPromise);
      }
      else if (activity.verb === 'share' && activity.files && activity.files.length && activity.encryptionKeyUrl) {
        for (let i = 0; i < activity.files.length; i += 1) {
          const file = activity.files[i];
          if (file && file.displayName && file.scr) {
            const filenamePromise = this.spark.internal.encryption.decryptText(activity.encryptionKeyUrl, file.displayName, activity.actorId)
              .catch((reason) => {
                this.logger.error(`Unable to decrypt filename due to error: ${reason}`);
                return Promise.reject(reason);
              });
            const fileContentPromise = this.spark.internal.encryption.decryptScr(activity.encryptionKeyUrl, file.scr, activity.actorId)
              .then((decryptedScr) => this.spark.internal.encryption.download(decryptedScr))
              .catch((reason) => {
                this.logger.error(`Unable to download/decrypt file content due to error: ${reason}`);
                return Promise.reject(reason);
              });
            // Return once both promises have resolved
            const filePromise = Promise.all([filenamePromise, fileContentPromise])
              .then((values) => {
                file.name = values[0];
                file.content = values[1];
                return activity;
              })
              .catch(() => activity); // TODO: What should be done with the activity if the file download/decryption fails?
            promises.push(filePromise);
          }
        }
      }
      else {
        promises.push(Promise.resolve(activity));
      }
    }

    return Promise.all(promises);
  }

});

export default Ediscovery;
