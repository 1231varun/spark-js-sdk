/* eslint-disable prefer-template */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {waitForValue, SparkPlugin} from '@ciscospark/spark-core';
import reportRequest from './report-request';
import ReportGenerator from './report-generator';

const Ediscovery = SparkPlugin.extend({
  namespace: 'Ediscovery',

  @waitForValue('@')
  createReport(emails, keywords, spaceNames, spaceIds, range) {
    if (!emails || !keywords || !spaceNames || !spaceIds) {
      throw new Error('Invalid parameter(s)');
    }

    const self = this;
    return this.asUUIDs(emails).then((uuids) => {
      const body = reportRequest;
      body.userIds = uuids;
      body.keywords = keywords;
      body.spaceNames = spaceNames;
      body.spaceIds = spaceIds;
      body.range = range;

      return self.request({
        method: 'POST',
        service: 'ediscovery',
        resource: 'reports',
        body
      }).then((res) => {
        this.logger.info('Create Report Response', res);
        return res;
      }).catch((reason) => {
        this.logger.error('Create Report Error', reason);
        return reason;
      });
    }).catch((reason) => {
      this.logger.error('Failure when converting emails to uuids', reason);
      return reason;
    });
  },

  /**
   * Retrieve the user UUID associated with each supplied email. If an email with no user
   * is found an error is thrown. If multiple such emails exist only the first encountered
   * throws an error.
   *
   * @param {Array.<String>} emails A list of emails to resolve
   * @returns {Promise} The UUIDs associated with the emails
   */
  asUUIDs(emails) {
    if (!emails) {
      throw new Error('Invalid parameter');
    }
    if (emails.length <= 0) {
      return Promise.resolve([]);
    }
    const promises = [];
    emails.forEach((userEmail) => {
      promises.push(
        // The people list API only supports a single email
        this.spark.people.list({email: userEmail})
          .then((result) => {
            if (result.items.length <= 0) {
              throw new Error('Unable to find user with email ' + userEmail);
            }
            // User id is base64 encoded and of the format Y2lzY29zcGFyazovL3VzL1BFT1BMRS81ZDU5Yjc5NS02ZmEyLTQ2NTQtOGVjMi03NjlkYjE1YzBkOWU
            const decodedId = Buffer.from(result.items[0].id, 'base64').toString();
            // Decode and strip out the uuid ciscospark://us/PEOPLE/5d59b795-6fa2-4654-8ec2-769db15c0d9e
            const uuid = decodedId.substring(decodedId.lastIndexOf('/') + 1, decodedId.length);
            return uuid;
          })
      );
    });
    return Promise.all(promises);
  },

  @waitForValue('@')
  getReport(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports/' + id
    }).then((res) => {
      this.logger.info('Get Report Response', res);
      return res;
    }).catch((reason) => {
      this.logger.error('Get Report Error', reason);
      return reason;
    });
  },

  @waitForValue('@')
  getReports() {
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports'
    }).then((res) => {
      this.logger.info('Get Reports Response', res);
      return res;
    }).catch((reason) => {
      this.logger.error('Get Reports Error', reason);
      return reason;
    });
  },

  @waitForValue('@')
  deleteReport(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'DELETE',
      service: 'ediscovery',
      resource: 'reports/' + id
    }).then((res) => {
      this.logger.info('Delete Report Response', res);
      return res;
    }).catch((reason) => {
      this.logger.error('Delete Report Error', reason);
      return reason;
    });
  },

  @waitForValue('@')
  restartReport(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'PUT',
      service: 'ediscovery',
      resource: 'reports/' + id
    }).then((res) => {
      this.logger.info('Restart Report Response', res);
      return res;
    }).catch((reason) => {
      this.logger.error('Restart Report Error', reason);
      return reason;
    });
  },


  /**
   * Retrieve the content summary for a specified report
   *
   * @param {UUID} The report id
   * @returns {Promise} The report content summary
   */
  @waitForValue('@')
  getContentSummary(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    let offset = 0;
    const size = 10;
    let contentSummary = [];

    function getNextContentSummaryPage(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: 'reports/' + id + '/contents/summary',
        qs: {offset, size}
      }).then((res) => {
        plugin.logger.info(res);
        contentSummary = contentSummary.concat(res.body);
        if (res.body.length < size) {
          return contentSummary;
        }
        offset += size;
        return getNextContentSummaryPage(plugin);
      }).catch((reason) => {
        plugin.logger.error(reason);
        return reason;
      });
    }

    return getNextContentSummaryPage(this);
  },

  @waitForValue('@')
  getPagedContentSummary(reportId, offset, size) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports/' + id + '/contents/summary',
      qs: {offset, size}
    }).then((res) => {
      this.logger.info(res);
      return res;
    }).catch((reason) => {
      this.logger.error(reason);
      return reason;
    });
  },

  /**
   * Retrieve the content for a specified report
   *
   * @param {UUID} The report id
   * @returns {Promise} The report content
   */
  @waitForValue('@')
  getContent(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    let offset = 0;
    const size = 10;
    let content = [];

    function getNextContentPage(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: 'reports/' + id + '/contents',
        qs: {offset, size}
      }).then((res) => {
        plugin.logger.info(res);
        content = content.concat(res.body);
        if (res.body.length < size) {
          return content;
        }
        offset += size;
        return getNextContentPage(plugin);
      }).catch((reason) => {
        plugin.logger.error(reason);
        return reason;
      });
    }

    return getNextContentPage(this);
  },

  @waitForValue('@')
  getPagedContent(reportId, offset, size) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports/' + id + '/contents',
      qs: {offset, size}
    }).then((res) => {
      this.logger.info(res);
      return res;
    }).catch((reason) => {
      this.logger.error(reason);
      return reason;
    });
  },

  @waitForValue('@')
  generateReport(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    return this.getReport(reportId)
      .then((reportResponse) => {
        if (!reportResponse) {
          throw new Error('Unable to find report associated with id ' + reportId);
        }
        this.logger.info(reportResponse);

        let offset = 0;
        const size = 5;
        const reportGenerator = new ReportGenerator({reportId});

        function decryptNextActivities(plugin) {
          return plugin.request({
            method: 'GET',
            service: 'ediscovery',
            resource: 'reports/' + reportId + '/contents',
            qs: {offset, size}
          })
            .then((response) => {
              const contents = response.body;
              return plugin._decryptActivities(contents);
            })
            .then((activities) => {
              if (activities && Array.isArray(activities) && activities.length > 0) {
                reportGenerator.add(activities);
                if (activities.length < size) {
                  // No more activities to decrypt
                  return activities;
                }
                // Add activities to the report, increment and decrypt next activities
                offset += size;
                return decryptNextActivities(plugin);
              }
              return activities;
            })
            .catch((error) => {
              plugin.logger.error(error);
              return error;
            });
        }

        return decryptNextActivities(this).then(() => reportGenerator.saveAs());
      })
      .catch((error) => {
        this.logger.error(error);
        return error;
      });
  },

  /**
   * Decrypt the messages found on the activities.
   * @param {Object[]} activities An array of activities with encrypted messages
   * @returns {Promise<[any]>} The activities with their messages decrypted
   */
  _decryptActivities(activities) {
    const promises = [];
    for (let i = 0; i < activities.length; i += 1) {
      const activity = activities[i];
      if (activity.verb === 'post' && activity.objectDisplayName && activity.encryptionKeyUrl) {
        const textPromise = this.spark.internal.encryption.decryptText(activity.encryptionKeyUrl, activity.objectDisplayName, activity.actorId)
          .then((decryptedMessage) => {
            // Replace encrypted message with the decrypted version
            activity.objectDisplayName = decryptedMessage;
            return activity;
          })
          .catch((error) => {
            this.logger.error(`Unable to decrypt message due to error: ${error}`);
            return activity;
          });
        promises.push(textPromise);
      }
      else if (activity.verb === 'share' && activity.files && activity.files.length && activity.encryptionKeyUrl) {
        for (let i = 0; i < activity.files.length; i += 1) {
          const file = activity.files[i];
          if (file && file.displayName && file.scr) {
            const filenamePromise = this.spark.internal.encryption.decryptText(activity.encryptionKeyUrl, file.displayName, activity.actorId)
              .catch((error) => {
                this.logger.error(`Unable to decrypt filename due to error: ${error}`);
                return Promise.reject(error);
              });
            const fileContentPromise = this.spark.internal.encryption.decryptScr(activity.encryptionKeyUrl, file.scr, activity.actorId)
              .then((decryptedScr) => this.spark.internal.encryption.download(decryptedScr))
              .catch((error) => {
                this.logger.error(`Unable to download/decrypt file content due to error: ${error}`);
                return Promise.reject(error);
              });
            // Return once both promises have resolved
            const filePromise = Promise.all([filenamePromise, fileContentPromise])
              .then((values) => {
                file.name = values[0];
                file.content = values[1];
                return activity;
              })
              .catch(() => activity); // TODO: What should be done with the activity if the file download/decryption fails?
            promises.push(filePromise);
          }
        }
      }
      else {
        promises.push(Promise.resolve(activity));
      }
    }

    return Promise.all(promises);
  }

});

export default Ediscovery;
