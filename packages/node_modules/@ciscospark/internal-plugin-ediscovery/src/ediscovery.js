/* eslint-disable prefer-template */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {waitForValue, SparkPlugin} from '@ciscospark/spark-core';

import reportRequest from './report-request';
import ReportGenerator from './report-generator';

const Ediscovery = SparkPlugin.extend({
  namespace: 'Ediscovery',

  @waitForValue('@')
  createReport(emails, keywords, spaceNames, spaceIds, range) {
    if (!emails || !keywords || !spaceNames || !spaceIds) {
      throw new Error('Invalid parameter(s)');
    }

    const self = this;
    return this.asUUIDs(emails).then((uuids) => {
      const body = reportRequest;
      body.userIds = uuids;
      body.keywords = keywords;
      body.spaceNames = spaceNames;
      body.spaceIds = spaceIds;
      body.range = range;

      return self.request({
        method: 'POST',
        service: 'ediscovery',
        resource: 'reports',
        body
      }).then((res) => {
        this.logger.info('Create Report Response', res);
        return res;
      }).catch((reason) => {
        this.logger.error('Create Report Error', reason);
        return reason;
      });
    }).catch((reason) => {
      this.logger.error('Failure when converting emails to uuids', reason);
      return reason;
    });
  },

  /**
   * Retrieve the user UUID associated with each supplied email. If an email with no user
   * is found an error is thrown. If multiple such emails exist only the first encountered
   * throws an error.
   *
   * @param {Array.<String>} emails A list of emails to resolve
   * @returns {Promise} The UUIDs associated with the emails
   */
  asUUIDs(emails) {
    if (!emails) {
      throw new Error('Invalid parameter');
    }
    if (emails.length <= 0) {
      return Promise.resolve([]);
    }
    const promises = [];
    emails.forEach((userEmail) => {
      promises.push(
        // The people list API only supports a single email
        this.spark.people.list({email: userEmail})
          .then((result) => {
            if (result.items.length <= 0) {
              throw new Error('Unable to find user with email ' + userEmail);
            }
            // User id is base64 encoded and of the format Y2lzY29zcGFyazovL3VzL1BFT1BMRS81ZDU5Yjc5NS02ZmEyLTQ2NTQtOGVjMi03NjlkYjE1YzBkOWU
            const decodedId = Buffer.from(result.items[0].id, 'base64').toString();
            // Decode and strip out the uuid ciscospark://us/PEOPLE/5d59b795-6fa2-4654-8ec2-769db15c0d9e
            const uuid = decodedId.substring(decodedId.lastIndexOf('/') + 1, decodedId.length);
            return uuid;
          })
      );
    });
    return Promise.all(promises);
  },

  @waitForValue('@')
  getReport(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports/' + id
    }).then((res) => {
      this.logger.info('Get Report Response', res);
      return res;
    }).catch((reason) => {
      this.logger.error('Get Report Error', reason);
      return reason;
    });
  },

  @waitForValue('@')
  getReports() {
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports'
    }).then((res) => {
      this.logger.info('Get Reports Response', res);
      return res;
    }).catch((reason) => {
      this.logger.error('Get Reports Error', reason);
      return reason;
    });
  },

  @waitForValue('@')
  deleteReport(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'DELETE',
      service: 'ediscovery',
      resource: 'reports/' + id
    }).then((res) => {
      this.logger.info('Delete Report Response', res);
      return res;
    }).catch((reason) => {
      this.logger.error('Delete Report Error', reason);
      return reason;
    });
  },

  @waitForValue('@')
  restartReport(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'PUT',
      service: 'ediscovery',
      resource: 'reports/' + id
    }).then((res) => {
      this.logger.info('Restart Report Response', res);
      return res;
    }).catch((reason) => {
      this.logger.error('Restart Report Error', reason);
      return reason;
    });
  },


  /**
   * Retrieve the content summary for a specified report
   *
   * @param {UUID} The report id
   * @returns {Promise} The report content summary
   */
  @waitForValue('@')
  async getContentSummary(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    let offset = 0;
    const pageSize = 10;
    const contentSummary = [];

    function getNextContentSummaryPage(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: 'reports/' + id + '/contents/summary',
        qs: {offset, pageSize}
      }).then((res) => {
        plugin.logger.info(res);
        contentSummary.concat(res.body);
        if (res.body.length < pageSize) {
          return contentSummary;
        }
        offset += pageSize;
        return getNextContentSummaryPage(plugin);
      }).catch((reason) => {
        plugin.logger.error(reason);
        return reason;
      });
    }

    return getNextContentSummaryPage(this);
  },

  @waitForValue('@')
  getPagedContentSummary(reportId, offset, size) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports/' + id + '/contents/summary',
      qs: {offset, size}
    }).then((res) => {
      this.logger.info(res);
      return res;
    }).catch((reason) => {
      this.logger.error(reason);
      return reason;
    });
  },

  /**
   * Retrieve the content for a specified report
   *
   * @param {UUID} The report id
   * @returns {Promise} The report content
   */
  @waitForValue('@')
  getContent(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    let offset = 0;
    const pageSize = 10;
    const content = [];

    function getNextContentPage(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: 'reports/' + id + '/contents',
        qs: {offset, pageSize}
      }).then((res) => {
        plugin.logger.info(res);
        content.concat(res.body);
        if (res.body.length < pageSize) {
          return content;
        }
        offset += pageSize;
        return getNextContentPage(plugin);
      }).catch((reason) => {
        plugin.logger.error(reason);
        return reason;
      });
    }

    return getNextContentPage(this);
  },

  @waitForValue('@')
  getPagedContent(reportId, offset, size) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    const id = reportId;
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports/' + id + '/contents',
      qs: {offset, size}
    }).then((res) => {
      this.logger.info(res);
      return res;
    }).catch((reason) => {
      this.logger.error(reason);
      return reason;
    });
  },

  @waitForValue('@')
  generateReport(reportId) {
    if (!reportId) {
      throw new Error('Invalid parameter(s)');
    }

    return this.getReport(reportId)
      .then((reportResponse) => {
        if (!reportResponse) {
          throw new Error('Unable to find report associated with id ' + reportId);
        }

        this.logger.info(reportResponse);

        // TODO: Hard coded for now
        const activityCount = 20000; // reportResponse.body.contentCounter.activityCount;
        const numberToRetrieve = 1000;
        const promises = [];
        const reportGenerator = new ReportGenerator();

        // Retrieve the activities
        for (let offset = 0; offset < activityCount; offset += numberToRetrieve) {
          const promise = this.getPagedContent(reportId, offset, numberToRetrieve).then((response) => {
            const activities = response.body;
            if (activities) {
              // Add activities to the report
              reportGenerator.add(reportId, activities);
            }
          });

          promises.push(promise);
        }

        // Download the zip once all the activites have been added
        return Promise.all(promises).then(() => reportGenerator.saveAs(reportId));
      })
      .catch((reason) => this.logger.error(reason));
  }
});

export default Ediscovery;
