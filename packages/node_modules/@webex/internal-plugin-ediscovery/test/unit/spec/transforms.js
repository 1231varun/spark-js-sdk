import EDiscovery from '@webex/internal-plugin-ediscovery';
import Transforms from '@webex/internal-plugin-ediscovery/src/transforms';
import ReportRequest from '@webex/internal-plugin-ediscovery/src/report-request';
import MockWebex from '@webex/test-helper-mock-webex';
import sinon from 'sinon';
import {assert} from '@webex/test-helper-chai';

describe('EDiscovery Transform Tests', () => {
  const encryptedText = 'this text has been encrypted';
  const decryptedText = 'this text has been decrypted';
  const decryptedScr = 'this scr has been decrypted';

  const ctx = {transform: sinon.stub().returns(Promise.resolve())};

  ctx.webex = new MockWebex({children: {ediscovery: EDiscovery}});
  ctx.webex.internal = {
    device: {
      deviceType: 'FAKE_DEVICE'
    },
    encryption: {
      encryptText: sinon.stub().returns(Promise.resolve(encryptedText)),
      decryptText: sinon.stub().returns(Promise.resolve(decryptedText)),
      decryptScr: sinon.stub().returns(Promise.resolve(decryptedScr)),
      kms: {
        createUnboundKeys: sinon.stub().returns(Promise.resolve([{userIds: 'e20d6180-2b95-11e9-8f7a-59e7a3b4e375', uri: 'kms://ciscospark.com/keys/32471db7-3d71-4fd1-b36c-0a1fe9efae2d'}])),
        createResource: sinon.stub().returns(Promise.resolve())
      }
    }
  };
  let object;

  afterEach(() => {
    ctx.transform.resetHistory();
    ctx.webex.internal.encryption.encryptText.resetHistory();
    ctx.webex.internal.encryption.decryptText.resetHistory();
    ctx.webex.internal.encryption.decryptScr.resetHistory();
    ctx.webex.internal.encryption.kms.createUnboundKeys.resetHistory();
    ctx.webex.internal.encryption.kms.createResource.resetHistory();
  });

  describe('Report Request Transforms', () => {
    let reportRequest;

    beforeEach(() => {
      reportRequest = new ReportRequest();
      reportRequest.name = 'test report';
      reportRequest.description = '';
      reportRequest.spaceNames = ['test space 1'];
      reportRequest.emails = ['email1@test.com', 'email2@test.com'];
      reportRequest.keywords = [];
    });

    describe('Encrypt ReportRequest Tests', () => {
      it('Calls the correct encrypt functions when transforming a report request', () => {
        // body IS a ReportRequest
        object = {body: reportRequest};
        const result = Transforms.encryptReportRequest(ctx, object)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.encryptText, 4);
            assert.equal(reportRequest.name, encryptedText);
            assert.equal(reportRequest.description, '');
            assert.equal(reportRequest.spaceNames[0], encryptedText);
            assert.equal(reportRequest.emails[0], encryptedText);
            assert.equal(reportRequest.emails[1], encryptedText);
            // unencryptedEmails should be copied from emails before decryption
            assert.equal(reportRequest.unencryptedEmails[0], 'email1@test.com');
            assert.equal(reportRequest.unencryptedEmails[1], 'email2@test.com');
            assert.empty(reportRequest.keywords);
            // this should be populated by request to kms
            assert.notEqual(reportRequest.encryptionKeyUrl, '');
          });

        return result;
      });
    });

    describe('Decrypt ReportRequest Tests', () => {
      it('Calls the correct decrypt functions when transforming a report request', () => {
        // body CONTAINS a ReportRequest
        object = {body: {reportRequest}};
        // object to be decrypted must have an encryption key
        reportRequest.encryptionKeyUrl = 'kms://ciscospark.com/keys/32471db7-3d71-4fd1-b36c-0a1fe9efae2d';
        const result = Transforms.decryptReportRequest(ctx, object)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 4);
            assert.equal(reportRequest.name, decryptedText);
            assert.equal(reportRequest.description, '');
            assert.equal(reportRequest.spaceNames[0], decryptedText);
            assert.equal(reportRequest.emails[0], decryptedText);
            assert.equal(reportRequest.emails[1], decryptedText);
            assert.empty(reportRequest.keywords);
          });

        return result;
      });

      it('Does not attempt to decrypt a report request if there is no encryption key url', () => {
        // body CONTAINS a ReportRequest
        object = {body: {reportRequest}};
        const result = Transforms.decryptReportRequest(ctx, object)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 0);
          });

        return result;
      });
    });
  });

  describe('Report Content Transform', () => {
    describe('Decrypt Content Tests', () => {
      let activity;
      let contentSummary;
      const reportId = 'cbf0323f-44e9-4b56-8514-a0a7ed3b333a';

      beforeEach(() => {
        activity = {};
        activity.activityId = 'f0f8af74-17cf-312f-9f53-64f2400aff54';
        activity.verb = 'post';
        activity.actorId = 'f1c2a410-2b94-11e9-8db0-679e818b2dec';
        activity.actorDisplayName = 'user1';
        activity.targetId = '8ceb2dbf-7a2c-41bf-91bb-a42a37d69b74';
        activity.objectDisplayName = 'encrypted content';
        activity.encryptionKeyUrl = 'kms://ciscospark.com/keys/09274c9c-b7c6-41a3-9948-e0657884a5c1';

        object = {body: activity};

        contentSummary = {};
        contentSummary.spaceId = '0';
        contentSummary.spaceName = 'spaceName';
        contentSummary.isOneOnOne = false;
        contentSummary.participants = ['7765121f-f04e-4bae-8f83-16ac80a3315b', 'cbf0323f-44e9-4b56-8514-a0a7ed3b333a', 'e0325f64-ae51-4821-9f8b-9d238f49d81b'];
        contentSummary.participantDisplayNames = ['user1', 'user2', 'user3'];
        contentSummary.encryptionKeyUrl = 'kms://ciscospark.com/keys/f38b40de-f415-487f-81b2-2f02e9a3c555';

        ctx.webex.internal.ediscovery = {getContentSummaryBySpaceId: sinon.stub().returns(Promise.resolve(contentSummary))};
      });

      afterEach(() => ctx.webex.internal.ediscovery.getContentSummaryBySpaceId.resetHistory());

      it('Calls the correct decrypt functions when transforming activities', () => {
        const result = Transforms.decryptReportContent(ctx, object, reportId)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 1);
            assert.equal(activity.objectDisplayName, decryptedText);
            assert.equal(activity.spaceName, contentSummary.spaceName);
          });

        return result;
      });

      it('Creates spaceName from participantDisplayNames for one to one spaces', () => {
        contentSummary.isOneOnOne = true;
        // one to one conversations have only 2 participants
        contentSummary.participants = ['7765121f-f04e-4bae-8f83-16ac80a3315b', 'cbf0323f-44e9-4b56-8514-a0a7ed3b333a'];
        contentSummary.participantDisplayNames = ['user1', 'user2'];
        // spacename should be undefined for one on one conversations
        contentSummary.spaceName = undefined;
        const result = Transforms.decryptReportContent(ctx, object, reportId)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 1);
            assert.equal(activity.objectDisplayName, decryptedText);
            assert.equal(activity.spaceName, 'user1 & user2');
          });

        return result;
      });

      it('Removes sender from participantDisplayNames', () => {
        const result = Transforms.decryptReportContent(ctx, object, reportId)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 1);
            assert.equal(activity.objectDisplayName, decryptedText);
            // as the sender, user1 should be removed
            assert.equal(activity.participantDisplayNames, 'user2,user3');
          });

        return result;
      });

      it('Does not call any decrypt functions when transforming add activities', () => {
        object.body.verb = 'add';
        // object display name for add activity is a uuid
        const uuid = 'fe76d712-76ae-44ce-aa30-2caa938a9853';

        object.body.objectDisplayName = uuid;
        const result = Transforms.decryptReportContent(ctx, object, reportId)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 0);
            assert.equal(activity.objectDisplayName, uuid);
            assert.equal(activity.spaceName, contentSummary.spaceName);
          });

        return result;
      });

      it('Calls the correct decrypt functions when transforming file share activities', () => {
        object.body.verb = 'share';
        // there should be no other content for a share
        object.body.objectDisplayName = undefined;
        object.body.files = [{displayName: 'file name', scr: 'eyJhbGciOi...'}];
        const result = Transforms.decryptReportContent(ctx, object, reportId)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 1);
            assert.callCount(ctx.webex.internal.encryption.decryptScr, 1);
            assert.equal(activity.objectDisplayName, undefined);
            assert.equal(activity.files[0].displayName, decryptedText);
            assert.equal(activity.files[0].scr, decryptedScr);
          });

        return result;
      });

      it('Calls the correct decrypt functions when transforming file share activities with Microsoft shared link info', () => {
        object.body.verb = 'share';
        // there should be no other content for a share
        object.body.objectDisplayName = undefined;
        object.body.files = [{displayName: 'file name', scr: 'eyJhbGciOi...', microsoftSharedLinkInfo: {driveId: '1', itemId: '2'}}];
        const result = Transforms.decryptReportContent(ctx, object, reportId)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 3);
            assert.callCount(ctx.webex.internal.encryption.decryptScr, 1);
            assert.equal(activity.objectDisplayName, undefined);
            assert.equal(activity.files[0].displayName, decryptedText);
            assert.equal(activity.files[0].scr, decryptedScr);
            assert.equal(activity.files[0].microsoftSharedLinkInfo.driveId, decryptedText);
            assert.equal(activity.files[0].microsoftSharedLinkInfo.itemId, decryptedText);
          });

        return result;
      });

      it('Adds error to activity if error found while retrieving space', () => {
        contentSummary.error = 'error';
        const result = Transforms.decryptReportContent(ctx, object, reportId)
          .then(() => {
            assert.equal(activity.error, contentSummary.error);
          });

        return result;
      });
    });
  });

  describe('Report Content Summary Transform', () => {
    describe('Decrypt ContentSummary Tests', () => {
      let space;

      beforeEach(() => {
        space = {};
        space.spaceId = '91facb42-c96f-441d-b45c-718ba5a71786';
        space.spaceName = 'test space';
        space.isOneOnOne = true;
        space.participants = ['93b4bd25-ed19-4c72-81a4-a9c8b6241708', 'cbf0323f-44e9-4b56-8514-a0a7ed3b333a'];
        space.participantDisplayNames = ['user1', 'user1'];
        space.encryptionKeyUrl = 'kms://ciscospark.com/keys/b1567590-f875-468d-b9d2-d1767b856c7c';

        object = {body: space};
      });

      it('Calls the correct decrypt functions when transforming report content summary', () => {
        const result = Transforms.decryptReportContentSummary(ctx, object)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 1);
            assert.equal(space.spaceName, decryptedText);
            assert.equal(space.error, undefined);
          });

        return result;
      });

      it('Does not attempt to decrypt a spacename if there is none', () => {
        // empty the list of participants
        object.body.spaceName = undefined;
        const result = Transforms.decryptReportContentSummary(ctx, object)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 0);
            assert.equal(space.spaceName, undefined);
          });

        return result;
      });

      it('Does not attempt to decrypt a space if there are no participants', () => {
        // empty the list of participants
        object.body.participants = [];
        const result = Transforms.decryptReportContentSummary(ctx, object)
          .then(() => {
            assert.callCount(ctx.webex.internal.encryption.decryptText, 0);
            assert.notEqual(space.spaceName, decryptedText);
            assert.notEmpty(space.error);
          });

        return result;
      });
    });
  });
});
