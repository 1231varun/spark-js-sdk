/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-encryption';
import '@ciscospark/internal-plugin-conversation';

import {registerInternalPlugin} from '@ciscospark/spark-core';
import {has} from 'lodash';

import EDiscovery from './ediscovery';

registerInternalPlugin('ediscovery', EDiscovery, {
  payloadTransformer: {
    predicates: [
      {
        name: 'decryptReportRequest',
        direction: 'inbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body.reportRequest'));
        },
        extract(object) {
          return Promise.resolve(object.body.reportRequest);
        }
      },
      {
        name: 'decryptReportRequestArray',
        direction: 'inbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body[0].reportRequest'));
        },
        extract(object) {
          return Promise.resolve(object.body);
        }
      },
      {
        name: 'transformReportRequestEmailsToUUIDS',
        direction: 'outbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body.emails'));
        },
        extract(object) {
          return Promise.resolve(object.body);
        }
      },
      {
        name: 'encryptReportRequest',
        direction: 'outbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body.keywords'));
        },
        extract(object) {
          return Promise.resolve(object.body);
        }
      },
      {
        name: 'decryptReportContent',
        direction: 'inbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body.activityId'));
        },
        extract(object) {
          return Promise.resolve(object.body);
        }
      },
      {
        name: 'decryptReportContentArray',
        direction: 'inbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body[0].activityId'));
        },
        extract(object) {
          return Promise.resolve(object);
        }
      }
    ],
    transforms: [
      {
        name: 'decryptReportRequest',
        direction: 'inbound',
        fn(ctx, object) {
          if (!object || !object.encryptionKeyUrl) {
            return Promise.resolve();
          }

          let keywordPromises = [];
          if (object.keywords) {
            keywordPromises = Promise.all(object.keywords.map((keyword) => ctx.spark.internal.encryption.decryptText(object.encryptionKeyUrl, keyword)))
              .then((decryptedKeywords) => {
                object.keywords = decryptedKeywords;
              });
          }

          let emailPromises = [];
          if (object.emails) {
            emailPromises = Promise.all(object.emails.map((email) => ctx.spark.internal.encryption.decryptText(object.encryptionKeyUrl, email)))
              .then((decryptedEmails) => {
                object.emails = decryptedEmails;
              });
          }

          return Promise.all([
            ctx.transform('decryptTextProp', 'name', object.encryptionKeyUrl, object),
            ctx.transform('decryptTextProp', 'description', object.encryptionKeyUrl, object)
          ].concat(keywordPromises, emailPromises));
        }
      },
      {
        name: 'decryptReportRequestArray',
        direction: 'inbound',
        fn(ctx, array) {
          if (!array) {
            return Promise.resolve();
          }

          return Promise.all(array.map((item) => ctx.transform('decryptReportRequest', item.reportRequest)));
        }
      },
      {
        name: 'transformReportRequestEmailsToUUIDS',
        direction: 'outbound',
        fn(ctx, object) {
          if (!object) {
            throw Error('Invalid parameter');
          }

          if (object.emails.length <= 0) {
            return Promise.resolve();
          }

          const promises = [];
          object.emails.forEach((userEmail) => {
            promises.push(
              // The people list API only supports a single email
              ctx.spark.people.list({email: userEmail})
                .then((res) => {
                  if (res.items.length <= 0) {
                    throw Error(`Unable to find user with email ${userEmail}`);
                  }
                  // User id is base64 encoded and of the format Y2lzY29zcGFyazovL3VzL1BFT1BMRS81ZDU5Yjc5NS02ZmEyLTQ2NTQtOGVjMi03NjlkYjE1YzBkOWU
                  const decodedId = Buffer.from(res.items[0].id, 'base64').toString();
                  // Decode and strip out the uuid ciscospark://us/PEOPLE/5d59b795-6fa2-4654-8ec2-769db15c0d9e
                  const uuid = decodedId.substring(decodedId.lastIndexOf('/') + 1, decodedId.length);
                  return uuid;
                })
                .catch((reason) => Promise.reject(reason))
            );
          });
          return Promise.all(promises)
            .then((uuids) => {
              object.userIds = uuids;
            });
        }
      },
      {
        name: 'encryptReportRequest',
        direction: 'outbound',
        fn(ctx, object) {
          if (!object) {
            return Promise.resolve();
          }
          return ctx.spark.internal.encryption.kms.createUnboundKeys({count: 1})
            .then((keys) => {
              if (keys && keys.length > 0 && keys[0]) {
                object.encryptionKeyUrl = keys[0].uri;
                return ctx.spark.internal.encryption.kms.createResource({userIds: [keys[0].userId], keys})
                  .then(() => {
                    const keywordPromises = Promise.all(object.keywords.map((keyword) => ctx.spark.internal.encryption.encryptText(keys[0], keyword)))
                      .then((encryptedKeywords) => {
                        object.keywords = encryptedKeywords;
                      });

                    const emailPromises = Promise.all(object.emails.map((email) => ctx.spark.internal.encryption.encryptText(keys[0], email)))
                      .then((encryptedEmails) => {
                        object.emails = encryptedEmails;
                      });

                    return Promise.all([
                      ctx.transform('encryptTextProp', 'name', keys[0], object),
                      ctx.transform('encryptTextProp', 'description', keys[0], object)
                    ].concat(keywordPromises, emailPromises));
                  });
              }
              return Promise.resolve();
            })
            .catch((reason) => Promise.reject(reason));
        }
      },
      {
        name: 'decryptReportContent',
        direction: 'inbound',
        fn(ctx, object, reportId = '') {
          if (!object) {
            return Promise.resolve();
          }

          const promises = [];
          if (object.verb === 'post' && object.objectDisplayName && object.encryptionKeyUrl) {
            promises.push(ctx.spark.internal.encryption.decryptText(object.encryptionKeyUrl, object.objectDisplayName, {onBehalfOf: object.actorId})
              .then((decryptedMessage) => {
                object.objectDisplayName = decryptedMessage;
              })
              .catch((reason) => {
                ctx.spark.logger.info(`Decrypt message error for activity ${object.activityId}: ${reason}`);
                return object; // TODO - determine correct behaviour when an individual operation fails
              }));
          }
          else if (object.verb === 'share' && object.files && object.files.length && object.encryptionKeyUrl) {
            for (let i = 0; i < object.files.length; i += 1) {
              if (object.files[i] && object.files[i].displayName && object.files[i].scr) {
                if (object.files[i].displayName !== '<Missing>') { // shared whiteboards are given this displayname by the ED service, if unchecked it causes a parsing error
                  promises.push(ctx.spark.internal.encryption.decryptText(object.encryptionKeyUrl, object.files[i].displayName, {onBehalfOf: object.actorId})
                    .then((decryptedFilename) => {
                      object.files[i].displayName = decryptedFilename;
                    })
                    .catch((reason) => {
                      ctx.spark.logger.info(`Decrypt filename error for activity ${object.activityId}: ${reason}`);
                      return object; // TODO - determine correct behaviour when an individual operation fails
                    }));
                }
                promises.push(ctx.spark.internal.encryption.decryptScr(object.encryptionKeyUrl, object.files[i].scr, {onBehalfOf: object.actorId})
                  .then((decryptedScr) => {
                    object.files[i].scr = decryptedScr;
                  })
                  .catch((reason) => {
                    ctx.spark.logger.info(`Decrypt file scr error for activity ${object.activityId}: ${reason}`);
                    return object; // TODO - determine correct behaviour when an individual operation fails
                  }));
              }
            }
          }
          else if (object.verb === 'share' && object.whiteboards && object.whiteboards.length && object.encryptionKeyUrl && reportId) {
            promises.push(ctx.spark.internal.ediscovery.getContentSummaryBySpaceId(reportId, object.targetId)
              .then((res) => {
                if (res.body.spaceId === object.targetId && res.body.participants.length) {
                  for (let i = 0; i < object.whiteboards.length; i += 1) {
                    if (object.whiteboards[i] && object.whiteboards[i].scr) {
                      return ctx.spark.internal.encryption.decryptScr(object.encryptionKeyUrl, object.whiteboards[i].scr, {onBehalfOf: res.body.participants[0]})
                        .then((decryptedScr) => {
                          object.whiteboards[i].scr = decryptedScr;
                        })
                        .catch((reason) => {
                          ctx.spark.logger.info(`Decrypt whiteboard scr error for activity ${object.activityId}: ${reason}`);
                          return object; // TODO - determine correct behaviour when an individual operation fails
                        });
                    }
                  }
                }
                return object;
              }));
          }
          return Promise.all(promises);
        }
      },
      {
        name: 'decryptReportContentArray',
        direction: 'inbound',
        fn(ctx, object) {
          if (!object) {
            return Promise.resolve();
          }
          // the report id is needed in order to retrieve space information for activities with whiteboards so that
          // the list of users in those spaces can be accessed and the content can be decrypted on their behalf
          const reportId = object.options.resource.split('/')[1];
          return Promise.all(object.body.map((item) => ctx.transform('decryptReportContent', item, reportId)));
        }
      }
    ]
  }
});

export default EDiscovery;

export {config} from './config';
export {default as ReportGenerator} from './report-generator';
export {default as ReportRequest} from './report-request';
