/* eslint-disable prefer-template */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {waitForValue, SparkPlugin} from '@ciscospark/spark-core';
import Map from 'babel-runtime/core-js/map';

import ReportGenerator from './report-generator';

/**
 * @class EDiscovery is used by compliance officers to run compliance reports
 *
 */
const EDiscovery = SparkPlugin.extend({
  namespace: 'EDiscovery',

  session: {
    contentSummaryCache: {
      type: 'object',
      default() {
        return new Map();
      }
    }
  },

  @waitForValue('@')
  /**
   * Creates a compliance report with a specific set of search parameters
   * @param {Object} reportRequest - A set of criteria for determining the focus of the search
   * @returns {Promise<ResponseEntity>} Http response containing the new report record
   */
  createReport(reportRequest) {
    if (!reportRequest) {
      throw Error('Undefined parameter');
    }

    const body = reportRequest;
    return this.request({
      method: 'POST',
      service: 'ediscovery',
      resource: 'reports',
      body
    });
  },

  @waitForValue('@')
  /**
   * Retrieves information relating to a specified report
   * @param {UUID} reportId - Id of the report being requested
   * @returns {Promise<ResponseEntity<ReportRecord>>} Http response containing the specified report record
   */
  getReport(reportId) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }

    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    });
  },

  @waitForValue('@')
  /**
   * Retrieves all the compliance officers reports
   * @returns {Promise<ResponseEntity<Array<ReportRecord>>>} Http Response containing a list of report records
   */
  getReports() {
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports'
    });
  },

  @waitForValue('@')
  /**
   * Deletes a specified report
   * @param {UUID} reportId - Id of the report being requested for deletion
   * @returns {Promise<ResponseEntity>} HttpResponse indicating if delete was successful
   */
  deleteReport(reportId) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }

    return this.request({
      method: 'DELETE',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    });
  },

  @waitForValue('@')
  /**
   * Restarts a completed or cancelled report so that it begins again from scratch
   * @param {UUID} reportId - Id of the report being requested
   * @returns {Promise<ResponseEntity<ReportRecord>>} Http response containing the report record
   */
  restartReport(reportId) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }

    return this.request({
      method: 'PUT',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    });
  },

  @waitForValue('@')
  /**
   * Retrieves a list of the conversations relevant to a specified report
   * @param {UUID} reportId - Id of the report being requested
   * @param {boolean} writeToCache - Can be set to true if the content summary is expected to be accessed very frequently for space information
   * @returns {Promise<ResponseEntity<ContentSummary>>} Http response containing the content summary
   */
  getContentSummary(reportId, writeToCache = false) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }

    let offset = 0;
    const size = 100;
    let contentSummary = [];

    function getNextContentSummaryPage(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: `reports/${reportId}/contents/summary`,
        qs: {offset, size}
      })
        .then((res) => {
          // The results can be written to the contentSummaryCache in situations where information for a space is likely to be accessed very frequently
          if (writeToCache) {
            if (!plugin.contentSummaryCache.has(reportId)) {
              plugin.contentSummaryCache.set(reportId, new Map());
            }
            for (let i = 0; i < res.body.length; i += 1) {
              plugin.contentSummaryCache.get(reportId).set(res.body[i].spaceId, res.body[i]);
            }
          }

          contentSummary = contentSummary.concat(res.body);
          if (res.body.length < size) {
            return contentSummary;
          }
          offset += size;
          return getNextContentSummaryPage(plugin);
        });
    }

    return getNextContentSummaryPage(this);
  },

  @waitForValue('@')
  /**
   * Retrieves information for a specific conversation relevant to a specified report
   * @param {UUID} reportId - Id of the report which contains the relevant content summary
   * @param {UUID} spaceId = Id of the conversation being requested
   * @returns {Promise<ResponseEntity<ContentSummary>>} Http response containing the specified content summary
   */
  _getContentSummaryBySpaceId(reportId, spaceId) {
    if (!reportId || !spaceId) {
      throw Error('Undefined parameter(s)');
    }

    // If the content summary for this report has already been cached then it can be retrieved from there instead of making a network call to ediscovery
    if (this.contentSummaryCache.has(reportId) && this.contentSummaryCache.get(reportId).has(spaceId)) {
      return this.contentSummaryCache.get(reportId).get(spaceId);
    }

    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: `reports/${reportId}/contents/summary/${spaceId}`
    });
  },

  @waitForValue('@')
  /**
   * Retrieves content associated with a report
   * @param {UUID} reportId - Id of the report which contains the content
   * @param {UUID} offset - Start position from which to retrieve content
   * @param {UUID} size - Number of activities to retrieve
   * @returns {Promise<ResponseEntity<[Activity]>>} Http response containing the activities
   */
  getContent(reportId, {offset, size}) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }

    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: `reports/${reportId}/contents`,
      qs: {offset, size}
    });
  },

  @waitForValue('@')
  /**
   * Generates the report content and triggers the download of the content
   * @param {UUID} reportId - Id of the report being requested
   * @returns {List<Activities>} HttpResponse
   */
  generateReport(reportId) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }

    let offset = 0;
    const size = 100;
    const reportGenerator = new ReportGenerator({reportId});

    const self = this;

    function processNextActivities(plugin) {
      return self.getContent(reportId, {offset, size})
        .then((res) => {
          const promises = [];
          const activities = res.body;

          // Dequeue the activities until the list is empty
          while (activities.length) {
            // Grab the 1st activity
            const activity = activities.shift();

            // set defaults for new properties
            activity.spaceName = '';
            activity.participantDisplayNames = '';
            // Get the information for the space the activity occured in
            const spaceInfoPromise = plugin._getContentSummaryBySpaceId(reportId, activity.targetId)
              .then((spaceSummary) => {
                activity.spaceName = spaceSummary.spaceName || spaceSummary.participantDisplayNames.toString().replace(',', ' & ');
                const filteredParticipantDisplayNames = spaceSummary.participantDisplayNames.filter((value) => value !== activity.actorDisplayName);
                activity.participantDisplayNames = filteredParticipantDisplayNames.toString();
              });

            let fileDownloadPromise = Promise.resolve();
            // If the activity contains a file or whiteboard download it and add to the report
            if (activity.verb === 'share' && (activity.files || activity.whiteboards)) {
              fileDownloadPromise = plugin._downloadFileContent(activity.files || activity.whiteboards)
                .then((downloadedFiles) => {
                  activity.files = downloadedFiles;
                  // store all file and whiteboard content as files, they are handled in the same manner
                  delete activity.whiteboards;
                });
            }

            // Even if there was an error in one or both operations we should add the activity to the generator and move on
            const activityPromise = Promise.all([spaceInfoPromise, fileDownloadPromise])
              .finally(() => reportGenerator.add(activity));

            promises.push(activityPromise);
          }

          return promises;
        })
        .then((promises) => {
          if (promises.length < size) {
            // No more activities to retrieve
            return promises;
          }
          // Increment and recursively retrieve the next activities
          offset += size;
          return processNextActivities(plugin)
            // Return all the promises
            .then((nextPromises) => promises.concat(nextPromises));
        });
    }

    // Retrieve the entire content summary for this report so that it will be cached prior to report generation
    return this.getContentSummary(reportId, true)
      .then(() => processNextActivities(this) // Once all the activities have been added generate the last part of the report
        .then((promises) => Promise.all(promises)
          .then(() => {
            // This report can be removed from the cache once all content has been retrieved
            this.contentSummaryCache.delete(reportId);
            reportGenerator.generate();
          })));
  },

  /**
   * Download the files associated with an activity
   * @param {Object} files - An array of files or whiteboards for download
   * @returns {Promise<[any]>} - The array with its file content downloaded (where applicable)
   */
  _downloadFileContent(files) {
    if (!files) {
      return Promise.resolve().then(() => []);
    }

    const promises = [];
    let includedFilesSize = 0;
    for (let i = 0; i < files.length; i += 1) {
      const file = files[i];
      if (file && file.scr && file.scr.loc) {
        if (file.fileSize > 52428800) {
          file.content = `File filtered as it exceeds the size limit of 50 MB. File Size: ${file.fileSize}`;
        }
        else {
          includedFilesSize += file.fileSize;
          if (includedFilesSize > 78643200) {
            file.content = `File filtered as the files associated with the activity exceed the size limit of 75 MB. Included Files Size: ${includedFilesSize}`;
          }
          else {
            promises.push(this.spark.internal.encryption.download(file.scr)
              .then((content) => {
                file.content = content;
              })
              .catch((reason) => {
                this.logger.error(`Unable to download file content due to error: ${reason}`);
              }));
          }
        }
      }
    }
    return Promise.all(promises).then(() => files);
  }

});

export default EDiscovery;
