/* eslint-disable prefer-template */
/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {waitForValue, SparkPlugin} from '@ciscospark/spark-core';

import ReportGenerator from './report-generator';

/**
 * @class EDiscovery is used by compliance officers to run compliance reports
 *
 */
const EDiscovery = SparkPlugin.extend({
  namespace: 'EDiscovery',

  @waitForValue('@')
  /**
   * Creates a compliance report with a specific set of search parameters
   * @param {Object} reportRequest - A set of criteria for determining the focus of the search
   * @returns {Promise<ResponseEntity>} Http response containing the new report record
   */
  createReport(reportRequest) {
    if (!reportRequest || !reportRequest.emails || !reportRequest.range) {
      throw Error('Invalid parameter(s)');
    }

    const body = reportRequest;
    return this.request({
      method: 'POST',
      service: 'ediscovery',
      resource: 'reports',
      body
    })
      .catch((reason) => {
        throw Error(reason);
      });
  },

  @waitForValue('@')
  /**
   * Retrieves information relating to a specified report
   * @param {UUID} reportId - Id of the report being requested
   * @returns {Promise<ResponseEntity<ReportRecord>>} Http response containing the specified report record
   */
  getReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    })
      .catch((reason) => {
        throw Error(reason);
      });
  },

  @waitForValue('@')
  /**
   * Retrieves all the compliance officers reports
   * @returns {Promise<ResponseEntity<Array<ReportRecord>>>} Http Response containing a list of report records
   */
  getReports() {
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports'
    })
      .catch((reason) => {
        throw Error(reason);
      });
  },

  @waitForValue('@')
  /**
   * Deletes a specified report
   * @param {UUID} reportId - Id of the report being requested for deletion
   * @returns {Promise<ResponseEntity>} HttpResponse indicating if delete was successful
   */
  deleteReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    return this.request({
      method: 'DELETE',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    })
      .catch((reason) => {
        throw Error(reason);
      });
  },

  @waitForValue('@')
  /**
   * Restarts a completed or cancelled report so that it begins again from scratch
   * @param {UUID} reportId - Id of the report being requested
   * @returns {Promise<ResponseEntity<ReportRecord>>} Http response containing the report record
   */
  restartReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    return this.request({
      method: 'PUT',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    })
      .catch((reason) => {
        throw Error(reason);
      });
  },

  @waitForValue('@')
  /**
   * Retrieves a list of the conversations relevant to a specified report
   * @param {UUID} reportId - Id of the report being requested
   * @returns {Promise<ResponseEntity<ContentSummary>>} Http response containing the content summary
   */
  getContentSummary(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    let offset = 0;
    const size = 100;
    let contentSummary = [];

    function getNextContentSummaryPage(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: `reports/${reportId}/contents/summary`,
        qs: {offset, size}
      })
        .then((res) => {
          contentSummary = contentSummary.concat(res.body);
          if (res.body.length < size) {
            return contentSummary;
          }
          offset += size;
          return getNextContentSummaryPage(plugin);
        })
        .catch((reason) => {
          throw Error(reason);
        });
    }

    return getNextContentSummaryPage(this);
  },

  @waitForValue('@')
  /**
   * Retrieves a list of the conversations relevant to a specified report, paged with a specified offset and size
   * @param {UUID} reportId - Id of the report being requested
   * @param {long} offset - the starting index of the results the caller wants
   * @param {long} size - the number of conversations the caller wants
   * @returns {Promise<ResponseEntity<ContentSummary>>} Http response containing the specified content summary
   */
  getPagedContentSummary(reportId, offset, size) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: `reports/${reportId}/contents/summary`,
      qs: {offset, size}
    })
      .catch((reason) => {
        throw Error(reason);
      });
  },

@waitForValue('@')
  /**
   * Retrieves information for a specific conversation relevant to a specified report
   * @param {UUID} reportId - Id of the report which contains the relevant content summary
   * @param {UUID} spaceId = Id of the conversation being requested
   * @returns {Promise<ResponseEntity<ContentSummary>>} Http response containing the specified content summary
   */
  getContentSummaryBySpaceId(reportId, spaceId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: `reports/${reportId}/contents/summary/${spaceId}`
    })
      .catch((reason) => {
        throw Error(reason);
      });
  },

  @waitForValue('@')
  /**
   * Generates the report content and triggers the download of the content
   * @param {UUID} reportId - Id of the report being requested
   * @returns {List<Activities>} HttpResponse
   */
  generateReport(reportId) {
    if (!reportId) {
      throw Error('Invalid parameter(s)');
    }

    let offset = 0;
    const size = 100;
    const reportGenerator = new ReportGenerator({reportId});

    function processNextActivities(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: `reports/${reportId}/contents`,
        qs: {offset, size}
      })
        .then((res) => {
          const promises = [];
          const activities = res.body;

          // Dequeue the activities until the list is empty
          while (activities.length) {
            // Grab the 1st activity
            const activity = activities.shift();
            // If the activity contains a file download it, but either way add the file to the report
            const promise = plugin._downloadFileContent(activity)
              .then((downloadedActivity) => reportGenerator.add(downloadedActivity));
            promises.push(promise);
          }

          return promises;
        })
        .then((promises) => {
          if (promises.length < size) {
            // No more activities to retrieve
            return promises;
          }
          // Increment and recursively retrieve the next activities
          offset += size;
          return processNextActivities(plugin)
            // Return all the promises
            .then((nextPromises) => promises.concat(nextPromises));
        })
        .catch((reason) => {
          throw Error(reason);
        });
    }

    // Once all the activities have been added generate the last part of the report
    return processNextActivities(this)
      .then((promises) => Promise.all(promises)
        .then(() => reportGenerator.generate()));
  },

  /**
   * Download the files associated with an activity
   * @param {Object} activity - An activity, potentially, with files to download
   * @returns {Promise<[any]>} - The activity with its file content downloaded (where applicable)
   */
  _downloadFileContent(activity) {
    if (activity.verb !== 'share' || !activity.files || !activity.files.length) {
      return Promise.resolve().then(() => activity);
    }

    const promises = [];
    let includedFilesSize = 0;
    for (let i = 0; i < activity.files.length; i += 1) {
      const file = activity.files[i];
      if (file && file.scr && file.scr.loc) {
        if (file.fileSize > 52428800) {
          file.content = `File filtered as it exceeds the size limit of 50 MB. File Size: ${file.fileSize}`;
        }
        else {
          includedFilesSize += file.fileSize;
          if (includedFilesSize > 78643200) {
            file.content = `File filtered as the files associated with the activity exceed the size limit of 75 MB. Included Files Size: ${includedFilesSize}`;
          }
          else {
            promises.push(this.spark.internal.encryption.download(file.scr)
              .then((content) => {
                activity.files[i].content = content;
              })
              .catch((reason) => {
                this.logger.error(`Unable to download file content for activity ${activity.activityId} due to error: ${reason}`);
              }));
          }
        }
      }
      else if (activity.verb === 'share' && activity.whiteboards && activity.whiteboards.length) {
        for (let i = 0; i < activity.whiteboards.length; i += 1) {
          if (activity.whiteboards[i] && activity.whiteboards[i].scr && activity.whiteboards[i].scr.loc) {
            promises.push(this.spark.internal.encryption.download(activity.whiteboards[i].scr)
              .then((content) => {
                activity.whiteboards[i].content = content;
              })
              .catch((reason) => {
                this.logger.error(`Unable to download whiteboard content for activity ${activity.activityId} due to error: ${reason}`);
              }));
          }
        }
      }
    }
    return Promise.all(promises).then(() => activity);
  }

});

export default EDiscovery;
