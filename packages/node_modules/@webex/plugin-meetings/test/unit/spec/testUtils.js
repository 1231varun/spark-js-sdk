
/**
   * @param {number} max
   * @param {string} event
   * @param {EventEmitter} emitter
   * @param {string} msg
   * @returns {Promise<mixed>} Resolves with the results of the event
   */

const max = 20000;
const waitForSpy = (spy, event) => {
  let timer;
  return Promise.race([
    new Promise((resolve, reject) => {
      timer = setTimeout(() => {
        reject(new Error(` ${event} did not fire`));
      }, max);
    }),
    new Promise((resolve) => {
      const interval = setInterval(() => {
        if (spy.calledOnce) {
          clearTimeout(timer);
          clearInterval(interval);
          resolve(spy.args[0][0]);
        }
      }, 1000);
    })
  ]);
};

const waitForStateChange = (meeting, state) => {
  let timer;
  return Promise.race([
    new Promise((resolve, reject) => {
      timer = setTimeout(() => {
        reject(new Error(` ${state} did not change`));
      }, max);
    }),
    new Promise((resolve) => {
      const interval = setInterval(() => {
        if (meeting.state === state) {
          clearTimeout(timer);
          clearInterval(interval);
          resolve(meeting.locusInfo.parsedLocus.states);
        }
      }, 1000);
    })
  ]);
};

const waitForCallEnded = (user, email) => {
  let timer;
  return Promise.race([
    new Promise((resolve, reject) => {
      timer = setTimeout(() => {
        reject(new Error('meeting still exists'));
      }, max);
    }),
    new Promise((resolve) => {
      const interval = setInterval(() => {
        if (user.spark.meetings.getMeetingByType('sipUri', email) === undefined) {
          clearTimeout(timer);
          clearInterval(interval);
          resolve();
        }
        else {
          console.log('NOT FOUND ', user.spark.meetings.getMeetingByType('sipUri', email));
        }
      }, 3000);
    })
  ]);
};

export default {
  waitForSpy,
  waitForStateChange,
  waitForCallEnded
};

