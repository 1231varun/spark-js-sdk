
/**
   * @param {number} max
   * @param {string} event
   * @param {EventEmitter} emitter
   * @param {string} msg
   * @returns {Promise<mixed>} Resolves with the results of the event
   */

const max = 20000;
const waitForSpy = (spy, event) => {
  let timer;
  return Promise.race([
    new Promise((resolve, reject) => {
      timer = setTimeout(() => {
        reject(new Error(` ${event} did not fire`));
      }, max);
    }),
    new Promise((resolve) => {
      const interval = setInterval(() => {
        if (spy.calledOnce) {
          clearTimeout(timer);
          clearInterval(interval);
          resolve(spy.args[0][0]);
        }
      }, 1000);
    })
  ]);
};

const waitForStateChange = (meeting, state) => {
  let timer;
  return Promise.race([
    new Promise((resolve, reject) => {
      timer = setTimeout(() => {
        reject(new Error(` ${state} did not change`));
      }, max);
    }),
    new Promise((resolve) => {
      const interval = setInterval(() => {
        if (meeting.state === state) {
          clearTimeout(timer);
          clearInterval(interval);
          resolve(meeting.locusInfo.parsedLocus.states);
        }
      }, 1000);
    })
  ]);
};

const waitForCallEnded = (user, email) => {
  let timer;
  return Promise.race([
    new Promise((resolve, reject) => {
      timer = setTimeout(() => {
        reject(new Error(` ${user.name} meeting still exists`));
      }, max);
    }),
    new Promise((resolve) => {
      const interval = setInterval(() => {
        if (user.spark.meetings.getMeetingByType('sipUri', email) === undefined) {
          clearTimeout(timer);
          clearInterval(interval);
          resolve();
        }
        else {
          console.log('NOT FOUND ', user.spark.meetings.getMeetingByType('sipUri', email));
        }
      }, 3000);
    })
  ]);
};

const syncAndEndMeeting = (user) => user.spark.meetings.syncMeetings()
  .then(() => {
    const promise = [];
    const meetings = user.spark.meetings.getAllMeetings();

    if (Object.key(meetings).length === 0) {
      return Promise.resolve();
    }
    Object.keys(meetings)
      .forEach((key) => {
        promise.push(meetings[key].leave());
      });

    return Promise.all(promise);
  })
  .then(() => new Promise((resolve) => {
    const interval = setInterval(() => {
      if (Object.keys(user.spark.meetings.getAllMeetings()).length === 0) {
        clearInterval(interval);
        resolve();
      }
      else {
        console.log('End Meetings before test failed');
      }
    }, 3000);
  }))
  .catch((e) => {
    console.log('ERROR on syncMeeting', e);
  });

export default {
  waitForSpy,
  waitForStateChange,
  waitForCallEnded,
  syncAndEndMeeting
};

