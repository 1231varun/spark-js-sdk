/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import MockSpark from '@ciscospark/test-helper-mock-spark';
import Device from '@ciscospark/internal-plugin-wdm';
import Mercury from '@ciscospark/internal-plugin-mercury';
import Meetings from '@webex/plugin-meetings';
import PersonalMeetingRoom from '@webex/plugin-meetings/src/personal-meeting-room';
import Reachability from '@webex/plugin-meetings/src/reachability';
import MeetingCollection from '@webex/plugin-meetings/src/meetings/collection';
import MeetingsUtil from '@webex/plugin-meetings/src/meetings/util';
import Meeting from '@webex/plugin-meetings/src/meeting';


describe('plugin-meetings', () => {
  let spark;
  console.log(Meetings);
  describe('meetings', () => {
    beforeEach(() => {
      spark = new MockSpark({
        children: {
          device: Device,
          mercury: Mercury,
          meetings: Meetings
        }
      });
    });
    it('has a spark instance with a meetings property', () => {
      assert.exists(spark, 'spark was initialized with children');
      assert.exists(spark.meetings, 'meetings child was set up on the spark instance');
    });
    describe('Public API Contracts', () => {
      describe('gets', () => {
        describe('#getReachability', () => {
          describe('before #setReachability', () => {
            it('does not get a reachability instance', () => {
              const reachability = spark.meetings.getReachability();
              assert.notExists(reachability, 'reachability is undefined because #setReachability has not been called');
            });
          });
          describe('after #setReachability', () => {
            beforeEach(() => {
              spark.meetings.setReachability();
              const reachabilityMocker = spark.meetings.getReachability();
              sinon.stub(reachabilityMocker, 'gatherReachability').returns(true);
            });
            it('gets the reachability data instance from spark.meetings', () => {
              const reachability = spark.meetings.getReachability();
              assert.exists(reachability, 'reachability is defined because #setReachability has been called');
              assert.typeOf(reachability, 'object', 'should be an object');
              assert.instanceOf(reachability, Reachability, 'should be a reachability instance');
            });
          });
        });
        describe('#getPersonalMeetingRoom', () => {
          it('gets the personal meeting room instance from spark.meetings', () => {
            const personalMeetingRoom = spark.meetings.getPersonalMeetingRoom();
            assert.exists(personalMeetingRoom, 'personal meeting room instance is set up at object creation');
            assert.typeOf(personalMeetingRoom, 'object', 'should be an object');
            assert.instanceOf(personalMeetingRoom, PersonalMeetingRoom, 'should be a personal meeting room instance');
          });
        });
        describe('Static shortcut proxy methods', () => {
          let staticMeetings;
          beforeEach(() => {
            staticMeetings = Meetings;
          });
          afterEach(() => {
            staticMeetings = null;
          });
          describe('MeetingCollection getByKey proxies', () => {
            beforeEach(() => {
              MeetingCollection.getByKey = sinon.stub().returns(true);
            });
            describe('#getMeetingByType', () => {
              it('gets the Meeting instance from MeetingCollection using type and value', () => {
                staticMeetings.getMeetingByType('test', 'test');
                assert.calledOnce(MeetingCollection.getByKey);
                assert.calledWith(MeetingCollection.getByKey, 'test', 'test');
              });
            });
          });
          describe('MeetingCollection getAll proxies', () => {
            beforeEach(() => {
              MeetingCollection.getAll = sinon.stub().returns(true);
            });
            describe('#getAllMeetings', () => {
              it('calls MeetingCollection to get all meetings with supplied options', () => {
                staticMeetings.getAllMeetings({test: 'test'});
                assert.calledOnce(MeetingCollection.getAll);
                assert.calledWith(MeetingCollection.getAll, {test: 'test'});
              });
            });
            describe('#getActiveMeetings', () => {
              it('calls MeetingCollection to get all active meetings using the active option', () => {
                staticMeetings.getActiveMeetings();
                assert.calledOnce(MeetingCollection.getAll);
                assert.calledWith(MeetingCollection.getAll, {active: true});
              });
            });
            describe('#getScheduledMeetings', () => {
              it('calls MeetingCollection to get all scheduled meetings using the scheduled option', () => {
                staticMeetings.getScheduledMeetings();
                assert.calledOnce(MeetingCollection.getAll);
                assert.calledWith(MeetingCollection.getAll, {scheduled: true});
              });
            });
          });
        });
      });
      describe('#syncMeetings', () => {
        describe('succesful requests', () => {
          beforeEach(() => {
            spark.meetings.request.getActiveMeetings = sinon.stub().returns(Promise.resolve({loci: [{url: 'test'}]}));
          });
          describe('when meeting is returned', () => {
            let onFullLocus;
            beforeEach(() => {
              onFullLocus = sinon.stub().returns(true);
              MeetingCollection.getByKey = sinon.stub().returns({locusInfo: {onFullLocus}});
            });
            it('tests the sync meeting calls for existing meeting', async () => {
              await spark.meetings.syncMeetings();
              assert.calledOnce(spark.meetings.request.getActiveMeetings);
              assert.calledOnce(MeetingCollection.getByKey);
              assert.calledOnce(onFullLocus);
              assert.calledWith(spark.meetings.request.getActiveMeetings);
              assert.calledWith(MeetingCollection.getByKey, 'locusUrl', 'test');
              assert.calledWith(onFullLocus, {url: 'test'});
            });
          });
          describe('when meeting is not returned', () => {
            let initialSetup;
            beforeEach(() => {
              initialSetup = sinon.stub().returns(true);
              MeetingCollection.getByKey = sinon.stub().returns(null);
              spark.meetings.create = sinon.stub().returns(Promise.resolve({locusInfo: {initialSetup}}));
            });
            it('tests the sync meeting calls for not existing meeting', async () => {
              await spark.meetings.syncMeetings();
              assert.calledOnce(spark.meetings.request.getActiveMeetings);
              assert.calledOnce(MeetingCollection.getByKey);
              assert.calledOnce(initialSetup);
              assert.calledOnce(spark.meetings.create);
              assert.calledWith(spark.meetings.request.getActiveMeetings);
              assert.calledWith(MeetingCollection.getByKey, 'locusUrl', 'test');
              assert.calledWith(spark.meetings.create, {url: 'test'}, 'LOCUS_ID');
              assert.calledWith(initialSetup, {url: 'test'});
            });
          });
        });
      });
      describe('#create', () => {
        beforeEach(() => {
          spark.meetings.createMeeting = sinon.stub().returns(Promise.resolve(true));
        });
        it('calls createMeeting and returns its promise', async () => {
          const create = spark.meetings.create('test', 'test');
          assert.exists(create.then);
          await create;
          assert.calledOnce(spark.meetings.createMeeting);
          assert.calledWith(spark.meetings.createMeeting, 'test', 'test');
        });
      });
      describe('#createMeeting', () => {
        beforeEach(() => {
          spark.internal.device.userId = 'test';
          spark.internal.device.url = 'test';
          MeetingCollection.set = sinon.stub().returns(true);
          MeetingsUtil.getMeetingAddedType = sinon.stub().returns('test');
          MeetingsUtil.extractDestination = sinon.stub().returns('test');
        });
        describe('successful MeetingInfo.#fetchMeetingInfo', () => {
          beforeEach(() => {
            spark.meetings.meetingInfo.fetchMeetingInfo = sinon.stub().returns(Promise.resolve(true));
          });
          it('creates the meeting from a successful meeting info fetch', async () => {
            const meeting = await spark.meetings.createMeeting('test', 'test');
            assert.instanceOf(meeting, Meeting, 'createMeeting should eventually resolve to a Meeting Object');
            assert.calledOnce(spark.meetings.meetingInfo.fetchMeetingInfo);
            assert.calledOnce(MeetingsUtil.extractDestination);
            assert.calledOnce(MeetingsUtil.getMeetingAddedType);
            // TODO: stub on the meeting instance
            // TODO: expect the trigger
            assert.calledWith(spark.meetings.meetingInfo.fetchMeetingInfo, 'test');
            assert.calledWith(MeetingsUtil.extractDestination, 'test', 'test');
            assert.calledWith(MeetingsUtil.getMeetingAddedType, 'test');
          });
        });
        describe('rejected MeetingInfo.#fetchMeetingInfo', () => {
          beforeEach(() => {
            spark.meetings.meetingInfo.fetchMeetingInfo = sinon.stub().returns(Promise.reject());
          });
          it('creates the meeting from a rejected meeting info fetch', async () => {
            const meeting = await spark.meetings.createMeeting('test', 'test');
            assert.instanceOf(meeting, Meeting, 'createMeeting should eventually resolve to a Meeting Object');
            assert.calledOnce(spark.meetings.meetingInfo.fetchMeetingInfo);
            assert.calledOnce(MeetingsUtil.extractDestination);
            assert.calledOnce(MeetingsUtil.getMeetingAddedType);
            // TODO: expect the trigger
            // TODO: stub on the meeting instance
            assert.calledWith(spark.meetings.meetingInfo.fetchMeetingInfo, 'test');
            assert.calledWith(MeetingsUtil.extractDestination, 'test', 'test');
            assert.calledWith(MeetingsUtil.getMeetingAddedType, 'test');
          });
        });
      });
      describe('#destroy', () => {
        beforeEach(() => {
          MeetingCollection.remove = sinon.stub().returns(true);
        });
        describe('correctly established meeting', () => {
          it('tests the destroy removal from the collection', () => {
            const response = spark.meetings.destroy({id: 'test'}, 'test', 'test');
            assert.calledOnce(MeetingCollection.remove);
            assert.calledWith(MeetingCollection.remove, 'test');
            // TODO: expect the trigger
            assert.equal(response, 'test');
          });
        });
        describe('incorrectly established meeting', () => {
          it('tests the destroy removal from the collection, and should throw an error without a meeting', () => {
            assert.throws(() => spark.meetings.destroy(null, 'test', 'test'), Error, 'Cannot remove a meeting without an id from the MeetingCollection.');
          });
          it('tests the destroy removal from the collection, and should throw an error without a meeting.id', () => {
            assert.throws(() => spark.meetings.destroy({}, 'test', 'test'), Error, 'Cannot remove a meeting without an id from the MeetingCollection.');
          });
        });
      });
    });
  });
});
