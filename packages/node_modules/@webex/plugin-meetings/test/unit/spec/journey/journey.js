
import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import testUtils from '@webex/plugin-meetings/test/unit/spec/journey/testUtils';

import MediaUtil from '../../../../src/media/util';

require('dotenv').config();

const sparkTestUsers = require('@webex/plugin-meetings/test/unit/spec/journey/sparkTestUsers');

let userSet, alice, bob, chris;
// TODO: Merge all the test it sections into one

describe('plugin-meeting', () => {
  before(() => {
    MediaUtil.createPeerConnection = sinon.stub().returns(true);
    MediaUtil.createMediaStream = sinon.stub().returns(true);

    return sparkTestUsers.generateTestUsers({count: 3})
      .then((users) => {
        userSet = users;
        alice = userSet[0];
        bob = userSet[1];
        chris = userSet[2];
        alice.name = 'alice';
        bob.name = 'bob';
      })
      .then(() => Promise.all([testUtils.syncAndEndMeeting(alice),
        testUtils.syncAndEndMeeting(bob)]))
      .catch((error) => {
        console.log(error);
      });
  });

  after(() => {
    const promise = [];

    userSet.forEach((user) => {
      promise.push(user.spark.internal.mercury.disconnect());
    });

    return Promise.all(promise)
      .then(() => sparkTestUsers.remove(userSet));
    // TODO: end is not a function on browser object
  });

  // Alice calls bob and bob rejects it
  describe('End outgoing Call', () => {
    after(() => {
      alice.meeting = null;
      bob.meeting = null;
    });

    it('Alice Ends a outgoing meeting', () => Promise.all([
      testUtils.delayedPromise(alice.spark.meetings.create(bob.emailAddress)),
      testUtils.waitForEvents([{scope: alice.spark.meetings, event: 'meeting:added', user: alice}])
    ])
      .then(() => Promise.all([
        testUtils.delayedPromise(alice.meeting.join()),
        testUtils.waitForEvents([{scope: bob.spark.meetings, event: 'meeting:added', user: bob}])
      ]))
      .then(() => {
        // bob and alice have meeting object
        bob.meeting.acknowledge('INCOMING');
        assert.equal(bob.meeting.sipUri, alice.emailAddress);
        assert.equal(alice.meeting.sipUri, bob.emailAddress);
        assert.equal(bob.meeting.state, 'IDLE');
        assert.equal(alice.meeting.state, 'JOINED');
      })
      .then(function aliceLeavesMeetingAndBobGetsMeetingRemoved() {
        return Promise.all([
          testUtils.delayedPromise(alice.meeting.leave()),
          testUtils.waitForEvents([{scope: bob.spark.meetings, event: 'meeting:removed', user: bob}])
        ]);
      })
      .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT'))
      .then(() => Promise.all([
        testUtils.waitForCallEnded(alice, bob.emailAddress),
        testUtils.waitForCallEnded(bob, alice.emailAddress)
      ]))
      .then(() => {
        assert.equal(alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress), null);
        assert.equal(bob.spark.meetings.getMeetingByType('sipUri', alice.emailAddress), null);
      })
      .catch((err) => {
        console.log('ERROR JOIN ', err);
        throw err;
      }));
  });

  // The event was coming but incomplete
  // 1) Test user doesnt have locus tag information

  // Alice calls bob and bob rejects it
  describe('reject Incoming Call', () => {
    it('alice dials bob and bob receives meeting added', () => Promise.all([
      testUtils.delayedPromise(alice.spark.meetings.create(bob.emailAddress)),
      testUtils.waitForEvents([{scope: alice.spark.meetings, event: 'meeting:added', user: alice}])
    ])
      .then(() => Promise.all([
        testUtils.delayedPromise(alice.meeting.join()),
        testUtils.waitForEvents([{scope: bob.spark.meetings, event: 'meeting:added', user: bob}])
      ]))
      .then(function alicebobJoined() {
        assert.exists(bob.meeting);
        assert.exists(alice.meeting);
        assert.equal(bob.meeting.sipUri, alice.emailAddress);
        assert.equal(alice.meeting.sipUri, bob.emailAddress);
        assert.equal(bob.meeting.state, 'IDLE');
        assert.equal(alice.meeting.state, 'JOINED');
        assert.exists(bob.meeting.partner);
        assert.exists(alice.meeting.partner);
      })
      .then(function bobDeclinedCall() {
        return bob.meeting.acknowledge('INCOMING')
          .then(() => bob.meeting.decline('BUSY'))
          .then(() => testUtils.waitForStateChange(bob.meeting, 'DECLINED'))
          .catch((e) => { console.error('Bob decline call not successful', e); throw e; });
      })
      .then(function aliceLeaveMeeting() {
        assert.equal(alice.meeting.state, 'JOINED');

        return alice.meeting.leave()
          .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT'))
          .then(() => testUtils.waitForStateChange(bob.meeting, 'DECLINED'))
          .catch((e) => { console.error('alice was not able to leave the meeting', e); throw e; });
      })
      .then(function WaitForMeetingEnd() {
        return Promise.all([
          testUtils.waitForCallEnded(alice, bob.emailAddress),
          testUtils.waitForCallEnded(bob, alice.emailAddress)
        ])
          .then(() => {
            assert.equal(alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress), null);
            assert.equal(bob.spark.meetings.getMeetingByType('sipUri', alice.emailAddress), null);
          })
          .catch((e) => { console.error('Alice bob meeting is deleted', e); throw e; });
      }));
  });

  // Alice calls bob and bob rejects it
  describe('Successful 1:1 meeting (including Guest)', () => {
    it(' No previous Call', () => {
      assert.equal(Object.keys(bob.spark.meetings.getAllMeetings()), 0);
      assert.equal(Object.keys(alice.spark.meetings.getAllMeetings()), 0);
    });

    it('alice dials bob and bob receives meeting added', () => Promise.all([
      testUtils.delayedPromise(alice.spark.meetings.create(bob.emailAddress)),
      testUtils.waitForEvents([{scope: alice.spark.meetings, event: 'meeting:added', user: alice}])
    ])
      .then(function aliceJoinsMeeting() {
        return Promise.all([
          testUtils.delayedPromise(alice.meeting.join()),
          testUtils.waitForEvents([{scope: bob.spark.meetings, event: 'meeting:added', user: bob}])
        ]);
      })
      .then(() => assert.equal(bob.meeting.partner.state, 'JOINED'))
      .then(() => {
        console.log('bobs email address', bob.emailAddress);
        console.log('bob partner', bob.meeting.partner);
        console.log('bob members', bob.meeting.members.membersCollection.getAll());
      })
      .then(function bobJoinsMeeting() {
        bob.meeting.acknowledge('INCOMING');

        return Promise.all([
          testUtils.delayedPromise(bob.meeting.join()),
          testUtils.waitForEvents([{scope: alice.meeting.members, event: 'members:update', user: alice}])
        ]).then((response) => {
          console.log('alices self', alice.meeting.locusInfo.self);
          testUtils.waitForStateChange(bob.meeting, 'JOINED');
          testUtils.waitForStateChange(alice.meeting, 'JOINED');
          console.log('alice email address', alice.emailAddress);
          console.log('alice partner', alice.meeting.partner);
          console.log('alice members', alice.meeting.members.membersCollection.getAll());
          console.log('************************************');
          console.log('RESPONSE FOR BOB', response[1][0].result);
        });
      })
      // .then(() => new Promise((resolve) => {
      //   setTimeout(() => {
      //     console.log('print alices locus info participants', alice.meeting.locusInfo.participants);
      //     console.log('print alice members', alice.meeting.members.membersCollection.get(alice.meeting.members.selfId));
      //     const aliceParticipant = alice.meeting.members.membersCollection.get(alice.meeting.members.selfId).participant;
      //     const bobParticipant = bob.meeting.members.membersCollection.get(bob.meeting.members.selfId).participant;

      //     assert.equal(aliceParticipant.devices.length, 1);
      //     assert.equal(bobParticipant.devices.length, 1);
      //     assert.equal(aliceParticipant.state, 'JOINED');
      //     assert.equal(bobParticipant.state, 'JOINED');
      //     resolve();
      //   }, 5000);
      // }))
      .then(function aliceAndBobJoinedType() {
        assert.equal(bob.meeting.sipUri, alice.emailAddress);
        assert.equal(alice.meeting.sipUri, bob.emailAddress);
        assert.exists(alice.meeting.members.locusUrl);
        assert.equal(bob.meeting.state, 'JOINED');
        assert.equal(alice.meeting.state, 'JOINED');
        assert.equal(alice.meeting.type, 'CALL');
        assert.equal(bob.meeting.type, 'CALL');
      })
      .then(function aliceMeetingProperties() {
        // Make sure values exists after join
        console.log('MEETING *** ', alice.meeting);
        assert.exists(alice.meeting.userId);
        assert.exists(alice.meeting.deviceUrl);
        assert.exists(alice.meeting.partner);
        assert.exists(alice.meeting.type);
        assert.exists(alice.meeting.state);
        assert.exists(alice.meeting.muted);
        assert.exists(alice.meeting.guest);
        assert.exists(alice.meeting.joinedWith);
        assert.exists(alice.meeting.selfId);
        assert.exists(alice.meeting.selfIdentity);
      }));

    xit('alice adds chris as guest to 1:1 meeting', () =>
      Promise.all([
        testUtils.delayedPromise(alice.meeting.invite({emailAddress: chris.emailAddress})),
        testUtils.waitForEvents([{scope: chris.spark.meetings, event: 'meeting:added', user: chris}])
      ])
        .catch((e) => { console.error('Error adding chris as guest ', e); throw e; })
        .then(function memberUpdated() {
          assert.exists(chris.meeting);

          return Promise.all([
            testUtils.delayedPromise(chris.meeting.join()),
            testUtils.waitForEvents([{scope: alice.meeting.members, event: 'members:update'}])
          ])
            .then((response) => {
              console.log('MEMBER ADDED', response[1][0].result);
              assert.equal(alice.meeting.members.membersCollection.get(chris.meeting.members.selfId).participant.state, 'JOINED');
            })
            .then(() => testUtils.waitForStateChange(chris.meeting, 'JOINED'))
            .catch((e) => { console.error('Error chris joining the meeting ', e); throw e; });
        }));

    it('leave on the meeting object', () => Promise.all([
      testUtils.delayedPromise(alice.meeting.leave()),
      testUtils.waitForEvents([{scope: bob.meeting.members, event: 'members:update'}])
    ])
      .then((response) => {
        const {result} = response[1][0];
        const {updated} = result.delta;
        let aliceWhoLeftUpdate;

        Object.keys(updated).forEach((key) => {
          const member = updated[key];

          if (!member.isSelf) {
            aliceWhoLeftUpdate = member;
          }
        });

        assert.exists(aliceWhoLeftUpdate);
        assert.equal(aliceWhoLeftUpdate.isInMeeting, false);

        console.log(aliceWhoLeftUpdate);
        console.log('BOBS RESPONSE WHEN ALICE LEAVES', response[1][0].result);
      })
      .then(() => bob.leave())
      .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT'))
      .then(() => testUtils.waitForStateChange(bob.meeting, 'LEFT'))
      .then(() => Promise.all([
        testUtils.waitForCallEnded(alice, bob.emailAddress),
        testUtils.waitForCallEnded(bob, alice.emailAddress)
      ]))
      .then(() => {
        assert.equal(alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress), null);
        assert.equal(bob.spark.meetings.getMeetingByType('sipUri', alice.emailAddress), null);
      }));
  });
});
