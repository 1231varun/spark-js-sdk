/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import Meeting from '@webex/plugin-meetings/src/meeting';
import Members from '@webex/plugin-meetings/src/members';
import Roap from '@webex/plugin-meetings/src/roap';
import StateMachine from 'javascript-state-machine';
import MeetingRequest from '@webex/plugin-meetings/src/meeting/request';
import LocusInfo from '@webex/plugin-meetings/src/locus-info';
import MediaProperties from '@webex/plugin-meetings/src/media/properties';
import Events from '@webex/plugin-meetings/src/events';
import WebRTCStats from '@webex/plugin-meetings/src/stats';
import MeetingUtil from '@webex/plugin-meetings/src/meeting/util';
import Media from '@webex/plugin-meetings/src/media/index';
import PeerConnectionManager from '@webex/plugin-meetings/src/peer-connection-manager';
import ReconnectionManager from '@webex/plugin-meetings/src/reconnection-manager';

describe('plugin-meetings', () => {
  describe('meeting index', () => {
    let meeting;
    const mercury = {};
    const log = sinon.stub().returns(true);
    const trigger = sinon.stub().returns(true);
    const spark = {
      trigger,
      internal: {mercury},
      logger: {log},
      meetings: {config: {mediaSettings: {}}}
    };
    beforeEach(() => {
      meeting = new Meeting(
        {
          userId: 'test',
          resource: 'test',
          deviceUrl: 'test',
          locus: {url: 'test'}
        },
        {
          parent: spark
        }
      );
    });
    describe('Public Api Contract', () => {
      describe('#constructor', () => {
        it('should have created a meeting object with public properties', () => {
          assert.exists(meeting);
          assert.exists(meeting.spark);
          assert.exists(meeting.options);
          assert.exists(meeting.attrs);
          assert.exists(meeting.id);
          assert.equal(meeting.userId, 'test');
          assert.equal(meeting.resource, 'test');
          assert.equal(meeting.deviceUrl, 'test');
          assert.equal(meeting.roapSeq, 0);
          assert.deepEqual(meeting.meetingInfo, {});
          assert.instanceOf(meeting.members, Members);
          assert.instanceOf(meeting.roap, Roap);
          assert.isNull(meeting.reconnectionManager);
          assert.isNull(meeting.audio);
          assert.isNull(meeting.video);
          assert.instanceOf(meeting.state, StateMachine);
          assert.isNull(meeting.stats);
          assert.isNull(meeting.convoId);
          assert.equal(meeting.locusUrl, 'test');
          assert.isNull(meeting.sipUri);
          assert.isNull(meeting.partner);
          assert.isNull(meeting.type);
          assert.isNull(meeting.owner);
          assert.isNull(meeting.hostId);
          assert.isNull(meeting.policy);
          assert.instanceOf(meeting.meetingRequest, MeetingRequest);
          assert.instanceOf(meeting.locusInfo, LocusInfo);
          assert.instanceOf(meeting.mediaProperties, MediaProperties);
        });
      });
      describe('#invite', () => {
        beforeEach(() => {
          meeting.members.addMember = sinon.stub().returns(Promise.resolve('test'));
        });
        it('should proxy members #addMember and return a promise', async () => {
          const invite = meeting.invite('test', false);
          assert.exists(invite.then);
          await invite;
          assert.calledOnce(meeting.members.addMember);
          assert.calledWith(meeting.members.addMember, 'test', false);
        });
      });
      describe('#admit', () => {
        beforeEach(() => {
          meeting.members.admitMembers = sinon.stub().returns(Promise.resolve('test'));
        });
        it('should proxy members #admitMembers and return a promise', async () => {
          const admit = meeting.members.admitMembers(['test']);
          assert.exists(admit.then);
          await admit;
          assert.calledOnce(meeting.members.admitMembers);
          assert.calledWith(meeting.members.admitMembers, ['test']);
        });
      });
      describe('#getMembers', () => {
        it('should get the members object as an instance and return Members', async () => {
          const members = meeting.getMembers();
          assert.instanceOf(members, Members);
        });
      });
      describe('#getStats', () => {
        it('should create stats if not exists and return WebRTCStats', () => {
          assert.notOk(meeting.stats);
          meeting.createStats = sinon.stub().returns(new WebRTCStats({}, {parent: spark}));
          const stats = meeting.getStats();
          assert.calledOnce(meeting.createStats);
          assert.instanceOf(stats, WebRTCStats);
        });
      });
      describe('#isAudioMuted', () => {
        it('should get the audio muted status and return as a boolean', () => {
          const muted = meeting.isAudioMuted();
          assert.isNotOk(muted);
        });
      });
      describe('#isAudioSelf', () => {
        it('should get the audio self status and return as a boolean', () => {
          const self = meeting.isAudioSelf();
          assert.isNotOk(self);
        });
      });
      describe('#isVideoMuted', () => {
        it('should get the video muted status and return as a boolean', () => {
          const muted = meeting.isVideoMuted();
          assert.isNotOk(muted);
        });
      });
      describe('#isVideoSelf', () => {
        it('should get the video self status and return as a boolean', () => {
          const self = meeting.isVideoSelf();
          assert.isNotOk(self);
        });
      });
      describe('#setSipUri', () => {
        it('should set the sip Uri and return null', () => {
          assert.notOk(meeting.sipUri);
          meeting.setSipUri('test');
          assert.equal(meeting.sipUri, 'test');
        });
      });
      describe('#unsetRemoteStream', () => {
        it('should unset the remote stream and return null', () => {
          meeting.mediaProperties.unsetRemoteStream = sinon.stub().returns(true);
          meeting.unsetRemoteStream();
          assert.calledOnce(meeting.mediaProperties.unsetRemoteStream);
        });
      });
      describe('#unsetLocalStream', () => {
        it('should unset the local stream and return null', () => {
          meeting.mediaProperties.unsetLocalStream = sinon.stub().returns(true);
          meeting.unsetLocalStream();
          assert.calledOnce(meeting.mediaProperties.unsetLocalStream);
        });
      });
      describe('#unsetLocalShare', () => {
        it('should unset the local share stream and return null', () => {
          meeting.mediaProperties.unsetLocalShare = sinon.stub().returns(true);
          meeting.unsetLocalShare();
          assert.calledOnce(meeting.mediaProperties.unsetLocalShare);
        });
      });
      describe('#setPeerConnections', () => {
        it('should set the peer connections', () => {
        // TODO: handle with config
        //   meeting.mediaProperties.setPeerConnections = sinon.stub().returns(true);
        //   PeerConnectionManager.detectFailures = sinon.stub().returns(true);
        //   meeting.reconnect = sinon.stub().returns(true);
        //   meeting.setPeerConnections('test', 'test');
        //   assert.calledOnce(meeting.mediaProperties.setPeerConnections);
        //   assert.calledWith(meeting.mediaProperties.setPeerConnections, 'test', 'test');
        //   assert.calledOnce(PeerConnectionManager.detectFailures);
        //   assert.calledWith(PeerConnectionManager.detectFailures, 'test', 'test', meeting.reconnect);
        //   assert.instanceOf(meeting.reconnectionManager, ReconnectionManager);
        });
      });
      describe('#closePeerConnections', () => {
        it('should close the peer connections, and return a promise', async () => {
          PeerConnectionManager.close = sinon.stub().returns(true);
          const pcs = meeting.closePeerConnections();
          assert.exists(pcs.then);
          await pcs;
          assert.calledTwice(PeerConnectionManager.close);
        });
      });
      describe('#unsetPeerConnections', () => {
        it('should unset the peer connections', () => {
          // TODO: handle with config
        });
      });
      describe('#muteAudio', () => {
        describe('before audio is defined', () => {
          it('should reject and return a promise', async () => {
            await meeting.muteAudio().catch((err) => {
              assert.instanceOf(err, Error);
            });
          });
        });
        describe('after audio is defined', () => {
          it('should return a promise resolution', async () => {
            const toggle = sinon.stub().returns(Promise.resolve(true));
            meeting.audio = {toggle};
            const audio = meeting.muteAudio();
            assert.exists(audio.then);
            await audio;
            assert.calledOnce(toggle);
            assert.calledWith(toggle, {mute: true, self: true});
          });
        });
      });
      describe('#unmuteAudio', () => {
        describe('before audio is defined', () => {
          it('should reject and return a promise', async () => {
            await meeting.unmuteAudio().catch((err) => {
              assert.instanceOf(err, Error);
            });
          });
        });
        describe('after audio is defined', () => {
          it('should return a promise resolution', async () => {
            const toggle = sinon.stub().returns(Promise.resolve(true));
            meeting.audio = {toggle};
            const audio = meeting.unmuteAudio();
            assert.exists(audio.then);
            await audio;
            assert.calledOnce(toggle);
            assert.calledWith(toggle, {mute: false, self: true});
          });
        });
      });
      describe('#muteVideo', () => {
        describe('before video is defined', () => {
          it('should reject and return a promise', async () => {
            await meeting.muteVideo().catch((err) => {
              assert.instanceOf(err, Error);
            });
          });
        });
        describe('after video is defined', () => {
          it('should return a promise resolution', async () => {
            const toggle = sinon.stub().returns(Promise.resolve(true));
            meeting.video = {toggle};
            const video = meeting.muteVideo();
            assert.exists(video.then);
            await video;
            assert.calledOnce(toggle);
            assert.calledWith(toggle, {mute: true, self: true});
          });
        });
      });
      describe('#unmuteVideo', () => {
        describe('before video is defined', () => {
          it('should reject and return a promise', async () => {
            await meeting.unmuteVideo().catch((err) => {
              assert.instanceOf(err, Error);
            });
          });
        });
        describe('after video is defined', () => {
          it('should return a promise resolution', async () => {
            const toggle = sinon.stub().returns(Promise.resolve(true));
            meeting.video = {toggle};
            const video = meeting.unmuteVideo();
            assert.exists(video.then);
            await video;
            assert.calledOnce(toggle);
            assert.calledWith(toggle, {mute: false, self: true});
          });
        });
      });
      describe('#joinWithMedia', () => {
        describe('resolution', () => {
          it('should success and return a promise', async () => {
            meeting.join = sinon.stub().returns(Promise.resolve('test'));
            meeting.getMediaStreams = sinon.stub().returns(Promise.resolve(['test', 'test']));
            meeting.addMedia = sinon.stub().returns(Promise.resolve('test'));
            await meeting.joinWithMedia();
            assert.calledOnce(meeting.join);
            assert.calledOnce(meeting.getMediaStreams);
          });
        });
        describe('rejection', () => {
          it('should error out and return a promise', async () => {
            meeting.join = sinon.stub().returns(Promise.reject());
            meeting.getMediaStreams = sinon.stub().returns(true);
            await meeting.joinWithMedia();
            assert.calledOnce(meeting.join);
            assert.notCalled(meeting.getMediaStreams);
          });
        });
      });
      describe('#getMediaStreams', () => {
        it('should proxy Media getUserMedia, and return a promise', async () => {
          Media.getUserMedia = sinon.stub().returns(Promise.resolve());
          await meeting.getMediaStreams();
          assert.calledOnce(Media.getUserMedia);
        });
      });
      describe('#join', () => {
        beforeEach(() => {
          meeting.ringing = sinon.stub().returns(true);
          meeting.setCorrelationId = sinon.stub().returns(true);
          MeetingUtil.cleanOptions = sinon.stub().returns(true);
          meeting.setLocus = sinon.stub().returns(true);
        });
        describe('successful', () => {
          beforeEach(() => {
            MeetingUtil.joinMeeting = sinon.stub().returns(Promise.resolve());
          });
          it('should join the meeting and return promise', async () => {
            const join = meeting.join();
            assert.exists(join.then);
            await join;
            assert.calledOnce(meeting.ringing);
            assert.calledOnce(meeting.setCorrelationId);
            assert.calledOnce(MeetingUtil.cleanOptions);
            assert.calledOnce(MeetingUtil.joinMeeting);
            assert.calledOnce(meeting.setLocus);
          });
        });
        describe('failure', () => {
          beforeEach(() => {
            MeetingUtil.joinMeeting = sinon.stub().returns(Promise.reject());
            meeting.logger.log = sinon.stub().returns(true);
          });
          describe('guest join', () => {
            beforeEach(() => {
              MeetingUtil.isPinOrGuest = sinon.stub().returns(true);
              MeetingUtil.hasOwner = sinon.stub().returns(false);
            });
            it('should try to join the meeting and return intent failure promise', async () => {
              await meeting.join().catch(() => {
                assert.calledOnce(meeting.ringing);
                assert.calledOnce(meeting.setCorrelationId);
                assert.calledOnce(MeetingUtil.cleanOptions);
                assert.calledOnce(MeetingUtil.joinMeeting);
              });
            });
          });
          describe('total failure', () => {
            beforeEach(() => {
              MeetingUtil.isPinOrGuest = sinon.stub().returns(false);
            });
          });
          it('should try to join the meeting and return promise reject', async () => {
            await meeting.join().catch(() => {
              assert.calledOnce(meeting.ringing);
              assert.calledOnce(meeting.setCorrelationId);
              assert.calledOnce(MeetingUtil.cleanOptions);
              assert.calledOnce(MeetingUtil.joinMeeting);
              assert.calledOnce(meeting.logger.log);
            });
          });
        });
      });
      describe('#addMedia', () => {
        beforeEach(() => {
          meeting.mediaProperties.setMediaDirection = sinon.stub().returns(true);
          meeting.audio = true;
          meeting.video = true;
          meeting.setLocalStream = sinon.stub().returns(true);
          meeting.setLocalShare = sinon.stub().returns(true);
          Media.attachMedia = sinon.stub().returns(Promise.resolve(['test', 'test']));
          meeting.setPeerConnections = sinon.stub().returns(true);
          meeting.setRemoteStream = sinon.stub().returns(true);
          meeting.setShareStream = sinon.stub().returns(true);
          meeting.roap.sendRoapMediaRequest = sinon.stub().returns(Promise.resolve());
          MeetingUtil.getSdps = sinon.stub().returns(true);
          PeerConnectionManager.setContentSlides = sinon.stub().returns(true);
        });
        it('should attach the media and return promise', async () => {
          const media = meeting.addMedia();
          assert.exists(media);
          await media;
          assert.calledOnce(meeting.mediaProperties.setMediaDirection);
          assert.calledOnce(meeting.setLocalStream);
          assert.calledOnce(meeting.setLocalShare);
          assert.calledOnce(Media.attachMedia);
          assert.calledOnce(PeerConnectionManager.setContentSlides);
          assert.calledOnce(meeting.setPeerConnections);
          assert.calledOnce(meeting.setRemoteStream);
          assert.calledOnce(meeting.setShareStream);
          assert.calledOnce(MeetingUtil.getSdps);
          assert.calledOnce(meeting.roap.sendRoapMediaRequest);
        });
      });
      describe('#acknowledge', () => {
        beforeEach(() => {
          meeting.meetingRequest.acknowledgeMeeting = sinon.stub().returns(Promise.resolve());
          meeting.ringing = sinon.stub().returns(true);
        });
        it('should acknowledge incoming and return a promise', async () => {
          const ack = meeting.acknowledge('INCOMING', false);
          assert.exists(ack.then);
          await ack;
          assert.calledOnce(meeting.meetingRequest.acknowledgeMeeting);
          assert.calledOnce(meeting.ringing);
        });
        it('should acknowledge a non incoming and return a promise', async () => {
          const ack = meeting.acknowledge('test', false);
          assert.exists(ack.then);
          await ack;
          assert.notCalled(meeting.meetingRequest.acknowledgeMeeting);
        });
      });
      describe('#decline', () => {
        beforeEach(() => {
          meeting.meetingRequest.declineMeeting = sinon.stub().returns(Promise.resolve());
          meeting.ringing = sinon.stub().returns(true);
        });
        it('should decline the meeting and trigger meeting destroy for 1:1', async () => {
          const spy = sinon.spy(Events, 'emit');
          await meeting.decline();
          assert.calledOnce(meeting.meetingRequest.declineMeeting);
          assert.calledOnce(meeting.ringing);
          assert.calledOnce(spy);
        });
      });
      describe('#leave', () => {
        beforeEach(() => {
          meeting.meetingRequest.leaveMeeting = sinon.stub().returns(Promise.resolve());
          meeting.closeLocalStream = sinon.stub().returns(true);
          meeting.closeLocalShare = sinon.stub().returns(true);
          meeting.closePeerConnections = sinon.stub().returns(true);
          meeting.unsetLocalStream = sinon.stub().returns(true);
          meeting.unsetLocalShare = sinon.stub().returns(true);
          meeting.unsetRemoteStream = sinon.stub().returns(true);
          meeting.unsetPeerConnections = sinon.stub().returns(true);
          meeting.roap.stop = sinon.stub().returns(Promise.resolve());
          meeting.logger.error = sinon.stub().returns(true);
        });
        it('should leave the meeting and return promise', async () => {
          const leave = meeting.leave();
          assert.exists(leave.then);
          await leave;
          assert.calledOnce(meeting.meetingRequest.leaveMeeting);
          assert.calledOnce(meeting.closeLocalStream);
          assert.calledOnce(meeting.closeLocalShare);
          assert.calledOnce(meeting.closePeerConnections);
          assert.calledOnce(meeting.unsetLocalStream);
          assert.calledOnce(meeting.unsetLocalShare);
          assert.calledOnce(meeting.unsetRemoteStream);
          assert.calledOnce(meeting.unsetPeerConnections);
          assert.calledOnce(meeting.roap.stop);
        });
      });
      describe('#share', () => {
        beforeEach(() => {
          meeting.locusInfo.mediaShares = [{name: 'content', url: 'test'}];
          meeting.locusInfo.self = {url: 'test'};
          meeting.meetingRequest.changeMeetingFloor = sinon.stub().returns(Promise.resolve());
        });
        it('should send the share', async () => {
          const share = meeting.share();
          assert.exists(share.then);
          await share;
          assert.calledOnce(meeting.meetingRequest.changeMeetingFloor);
        });
      });
      describe('#stopShare', () => {
        beforeEach(() => {
          meeting.locusInfo.mediaShares = [{name: 'content', url: 'test'}];
          meeting.locusInfo.self = {url: 'test'};
          meeting.meetingRequest.changeMeetingFloor = sinon.stub().returns(Promise.resolve());
        });
        it('should send the share', async () => {
          const share = meeting.share();
          assert.exists(share.then);
          await share;
          assert.calledOnce(meeting.meetingRequest.changeMeetingFloor);
        });
      });
    });
    describe('Public Event Triggers', () => {
      describe('#ringing', () => {
        it('should trigger the ringing event', () => {
          const spy = sinon.spy(meeting, 'trigger');
          meeting.ringing('test', false);
          assert.calledOnce(spy);
          assert.calledWith(spy, 'meeting:ringing', {type: 'test', ringing: false});
        });
      });
      describe('#reconnect', () => {
        describe('successful reconnect', () => {
          it('should reconnect and trigger reconnection and return a promise', async () => {
            const spy = sinon.spy(meeting, 'trigger');
            meeting.reconnectionManager = new ReconnectionManager({config: {reconnection: {retry: {backOff: 1}}}});
            meeting.reconnectionManager.reconnect = sinon.stub().returns(Promise.resolve('test'));
            meeting.reconnectionManager.reset = sinon.stub().returns(true);
            const reconnect = meeting.reconnect();
            assert.exists(reconnect.then);
            await reconnect;
            assert.calledOnce(spy);
            assert.calledWith(spy, 'meeting:reconnectionSuccess', {reconnect: 'test'});
            assert.calledOnce(meeting.reconnectionManager.reset);
          });
        });
        describe('unsuccessful reconnect', () => {
          it('should throw an error', () => {
            assert.throws(() => meeting.reconnect(), Error, 'Cannot reconnect, ReconnectionManager must first be defined.');
          });
          it('should trigger an unsuccessful reconnection and return a promise', async () => {
            const spy = sinon.spy(meeting, 'trigger');
            meeting.reconnectionManager = new ReconnectionManager({config: {reconnection: {retry: {backOff: 1}}}});
            meeting.reconnectionManager.reconnect = sinon.stub().returns(Promise.reject());
            meeting.reconnectionManager.reset = sinon.stub().returns(true);
            await meeting.reconnect().catch(() => {
              assert.calledOnce(spy);
              assert.calledWith(spy, 'meeting:reconnectionFailure', {error: sinon.match.any});
              assert.calledOnce(meeting.reconnectionManager.reset);
            });
          });
        });
      });
      describe('#closeRemoteStream', () => {
        it('should stop the stream, and trigger a media:stopped event when the remote stream stops', async () => {
          const spy = sinon.spy(meeting, 'trigger');
          Media.stopStream = sinon.stub().returns(Promise.resolve());
          await meeting.closeRemoteStream();
          assert.calledOnce(spy);
          assert.calledWith(spy, 'media:stopped', {type: 'remote'});
          assert.notOk(meeting.mediaProperties.shareStream);
        });
      });
      describe('#closeLocalShare', () => {
        it('should stop the stream, and trigger a media:stopped event when the local share stream stops', async () => {
          const spy = sinon.spy(meeting, 'trigger');
          Media.stopStream = sinon.stub().returns(Promise.resolve());
          await meeting.closeLocalShare();
          assert.calledOnce(spy);
          assert.calledWith(spy, 'media:stopped', {type: 'localShare'});
        });
      });
      describe('#closeLocalStream', () => {
        it('should stop the stream, and trigger a media:stopped event when the local stream stops', async () => {
          const spy = sinon.spy(meeting, 'trigger');
          Media.stopStream = sinon.stub().returns(Promise.resolve());
          await meeting.closeLocalStream();
          assert.calledOnce(spy);
          assert.calledWith(spy, 'media:stopped', {type: 'local'});
        });
      });
      describe('#setLocalShare', () => {
        it('should trigger a media:ready event with local share stream', () => {
          const spy = sinon.spy(meeting, 'trigger');
          const track = {};
          const getVideoTracks = sinon.stub().returns([track]);
          meeting.mediaProperties.setLocalShare = sinon.stub().returns(true);
          meeting.mediaProperties.localShare = {getVideoTracks};
          meeting.stopShare = sinon.stub().returns(true);
          meeting.setLocalShare('test');
          assert.calledOnce(spy);
          assert.calledWith(spy, 'media:ready', {type: 'localShare', stream: {getVideoTracks}});
          assert.calledOnce(meeting.mediaProperties.setLocalShare);
          assert.calledWith(meeting.mediaProperties.setLocalShare, 'test');
          assert.equal(meeting.mediaProperties.localStream, undefined);
          track.onended();
          assert.calledOnce(meeting.stopShare);
        });
      });
      describe('#setLocalStream', () => {
        it('should trigger a media:ready event with local stream', () => {
          const spy = sinon.spy(meeting, 'trigger');
          meeting.mediaProperties.setLocalStream = sinon.stub().returns(true);
          meeting.setLocalStream('test');
          assert.calledOnce(spy);
          assert.calledWith(spy, 'media:ready', {type: 'local', stream: undefined});
          assert.calledOnce(meeting.mediaProperties.setLocalStream);
          assert.calledWith(meeting.mediaProperties.setLocalStream, 'test');
          assert.equal(meeting.mediaProperties.localStream, undefined);
        });
      });
      describe('#setShareStream', () => {
        it('should trigger a media:ready event when share stream track ontrack is fired', () => {
          const spy = sinon.spy(meeting, 'trigger');
          const pc = {};
          meeting.setShareStream(pc);
          pc.ontrack({streams: ['test']});
          assert.calledOnce(spy);
          assert.calledWith(spy, 'media:ready', {type: 'remoteShare', stream: 'test'});
          assert.equal(meeting.mediaProperties.remoteShare, 'test');
        });
      });
      describe('#setRemoteStream', () => {
        it('should trigger a media:ready event when remote stream track ontrack is fired', () => {
          const spy = sinon.spy(meeting, 'trigger');
          const pc = {};
          meeting.setRemoteStream(pc);
          pc.ontrack({streams: ['test']});
          assert.calledOnce(spy);
          assert.calledWith(spy, 'media:ready', {type: 'remote', stream: 'test'});
          assert.equal(meeting.mediaProperties.remoteStream, 'test');
        });
      });
      describe('#setUpLocusInfoSelfListener', () => {
        it('listens to the self unaddmitted guest event', (done) => {
          const spy = sinon.spy(meeting, 'trigger');
          Events.emit('SELF_UNADMITTED_GUEST', 'test');
          assert.calledOnce(spy);
          assert.calledWith(spy, 'meeting:self:lobbyWaiting', {payload: 'test'});
          done();
        });
        it('listens to the self addmitted guest event', (done) => {
          const spy = sinon.spy(meeting, 'trigger');
          Events.emit('SELF_ADMITTED_GUEST', 'test');
          assert.calledOnce(spy);
          assert.calledWith(spy, 'meeting:self:guestAdmitted', {payload: 'test'});
          done();
        });
      });
    });
    describe('Private Detailed API and Helpers', () => {
      describe('#createStats', () => {
        it('should create stats for the meeting object', () => {
          const stats = meeting.createStats();
          assert.instanceOf(stats, WebRTCStats);
          assert.instanceOf(meeting.getStats(), WebRTCStats);
        });
      });
      describe('#parseMeetingInfo', () => {
        it('should parse meeting info, set values, and return null', () => {
          meeting.parseMeetingInfo({
            convoId: 'test',
            locusUrl: 'test',
            sipMeetingUri: 'test',
            owner: 'test'
          });
          assert.equal(meeting.convoId, 'test');
          assert.equal(meeting.locusUrl, 'test');
          assert.equal(meeting.sipUri, 'test');
          assert.equal(meeting.owner, 'test');
        });
      });
      describe('#parseLocus', () => {
        describe('when ONE_ON_ONE and participants', () => {
          beforeEach(() => {
            meeting.setLocus = sinon.stub().returns(true);
            MeetingUtil.getLocusPartner = sinon.stub().returns({person: {sipUrl: 'test'}});
          });
          it('should parse the locus object and set meeting properties and return null', () => {
            meeting.type = 'ONE_ON_ONE';
            meeting.parseLocus({url: 'test', participants: 'test', self: 'test'});
            assert.calledOnce(meeting.setLocus);
            assert.calledWith(meeting.setLocus, {url: 'test', participants: 'test', self: 'test'});
            assert.calledOnce(MeetingUtil.getLocusPartner);
            assert.calledWith(MeetingUtil.getLocusPartner, 'test', 'test');
            assert.deepEqual(meeting.partner, {person: {sipUrl: 'test'}});
            assert.equal(meeting.sipUri, 'test');
          });
        });
      });
      describe('#setRoapSeq', () => {
        it('should set the roap seq and return null', () => {
          assert.notOk(meeting.roapSeq);
          meeting.setRoapSeq('test');
          assert.equal(meeting.roapSeq, 'test');
        });
      });
      describe('#setCorrelationId', () => {
        it('should set the correlationId and return undefined', () => {
          assert.notOk(meeting.correlationId);
          meeting.setCorrelationId('test');
          assert.equal(meeting.correlationId, 'test');
        });
      });
      describe('#setLocus', () => {
        beforeEach(() => {
          meeting.locusInfo.initialSetup = sinon.stub().returns(true);
          meeting.members.set = sinon.stub().returns(true);
        });
        it('should read the locus object, set on the meeting and return null', () => {
          meeting.parseLocus({
            mediaConnections: 'test',
            locusUrl: 'test',
            locusId: 'test',
            selfId: 'test',
            mediaId: 'test',
            host: {id: 'test'}
          });
          assert.calledOnce(meeting.locusInfo.initialSetup);
          assert.calledWith(meeting.locusInfo.initialSetup, {
            mediaConnections: 'test',
            locusUrl: 'test',
            locusId: 'test',
            selfId: 'test',
            mediaId: 'test',
            host: {id: 'test'}
          });
          assert.calledOnce(meeting.members.set);
          assert.calledWith(meeting.members.set, {
            mediaConnections: 'test',
            locusUrl: 'test',
            locusId: 'test',
            selfId: 'test',
            mediaId: 'test',
            host: {id: 'test'}
          });
          assert.equal(meeting.mediaConnections, 'test');
          assert.equal(meeting.locusUrl, 'test');
          assert.equal(meeting.locusId, 'test');
          assert.equal(meeting.selfId, 'test');
          assert.equal(meeting.mediaId, 'test');
          assert.equal(meeting.hostId, 'test');
        });
      });
    });
  });
});
