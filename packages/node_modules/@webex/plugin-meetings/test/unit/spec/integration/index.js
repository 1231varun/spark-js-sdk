
import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';

import testUtils from './testUtils';

require('dotenv').config();

const sparkTestUsers = require('./sparkTestUsers.js');

let userSet, alice, bob, chris;
const startMeeting = (meeting) => {
  meeting.on('media:ready', (media) => {
    if (!media) {
      return;
    }
    if (media.type === 'local') {
      console.log('ready-localvideo');
    }
    if (media.type === 'remote') {
      console.log('ready-remotevideo');
    }
    if (media.type === 'remoteShare') {
      console.log('ready-sharevideo');
    }
    if (media.type === 'localShare') {
      console.log('ready-localshare');
    }
  });
  meeting.on('media:stopped', (media) => {
    if (media.type === 'local') {
      console.log('stopped-localvideo');
    }
    if (media.type === 'remote') {
      console.log('stopped-remotevideo');
    }
    if (media.type === 'localShare') {
      console.log('stopped-localshare');
    }
    if (media.type === 'remoteShare') {
      console.log('stopped-sharevideo');
    }
  });
};

// TODO: Merge all the test it sections into one

describe('plugin-meeting', () => {
  before(() => sparkTestUsers.generateTestUsers({count: 3})
    .then((users) => {
      userSet = users;
      alice = userSet[0];
      bob = userSet[1];
      chris = userSet[2];
      alice.name = 'alice';
      bob.name = 'bob';
    })
    .then(() => Promise.all([testUtils.syncAndEndMeeting(alice),
      testUtils.syncAndEndMeeting(bob)]))
    .catch((error) => {
      console.log(error);
    }));

  after(() => {
    const promise = [];
    userSet.forEach((user) => {
      promise.push(user.spark.internal.mercury.disconnect());
    });

    return Promise.all(promise)
      .then(() => sparkTestUsers.remove(userSet));
    // TODO: end is not a function on browser object
  });

  // The event was coming but incomplete
  // 1) Test user doesnt have locus tag information

  // Alice calls bob and bob rejects it
  describe('reject Incoming Call', () => {
    const aliceMeetingAdded = sinon.spy();
    const bobMeetingAdded = sinon.spy();
    it('alice dials bob and bob receives meeting added', () => {
      bob.spark.meetings.on('meeting:added', bobMeetingAdded);
      alice.spark.meetings.on('meeting:added', aliceMeetingAdded);
      return alice.spark.meetings.create(bob.emailAddress)
        .then((m) => m.join()
          .then(() => testUtils.waitForSpy(aliceMeetingAdded, 'meeting:added'))
          .then((m) => {
            alice.meeting = m.meeting;
            console.log('alice dialed');
          }))
        .then(() => testUtils.waitForSpy(bobMeetingAdded, 'meeting:added'))
        .then((m) => {
          bob.meeting = m.meeting;
        })
        .catch((err) => {
          console.log('ERROR JOIN ', err);
          throw err;
        });
    });

    it('bob and alice have meeting object', () => {
      assert.equal(bob.meeting.sipUri, alice.emailAddress);
      assert.equal(alice.meeting.sipUri, bob.emailAddress);
      assert.equal(bob.meeting.state, 'IDLE');
      assert.equal(alice.meeting.state, 'JOINED');
    }).timeout(20000);

    it('bob rejects the meeting', () => {
      bob.meeting.acknowledge('INCOMING');
      return bob.meeting.decline('BUSY')
        .then(() => testUtils.waitForStateChange(bob.meeting, 'DECLINED'));
    });

    it('alice leaves the meeting', () => {
      assert.equal(alice.meeting.state, 'JOINED');

      return alice.meeting.leave()
        .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT'))
        .then(() => testUtils.waitForStateChange(bob.meeting, 'DECLINED'));
    });

    it('alice and bob meeting object deleted', () => Promise.all([
      testUtils.waitForCallEnded(alice, bob.emailAddress),
      testUtils.waitForCallEnded(bob, alice.emailAddress)
    ])
      .then(() => {
        assert.equal(alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress), null);
        assert.equal(bob.spark.meetings.getMeetingByType('sipUri', alice.emailAddress), null);
      }));
  });

  describe('successfull 1:1 call (Including Guest) ', () => {
    const aliceMeetingAdded = sinon.spy();
    const bobMeetingAdded = sinon.spy();
    it('No previous call', () => {
      assert.equal(Object.keys(alice.spark.meetings.getAllMeetings()), 0);
      assert.equal(Object.keys(bob.spark.meetings.getAllMeetings()), 0);
    });

    it('alice dials bob and bob receives meeting added', () => {
      bob.spark.meetings.on('meeting:added', bobMeetingAdded);
      alice.spark.meetings.on('meeting:added', aliceMeetingAdded);
      return alice.spark.meetings.create(bob.emailAddress)
        .then((m) => {
          startMeeting(m);
          alice.meeting = m;
          return m.join()
            .then(() => testUtils.waitForSpy(aliceMeetingAdded, 'meeting:added'))
            .then((m) => {
              alice.meeting = m.meeting;
              console.log('alice dialed');
            });
        })
        .then(() => testUtils.waitForSpy(bobMeetingAdded, 'meeting:added'))
        .then((m) => {
          bob.meeting = m.meeting;
          bob.meeting.acknowledge('INCOMING');
          return bob.meeting.join()
            .then(() => testUtils.waitForStateChange(bob.meeting, 'JOINED'));
        })
        .catch((err) => {
          console.log('ERROR JOIN ', err);
          throw err;
        });
    });

    it('bob and alice have meeting object', () => {
      assert.equal(bob.meeting.sipUri, alice.emailAddress);
      assert.equal(alice.meeting.sipUri, bob.emailAddress);
      assert.equal(bob.meeting.state, 'JOINED');
      assert.equal(alice.meeting.state, 'JOINED');
      assert.equal(alice.meeting.type, 'ONE_ON_ONE');
      assert.equal(bob.meeting.type, 'ONE_ON_ONE');
    }).timeout(20000);

    it('alice adds chris as guest to 1:1 meeting', () => {
      const chrisMeetingAdded = sinon.spy();
      chris.spark.meetings.on('meeting:added', chrisMeetingAdded);
      return alice.meeting.invite(chris.emailAddress)
        .then(() => testUtils.waitForSpy(aliceMeetingAdded, 'meeting:added'))
        .then((m) => { chris.meeting = m; })
        .then(() => chris.meeting.join())
        .then(() => testUtils.waitForStateChange(chris.meeting, 'JOINED'));
    });

    it('leave on the meeting object', () => Promise.all([alice.meeting.leave(), bob.meeting.leave()])
      .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT'))
      .then(() => testUtils.waitForStateChange(bob.meeting, 'LEFT')));

    it('alice and bob meeting object deleted', () => Promise.all([
      testUtils.waitForCallEnded(alice, bob.emailAddress),
      testUtils.waitForCallEnded(bob, alice.emailAddress)
    ])
      .then(() => {
        assert.equal(alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress), null);
        assert.equal(bob.spark.meetings.getMeetingByType('sipUri', alice.emailAddress), null);
      }));
  });

  // Alice calls bob and bob rejects it
  describe('End outgoing Call', () => {
    after(() => {
      alice.meeting = null;
      bob.meeting = null;
    });

    const aliceMeetingAdded = sinon.spy();
    const bobMeetingAdded = sinon.spy();
    it('alice dials bob and bob receives meeting added', () => {
      bob.spark.meetings.on('meeting:added', bobMeetingAdded);
      alice.spark.meetings.on('meeting:added', aliceMeetingAdded);
      return alice.spark.meetings.create(bob.emailAddress)
        .then((m) => m.join()
          .then(() => testUtils.waitForSpy(aliceMeetingAdded, 'meeting:added'))
          .then((m) => {
            alice.meeting = m.meeting;
            console.log('alice dialed');
          }))
        .then(() => testUtils.waitForSpy(bobMeetingAdded, 'meeting:added'))
        .then((m) => {
          bob.meeting = m.meeting;
        })
        .catch((err) => {
          console.log('ERROR JOIN ', err);
          throw err;
        });
    });

    it('bob and alice have meeting object', () => {
      //* * acknoledging makes a difference */
      bob.meeting.acknowledge('INCOMING');
      assert.equal(bob.meeting.sipUri, alice.emailAddress);
      assert.equal(alice.meeting.sipUri, bob.emailAddress);
      assert.equal(bob.meeting.state, 'IDLE');
      assert.equal(alice.meeting.state, 'JOINED');
    }).timeout(20000);

    it('alice leaves the meeting', () => alice.meeting.leave()
      .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT')));

    it('alice and bob meeting object deleted', () => Promise.all([
      testUtils.waitForCallEnded(alice, bob.emailAddress),
      testUtils.waitForCallEnded(bob, alice.emailAddress)
    ])
      .then(() => {
        assert.equal(alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress), null);
        assert.equal(bob.spark.meetings.getMeetingByType('sipUri', alice.emailAddress), null);
      }));
  });
});
