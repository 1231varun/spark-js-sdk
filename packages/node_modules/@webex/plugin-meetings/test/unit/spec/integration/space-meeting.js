
import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';

import CMR from './cmr';
import testUtils from './testUtils';

require('dotenv').config();

const sparkTestUsers = require('./sparkTestUsers.js');

let userSet, alice, bob, chris;

describe('plugin-meetings-automation', () => {
  describe('plugin-meeting-space-meeting', () => {
    before(() => sparkTestUsers.generateTestUsers({count: 3})
      .then((users) => {
        userSet = users;
        alice = userSet[0];
        bob = userSet[1];
        chris = userSet[2];
        alice.name = 'alice';
        bob.name = 'bob';
      })
      .then(() => Promise.all([testUtils.syncAndEndMeeting(alice),
        testUtils.syncAndEndMeeting(bob)]))
      .catch((error) => {
        console.log(error);
      }));

    after(() => {
      const promise = [];
      userSet.forEach((user) => {
        promise.push(user.spark.internal.mercury.disconnect());
      });

      return Promise.all(promise)
        .then(() => sparkTestUsers.remove(userSet));
      // TODO: end is not a function on browser object
    });

    describe('Space meeting', () => {
      let space = null;
      const aliceMeetingAdded = sinon.spy();
      const bobMeetingAdded = sinon.spy();
      const chrisMeetingAdded = sinon.spy();
      it('Alice creates a space', () => alice.spark.internal.conversation.create({participants: [bob, chris]})
        .then((conversation) => {
          assert.lengthOf(conversation.participants.items, 3);
          assert.lengthOf(conversation.activities.items, 1);
          console.log('CONVERSATION', conversation);
          space = conversation;
        }));
      it('alice starts a space meeting', () => {
        chris.spark.meetings.on('meeting:added', chrisMeetingAdded);
        bob.spark.meetings.on('meeting:added', bobMeetingAdded);
        alice.spark.meetings.on('meeting:added', aliceMeetingAdded);
        return alice.spark.meetings.create(space.id)
          .then((m) => m.join()
            .then(() => testUtils.waitForSpy(aliceMeetingAdded, 'meeting:added'))
            .then((m) => {
              console.log('ALICE meeting ', m);
              alice.meeting = m.meeting;
            }))
          .then(() => testUtils.waitForSpy(bobMeetingAdded, 'meeting:added'))
          .then((m) => {
            bob.meeting = m.meeting;
          })
          .then(() => testUtils.waitForSpy(chrisMeetingAdded, 'meeting:added'))
          .then((m) => {
            chris.meeting = m.meeting;
          })
          .then(() => testUtils.waitForStateChange(alice.meeting, 'JOINED'))
          .then(() => testUtils.waitForStateChange(bob.meeting, 'IDLE'))
          .then(() => testUtils.waitForStateChange(chris.meeting, 'IDLE'));
      });

      it('check state of alice', () => {
        assert.equal(alice.meeting.state, 'JOINED');
        assert.equal(bob.meeting.state, 'IDLE');
        assert.equal(chris.meeting.state, 'IDLE');
      });

      it('bob and chris joins the meeting', () => bob.meeting.join()
        .then(() => chris.meeting.join())
        .then(() => testUtils.waitForStateChange(bob.meeting, 'JOINED'))
        .then(() => testUtils.waitForStateChange(chris.meeting, 'JOINED')));

      it('alice bob and chris leaves the meeting', () => alice.meeting.leave()
        .then(() => bob.meeting.leave())
        .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT'))
        .then(() => testUtils.waitForStateChange(bob.meeting, 'LEFT'))
        .then(() => chris.meeting.leave())
        .then(() => testUtils.waitForStateChange(chris.meeting, 'LEFT')));
    });
  });

  describe('Unclaimed PMR', () => {
    before(() => sparkTestUsers.generateTestUsers({count: 3})
      .then((users) => {
        userSet = users;
        alice = userSet[0];
        bob = userSet[1];
        chris = userSet[2];
      })
      .then(() => testUtils.syncAndEndMeeting(alice))
      .then(() => CMR.reserve(alice.spark, false))
      .then((cmr) => {
        console.log('CMRR ', cmr);
        alice.cmr = cmr;
      })
      .catch((error) => {
        console.log('WEBEX MEETING error ', error);
      }));

    after(() => {
      const promise = [];
      userSet.forEach((user) => {
        promise.push(user.spark.internal.mercury.disconnect());
      });

      return Promise.all(promise)
        .then(() => sparkTestUsers.remove(userSet))
        .then(() => CMR.release(alice.spark, alice.cmr.reservationUrl));
    });

    describe('Successful meeting', () => {
      const aliceMeetingAdded = sinon.spy();

      it('alice joins the unclaimed PMR as attende', () => {
        alice.spark.meetings.on('meeting:added', aliceMeetingAdded);
        return alice.spark.meetings.create(alice.cmr.sipAddress)
          .then((m) => m.join({moderator: false})
            .then(() => testUtils.waitForSpy(aliceMeetingAdded, 'meeting:added'))
            .then((m) => {
              console.log('ALICE meeting ', m);
              alice.meeting = m.meeting;
            }))
          .then(() => testUtils.waitForStateChange(alice.meeting, 'IDLE'));
      });

      it('bob joins with out host pin or moderator', () => {
        // either we see meeting info after create or we wait for the error to determine
      });

      it('bob and chris joins the unclaimed PMR using PIN', () => bob.spark.meetings.create(alice.cmr.sipAddress)
        .then((m) => { bob.meeting = m; return m.join({moderator: false, hostPin: alice.cmr.responseMetaData.hostPin}); })
        .then(() => chris.spark.meetings.create(alice.cmr.sipAddress))
        .then((m) => { chris.meeting = m; return m.join({moderator: false}); })
        .then(() => testUtils.waitForStateChange(bob.meeting, 'JOINED'))
        .then(() => testUtils.waitForStateChange(chris.meeting, 'JOINED')));

      it('alice bob and chris leaves the meeting', () => alice.meeting.leave()
        .then(() => bob.meeting.leave())
        .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT'))
        .then(() => testUtils.waitForStateChange(bob.meeting, 'LEFT'))
        .then(() => chris.meeting.leave())
        .then(() => testUtils.waitForStateChange(chris.meeting, 'LEFT')));

      it('wait for meetings to be cleared', () => Promise.all([
        testUtils.waitForCallEnded(alice, alice.sipAddress),
        testUtils.waitForCallEnded(bob, alice.sipAddress),
        testUtils.waitForCallEnded(chris, alice.sipAddress)]));
    });
  });

  describe('Claimed PMR', () => {
    before(() => sparkTestUsers.generateTestUsers({count: 3})
      .then((users) => {
        userSet = users;
        alice = userSet[0];
        bob = userSet[1];
        chris = userSet[2];
        alice.name = 'alice';
        // bob.name = 'bob';
      })
      .then(() => testUtils.syncAndEndMeeting(alice))
      .then(() => CMR.reserve(alice.spark, true))
      .then((cmr) => {
        console.log('CMRR ', cmr);
        alice.cmr = cmr;
      })
      .catch((error) => {
        console.log('WEBEX MEETING error ', error);
      }));

    after(() => {
      const promise = [];
      userSet.forEach((user) => {
        promise.push(user.spark.internal.mercury.disconnect());
      });

      return Promise.all(promise)
        .then(() => sparkTestUsers.remove(userSet))
        .then(() => CMR.release(alice.spark, alice.cmr.reservationUrl));
    });

    describe('Successful meeting', () => {
      const aliceMeetingAdded = sinon.spy();

      it('alice starts a space meeting', () => {
        alice.spark.meetings.on('meeting:added', aliceMeetingAdded);
        return alice.spark.meetings.create(alice.cmr.sipAddress)
          .then((m) => m.join()
            .then(() => testUtils.waitForSpy(aliceMeetingAdded, 'meeting:added'))
            .then((m) => {
              console.log('ALICE meeting ', m);
              alice.meeting = m.meeting;
            }))
          .then(() => testUtils.waitForStateChange(alice.meeting, 'JOINED'));
      });


      it('bob joins the meeting', () => bob.spark.meetings.create(alice.cmr.sipAddress)
        .then((m) => { bob.meeting = m; return m.join(); })
        .then(() => testUtils.waitForStateChange(bob.meeting, 'JOINED')));

      it('check if the host has joined', () => {

      });

      it('bob and chris joins the meeting', () => chris.spark.meetings.create(alice.cmr.sipAddress)
        .then((m) => { chris.meeting = m; return m.join({moderator: false}); })
        .then(() => testUtils.waitForStateChange(chris.meeting, 'JOINED')));

      it('alice bob and chris leaves the meeting', () => alice.meeting.leave()
        .then(() => bob.meeting.leave())
        .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT'))
        .then(() => testUtils.waitForStateChange(bob.meeting, 'LEFT'))
        .then(() => chris.meeting.leave())
        .then(() => testUtils.waitForStateChange(chris.meeting, 'LEFT')));

      it('wait for meetings to be cleared', () => Promise.all([
        testUtils.waitForCallEnded(alice, alice.sipAddress),
        testUtils.waitForCallEnded(bob, alice.sipAddress),
        testUtils.waitForCallEnded(chris, alice.sipAddress)]));
    });
  });
});
