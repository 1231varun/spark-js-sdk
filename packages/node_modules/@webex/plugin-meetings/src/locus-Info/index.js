import isEqual from 'lodash.isequal';

import {LOCUSEVENT} from '../constants';
import Parser from '../locus-Info';

/**
 * @export
 * @class LocusInfo
*/
export default class LocusInfo {
  constructor() {
    this.setup({});
  }

  /**
  * updates the default values from locus
  * @param {object} locus
  */
  setup(locus) {
    this.controls = locus.controls || null;
    this.conversationUrl = locus.conversationUrl || null;
    this.created = locus.created || null;
    this.fullState = locus.fullState || null;
    this.host = locus.host || null;
    this.info = locus.info || null;
    this.mediaShares = locus.mediaShares || null;
    this.participantsUrl = locus.participantsUrl || null;
    this.replaces = locus.replaces || null;
    this.self = locus.self || null;
    this.url = locus.url || null;
    this.aclUrl = locus.aclUrl || null;
    this.baseSequence = locus.baseSequence || null;
    this.sequence = locus.sequence || null;
    this.membership = locus.membership || null;
    this.identities = locus.identities || null;
    this.participants = locus.participants || null;
  }

  parse(meeting, data) {
    const {eventType} = data;
    switch (eventType) {
      case LOCUSEVENT.PARTICIPANT_JOIN:
        // incoming call triggers this
        break;
      case LOCUSEVENT.PARTICIPANT_LEFT:
        console.log('participant-LEFT', eventType);
        break;
      case LOCUSEVENT.CONTROLS_UPDATED:
        console.log('participant-CONTROLS_UPDATED', eventType);
        break;

      case LOCUSEVENT.PARTICIPANT_AUDIO_MUTED:
        console.log('participant-AUDIO_MUTED', eventType);
        break;
      case LOCUSEVENT.PARTICIPANT_AUDIO_UNMUTED:
        console.log('participant-AUDIO_UNMUTED', eventType);
        break;
      case LOCUSEVENT.PARTICIPANT_VIDEO_MUTED:
        console.log('participant-VIDEO_MUTED', eventType);
        break;
      case LOCUSEVENT.PARTICIPANT_VIDEO_UNMUTED:
        console.log('participant-VIDEO_UNMUTED', eventType);
        break;

      case LOCUSEVENT.SELF_CHANGED:
        console.log('participant-SELF_CHANGED', eventType);
        break;
      case LOCUSEVENT.PARTICIPANT_UPDATED:
        console.log('participant-PARTICIPANT_UPDATED', eventType);
        break;
      case LOCUSEVENT.PARTICIPANT_CONTROLS_UPDATED:
        console.log('participant-CONTROLS_UPDATED', eventType);
        break;
      case LOCUSEVENT.PARTICIPANT_ROLES_UPDATED:
        console.log('participant-ROLES_UPDATED', eventType);
        break;

      case LOCUSEVENT.PARTICIPANT_DECLINED:
        console.log('participant_DECLINED', eventType);
        break;

      case LOCUSEVENT.DIFFERENCE:
        Parser.updateWithDeltaLocus(data.locus, meeting);
        break;

      case LOCUSEVENT.FLOOR_GRANTED:
        console.log('floorGranted', eventType);
        break;

      case LOCUSEVENT.FLOOR_RELEASED:
        console.log('floorReleased', eventType);
        break;

      default:
        Parser.updateWithDeltaLocus(data.locus, meeting);
    }
  }

  /**
   * updates the locus with full locus object
   * @param {object} locus locus object
   * @returns {object} null
   */
  onFullLocus(locus) {
    this.updateLocusInfo(locus);
    this.updateParticipants(locus.participants);
  }

  onDeltaLocus(locus) {
    this.updateLocusInfo(locus);
    this.updateParticipants(locus.participants, true);
  }

  updateLocusInfo(locus) {
    this.updateControls(locus.controls);
    this.updateConversationUrl(locus.conversationUrl);
    this.updateCreated(locus.created);
    this.updateFullState(locus.state);
    this.updateHostInfo(locus.host);
    this.updateMeetingInfo(locus.info);
    this.updateMediaShares(locus.mediaShares);
    this.updateParticipantsUrl(locus.participantsUrl);
    this.updateReplace(locus.replace);
    this.updateSelf(locus.self);
    this.updateLocusUrl(locus.url);
    this.updateAclUrl(locus.aclUrl);
    this.updateBasequence(locus.baseSequence);
    this.updateSequence(locus.sequence);
    this.updateMemberShip(locus.membership);
    this.updateIdentifiers(locus.identities);
  }

  addedOrRemovedParticipant() {
    return {
      addedParticipants: [],
      removedParticipants: [],
      updatedParticipants: []
    };
  }

  /**
   *
   * @param {Object} participants new participants object
   * @param {boolen} deltaParticpantFlag  delta event
   */
  updateParticipants(participants, deltaParticpantFlag) {
    let updatedParticipants = [];

    // Only goes here on delta event have info about the participants who only got updated
    if (deltaParticpantFlag) {
      participants.forEach((participant) => {
        if (this.participants[participant.id]) {
          console.log('delta participants got updated', participant.id);
          this.participants[participant.id] = participant;
        }
        else {
          // TODO: added new participants to the meeting
          console.log('Added new participants to the meeting', participant.id);
          this.participants[participant.id] = participant;
        }
      });
    } // If not delta it tries to replace the whole participants list
    else if (participants && !isEqual(this.participants, participants)) {
      console.log('participants changed check everything');

      // If the length is not same some might have got added or removed
      if (participants.length !== this.participants.length) {
        const temp = this.addedOrRemovedParticipant(participants);
        const {
          addedParticipants,
          removedParticipants // I think there wont be any removed
          // All the participants just get there state updated
        } = temp;
        console.log('addedParticipants', addedParticipants);
        console.log('removedParticipants', removedParticipants);
        updatedParticipants = temp.updatedParticipants;
      }
      else {
        updatedParticipants = this.findChangedParticipants(participants);
      }
    }
    return updatedParticipants;
  }

  // TODO: check if this causes any perfomance issue
  findChangedParticipants(newParticipants) {
    if (newParticipants.length < 25) {
      const changedParticipants = [];
      this.participants.forEach((participant) => {
        if (!isEqual(participant, newParticipants[participant.id])) {
          this.participants[participant.id] = newParticipants[participant.id];
          changedParticipants[participant.id] = participant;
        }
      });

      return changedParticipants;
    }
    // If more then 25 and we got fullLocus send Everything
    return this.participants;
    // TODO: find an alternate way or just replace the whole object
    // Tell customers that more then 25 we will just send an update
  }

  updateControls(controls) {
    if (controls && !isEqual(this.controls, controls)) {
      this.controls = controls;
      console.info('LocusInfo:controls got updated');
    }
  }

  updateConversationUrl(conversationUrl) {
    if (conversationUrl && !isEqual(this.conversationUrl, conversationUrl)) {
      this.conversationUrl = conversationUrl;
      console.info('LocusInfo:conversationUrl got updated');
    }
  }

  updateCreated(created) {
    if (created && !isEqual(this.created, created)) {
      this.created = created;
      console.info('LocusInfo:created got updated');
    }
  }

  updateFullState(fullState) {
    if (fullState && !isEqual(this.fullState, fullState)) {
      this.fullState = fullState;
      console.info('LocusInfo:fullState got updated');
    }
  }

  updateHostInfo(host) {
    if (host && !isEqual(this.host, host)) {
      this.host = host;
      console.info('LocusInfo:host got updated');
    }
  }

  updateMeetingInfo(info) {
    if (info && !isEqual(this.info, info)) {
      this.info = info;
      console.info('LocusInfo:info got updated');
    }
  }

  updateMediaShares(mediaShares) {
    if (mediaShares && !isEqual(this.mediaShares, mediaShares)) {
      this.mediaShares = mediaShares;
      console.info('LocusInfo:mediaShares got updated');
    }
  }

  updateParticipantsUrl(participantsUrl) {
    if (participantsUrl && !isEqual(this.participantsUrl, participantsUrl)) {
      this.participantsUrl = participantsUrl;
      console.info('LocusInfo:participantsUrl got updated');
    }
  }

  updateReplace(replace) {
    if (replace && !isEqual(this.replace, replace)) {
      this.replace = replace;
      console.info('LocusInfo:replace got updated');
    }
  }

  updateSelf(self) {
    if (self && !isEqual(this.self, self)) {
      this.self = self;
      console.info('LocusInfo:self got updated');
    }
  }

  updateLocusUrl(url) {
    if (url && this.url !== url) {
      this.url = url;
      console.info('LocusInfo:url got updated');
    }
  }

  updateAclUrl(aclUrl) {
    if (aclUrl && !isEqual(this.aclUrl, aclUrl)) {
      this.aclUrl = aclUrl;
      console.info('LocusInfo:aclUrl got updated');
    }
  }

  updateBasequence(baseSequence) {
    if (baseSequence && !isEqual(this.baseSequence, baseSequence)) {
      this.baseSequence = baseSequence;
      console.info('LocusInfo:baseSequence got updated');
    }
  }

  updateSequence(sequence) {
    if (sequence && !isEqual(this.sequence, sequence)) {
      this.sequence = sequence;
      console.info('LocusInfo:sequence got updated');
    }
  }

  updateMemberShip(membership) {
    if (membership && !isEqual(this.membership, membership)) {
      this.membership = membership;
      console.info('LocusInfo:membership got updated');
    }
  }

  updateIdentifiers(identities) {
    if (identities && !isEqual(this.identities, identities)) {
      this.identities = identities;
      console.info('LocusInfo:identities got updated');
    }
  }
}
