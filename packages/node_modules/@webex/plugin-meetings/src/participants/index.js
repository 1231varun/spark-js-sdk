/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */

import {isEmpty} from 'lodash';
import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import {MEETINGS, EVENT_TRIGGERS} from '../constants';

import ParticipantCollection from './collection';
import ParticipantRequest from './request';
import ParticipantUtil from './util';

/**
 * @class Participants
 */
export default class Participants extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   * @memberof Participants
   */
  constructor(attrs, options) {
    super({}, options);
    this.participantRequest = new ParticipantRequest({}, options);
    // TODO add an setLocusUrl for all modules that consume locusUrl
    this.locusUrl = null;
  }

  /**
   * update the locus Url
   * @param {Object} locus
   * @param {String} locusUrl optional, takes precedence
   * @throws {Error}
   * @returns {undefined}
   * @memberof Participants
   */
  setLocusUrl(locus, locusUrl = null) {
    if (locusUrl) {
      this.locusUrl = locusUrl;
    }
    else if (locus && (locus.locusUrl || locus.url)) {
      this.locusUrl = locus.locusUrl || locus.url;
    }
    else {
      throw new Error('Setting locusUrl for the participants module should be done with a locus object or locusUrl');
    }
  }

  /**
   * @param {Object} locus the locus object for the meeting at join time
   * @returns {Participants} post construction
   * @throws {Error} if there is no locus object to work on
   * @memberof Participants
   */
  set(locus) {
    if (!locus) {
      throw new Error('Cannot set up an initial partcipants object without a locus');
    }
    this.setLocusUrl(locus);
    const participants = ParticipantCollection.create(locus);
    this.trigger(EVENT_TRIGGERS.PARTICIPANTS_CREATED, participants);
  }

  /**
   * @param {string} id
   * @returns {Participant}
   * @memberof Participants
   */
  static getParticipant(id) {
    return ParticipantCollection.get(id);
  }

  /**
   * @param {string} id
   * @param {Participant} participant
   * @returns {null}
   * @memberof Participants
   */
  static setParticipant(id, participant) {
    return ParticipantCollection.set(id, participant);
  }

  /**
   * @param {string} id
   * @returns {Participant}
   * @memberof Participants
   */
  static removeParticipant(id) {
    return ParticipantCollection.remove(id);
  }

  /**
   * adds a guest participant to the associated meeting
   * @param {String} invitee
   * @param {Boolean} alertIfActive optional parameter
   * @returns {Promise}
   * @memberof Participants
   */
  addParticipant(invitee, alertIfActive) {
    if (!(!invitee || (!invitee.emailAddress || !invitee.email) || !this.locusUrl)) {
      return Promise.reject(new Error('invitee must be passed and the associated locus url for this meeting object must be defined.'));
    }
    const options = ParticipantUtil.generateAddParticipantOptions(invitee, this.locusUrl, alertIfActive);
    return this.participantRequest.addParticipant(options).then((res) => res).catch((error) => error); // TODO:
  }

  /**
   * admits waiting participants (invited guests to meeting)
   * @param {Array} participantIds
   * @returns {Promise}
   * @memberof Participants
   */
  admitParticipants(participantIds) {
    if (isEmpty(participantIds)) {
      return Promise.reject(new Error('No participant ids provided to admit.'));
    }
    const options = ParticipantUtil.generateAdmitParticipantOptions(participantIds, this.locusUrl);
    return this.participantRequest.admitParticipant(options).then((res) => res).catch((error) => error); // TODO:
  }
}
