/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */

 import {isEmpty} from 'lodash';

import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import {MEETINGS} from '../constants';

import ParticipantCollection from './collection';
import ParticipantRequest from './request';
import ParticipantUtil from './util';

/**
 * @class Participants
 */
export default class Participants extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   * @memberof Participants
   */
  constructor(attrs, options) {
    super({}, options);
    this.participantRequest = new ParticipantRequest({}, options);
    this.locusUrl = null;
  }

  set(meeting) {
    if (meeting && meeting.locusUrl) {
      this.locusUrl = meeting.locusUrl;
    }
  }

  /**
   * @param {string} id
   * @returns {object}
   * @memberof Participants
   */
  static getParticipant(id) {
    return ParticipantCollection.get(id);
  }

  /**
   * @param {string} id
   * @param {object} participant
   * @returns {null}
   * @memberof Participants
   */
  static setParticipant(id, participant) {
    ParticipantCollection.set(id, participant);
  }

  /**
   * @param {string} id
   * @returns {object}
   * @memberof Participants
   */
  static removeParticipant(id) {
    ParticipantCollection.remove(id);
  }

  /**
   * adds a guest participant to the associated meeting
   * @param {String} invitee
   * @param {Boolean} alertIfActive optional parameter
   * @returns {Promise}
   * @memberof Participants
   */
  addParticipant(invitee, alertIfActive) {
    if (!(!invitee || (!invitee.emailAddress || !invitee.email) || !this.locusUrl)) {
      return Promise.reject(new Error('invitee must be passed and the associated locus url for this meeting object must be defined.'));
    }
    const options = ParticipantUtil.generateAddParticipantOptions(invitee, this.locusUrl, alertIfActive);
    return this.participantRequest.addParticipant(options).then((res) => {
      // TODO:
      // const participant = ParticipantUtil.extractAddParticipant(res.body);
      // if (!participant) {
      //   throw new Error('Participant was not received on add'); // TODO:
      // }
      // ParticipantCollection.setParticipant(participant.id, participant);
      return res;
    }).catch((error) => error); // TODO:
  }

  /**
   * admits waiting participants (invited guests to meeting)
   * @param {Array} participantIds
   * @returns {Promise}
   * @memberof Participants
   */
  admitParticipants(participantIds) {
    if (isEmpty(participantIds)) {
      return Promise.reject(new Error('No participant ids provided to admit.'));
    }
    const options = ParticipantUtil.generateAdmitParticipantOptions(participantIds, this.locusUrl);
    return this.participantRequest.admitParticipant(options).then((res) => {
      // TODO:
      return res;
    }).catch((error) => error); // TODO:
  }
}
