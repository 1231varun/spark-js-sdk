import {forEach} from 'lodash';

import {
  PUT,
  CONTROLS,
  IN_LOBBY,
  IN_MEETING,
  NOT_IN_MEETING,
  USER,
  RESOURCE_ROOM,
  JOINED,
  NONE,
  IDLE,
  WAIT,
  OBSERVE,
  LEFT
} from '../constants';

const ParticipantUtil = {};

ParticipantUtil.extractHostOwner = (locus) =>
  (locus && locus.owner && locus.owner.info ? locus.owner.info : null);

ParticipantUtil.extractSelfUserId = (locus) =>
  (locus && locus.self && locus.self.person && locus.self.person.id ? locus.self.person.id : null);

ParticipantUtil.isUser = (participant) =>
  (participant && participant.type === USER);

ParticipantUtil.isDevice = (participant) =>
  (participant && participant.type === RESOURCE_ROOM);

ParticipantUtil.getParticipantStatus = (participant) => {
  if (!(participant && participant.devices && participant.devices.length)) {
    return NOT_IN_MEETING;
  }
  const device = participant && participant.devices ? participant.devices[0] : null;
  if (device) {
    if (device.state === JOINED && (!device.intent || device.intent.type === NONE)) {
      return IN_MEETING;
    }
    if (device.state === IDLE && device.intent && (device.intent.type === WAIT || device.intent.type === OBSERVE)) {
      return IN_LOBBY;
    }
    if (device.state === LEFT || (device.state === IDLE && (!device.intent || device.intent.type === NONE))) {
      return NOT_IN_MEETING;
    }
  }
  return NOT_IN_MEETING;
};

ParticipantUtil.handledAddToLobbyMeetingUnjoinedLists = (participants, participant) => {
  switch (ParticipantUtil.getParticipantStatus(participant)) {
    case IN_LOBBY:
      return participants.inLobbyList.push(participant);
    case IN_MEETING:
      return participants.inMeetingList.push(participant);
    case NOT_IN_MEETING:
      return participants.notInMeetingList.push(participant);
    default:
      return participants.notInMeetingList.push(participant);
  }
};

ParticipantUtil.handleAddToHostList = (participants, participant, hostIdentity, selfUserIdentity) => {
  if (hostIdentity
  && hostIdentity !== selfUserIdentity) {
    if (ParticipantUtil.isUser(participant)
    && participant.identity === hostIdentity) {
      return participants.hostList.push(participant);
    }
    if (ParticipantUtil.isDevice(participant)
    && participant.associatedUsers && participant.associatedUsers.some((user) => (user.identity === hostIdentity))
    ) {
      return participants.hostList.push(participant);
    }
  }
  return null;
};

ParticipantUtil.handleAddToSelfList = (participants, participant, selfUserIdentity) => {
  if (ParticipantUtil.isUser(participant)
  && participant.identity === selfUserIdentity) {
    return participants.selfList.push(participant);
  }
  if (ParticipantUtil.isDevice(participant)
  && participant.associatedUsers && participant.associatedUsers.some((u) => (u.identity === selfUserIdentity))) {
    return participants.selfList.push(participant);
  }
  return null;
};

ParticipantUtil.constructParticipants = (locus, participants, selfUserIdentity, hostIdentity) => {
  if (!(locus && locus.participants && locus.participants.length && participants)) {
    throw new Error('Could not construct meeting participant list. Some value is not present');
  }
  forEach(locus.participants, (locusParticipant) => {
    if (locusParticipant.hideInRoster) {
      return;
    }
    if (ParticipantUtil.handleAddToSelfList(participants, locusParticipant, selfUserIdentity)) {
      return;
    }
    if (ParticipantUtil.handleAddToHostList(participants, locusParticipant, hostIdentity, selfUserIdentity)) {
      return;
    }
    ParticipantUtil.handledAddToLobbyMeetingUnjoinedLists(participants, locusParticipant);
  });
};

/**
 * @param {Object} invitee with emailAddress or email
 * @param {String} locusUrl
 * @param {Boolean} alertIfActive
 * @returns {Object} the format object
 */
ParticipantUtil.generateAddParticipantOptions = (invitee, locusUrl, alertIfActive) => ({
  invitee,
  locusUrl,
  alertIfActive
});

/**
 * @param {Array} participantIds
 * @param {String} locusUrl
 * @returns {Object} the format object
 */
ParticipantUtil.generateAdmitParticipantOptions = (participantIds, locusUrl) => ({
  locusUrl,
  participantIds
});

/**
 * @param {Object} options with {invitee: {emailAddress, email}, alertIfActive}
 * @returns {Object} with {invitees: [{address}], alertIfActive}
 */
ParticipantUtil.getAddParticipantBody = (options) => ({
  invitees: [
    {
      address: options.invitee.emailAddress || options.invitee.email
    }
  ],
  alertIfActive: options.alertIfActive
});

/**
 * @param {Object} options with {participantIds}
 * @returns {Object} admit with {participantIds}
 */
ParticipantUtil.getAdmitParticipantRequestBody = (options) => ({
  admit: {participantIds: options.participantIds}
});

/**
 * @param {Object} format with {participantIds, locusUrl}
 * @returns {Object} the request parameters (method, uri, body) needed to make a admitParticipant request
 */
ParticipantUtil.getAdmitParticipantRequestParams = (format) => {
  const body = ParticipantUtil.getAdmitParticipantRequestBody(format);
  return {
    method: PUT,
    uri: `${format.locusUrl}/${CONTROLS}`,
    body
  };
};

/**
 * @param {Object} format with {invitee {emailAddress, email}, locusUrl, alertIfActive}
 * @returns {Object} the request parameters (method, uri, body) needed to make a addParticipant request
 */
ParticipantUtil.getAddParticipantRequestParams = (format) => {
  const body = ParticipantUtil.getAddParticipantBody(format);
  const requestParams = {
    method: PUT,
    uri: format.locusUrl,
    body
  };
  return requestParams;
};

export default ParticipantUtil;
