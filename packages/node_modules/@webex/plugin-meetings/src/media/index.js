/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */
/* globals navigator */

/* eslint-disable no-logger */
import {AUDIO_INPUT, VIDEO_INPUT} from '../constants';
import PeerConnectionManager from '../peer-connection-manager';
/**
 *
 * @export
 * Mimic browser APIs as "the ultimate browser".
 * Handles the quirks of each browser.
 * Extends and enhances adapter.js, i.e., the "media" file from the web client.
 */
const Media = {};

Media.setLocalTracks = (audio, video, stream) => {
  Media.setLocalAudioTracks(audio, stream);
  Media.setLocalVideoTracks(video, stream);
};

Media.setLocalAudioTracks = (audio, stream) => {
  if (stream) {
    if (stream.getAudioTracks) {
      const [audioTrack] = stream.getAudioTracks();
      if (audioTrack) {
        audioTrack.enabled = !audio.mute;
        return true;
      }
    }
  }
  return false;
};

Media.setLocalVideoTracks = (video, stream) => {
  if (stream) {
    if (stream.getVideoTracks) {
      const [videoTrack] = stream.getVideoTracks();
      if (videoTrack) {
        videoTrack.enabled = !video.mute;
        return true;
      }
    }
  }
  return false;
};

Media.generateLocalMedias = (mediaId, audio, video) => {
  if (mediaId) {
    return [
      {
        localSdp: JSON.stringify({
          audioMuted: audio.mute,
          videoMuted: video.mute
        }),
        mediaId
      }
    ];
  }
  return [];
};

Media.getLocalMedia = (options) => {
  const {sendAudio, sendVideo, sendShare} = options;
  // we return undefined here as the second param until screen share is implemented

  if (sendAudio || sendVideo) {
    return Media.getMedia(sendAudio, sendVideo);
  }

  if (sendShare) {
    return Media.getDisplayMedia(
      {
        sendAudio: false,
        sendShare: true
      }
    );
  }

  return Promise.resolve(undefined);
};
/**
 *  Returns the direction and tracks
 * @param {string} trackType type of track (audio/video)
 * @param {object}  streams streams passed
 * @param {boolean} receiveTracks do you want to receive tracks from the remote side
 * @returns {Object} returns direction tracks to be added in transceiver
 */
Media.checkTracks = (trackType, streams, receiveTracks) => {
  const getDirection = (sendTracks, receiveTracks) => {
    if (sendTracks && receiveTracks) {
      return 'sendrecv';
    } if (sendTracks && !receiveTracks) {
      return 'sendOnly';
    } if (!sendTracks && receiveTracks) {
      return 'recvonly';
    } if (sendTracks && receiveTracks) {
      return 'inactive';
    }
    return 'inactive';
  };
  let tracks = null;
  if (streams) {
    if (trackType === 'audio') { tracks = streams.getAudioTracks(); }
    if (trackType === 'video') { tracks = streams.getVideoTracks(); }
    if (tracks && tracks.length === 1) {
      return {track: tracks[0], direction: getDirection(!!tracks, receiveTracks)};
    }
    return {track: trackType, direction: getDirection(!!tracks, receiveTracks)};
  }

  return {track: trackType, direction: getDirection(!!tracks, receiveTracks)};
};
/**
 * creates peerconnection and attaches streams
 * @param {object} mediaProperties mediaProperties
 * @param {Object} audioVideo audioVideo streams
 * @param {Object} localShare sendScreen: {Boolean} sendShare constraints
 * @param {Object} mappedPCs {peerConnection, sharePeerConnection}
 * @returns {Array} [peerConnection, ]
 */
Media.attachMedia = (mediaProperties, audioVideo, localShare) => {
  const {mediaDirection} = mediaProperties;
  const {peerConnection} = mediaProperties;
  let result = null;
  // Add Transceiver for audio
  result = Media.checkTracks('audio', audioVideo, mediaDirection.receiveAudio);
  peerConnection.audioTransceiver = peerConnection.addTransceiver(result.track, {direction: result.direction});

  // Add Transceiver for video
  result = Media.checkTracks('video', audioVideo, mediaDirection.receiveVideo);
  peerConnection.videoTransceiver = peerConnection.addTransceiver(result.track, {direction: result.direction});

  // Add Transceiver for share
  result = Media.checkTracks('video', localShare, mediaDirection.receiveShare);
  peerConnection.shareTransceiver = peerConnection.addTransceiver(result.track, {direction: result.direction});

  peerConnection.onnegotiationneeded = (event) => {
    console.log('PEER-CONNECTION ', event);
  };

  return PeerConnectionManager.createOffer(peerConnection);
};

Media.updateMedia = () => {

};

Media.updateTransceiver = (peerConnection, transceiver, options) => {
  try {
    const result = Media.checkTracks(options.type, options.stream, options.receiveTrack);
    if (options.stream) {
      transceiver.sender.replaceTrack(result.track);
    }
    transceiver.direction = result.direction;
    return PeerConnectionManager.createOffer(peerConnection);
  }
  catch (e) {
    throw e;
  }
};

/**
 * creates peerconnection and attaches streams
 * @param {object} mediaDirection mediaDirection
 * @param {Object} pcManager peerConnectionManager instance
 * @param {Object} mappedPCs {peerConnection, sharePeerConnection}
 * @returns {Array} [peerConnection, sharePeerConnection ]
 */
Media.negotation = (mediaDirection, pcManager, mappedPCs = {}) => {
  const promises = [];
  // Create a peer
  if (mediaDirection.receiveVideo || mediaDirection.receiveAudio) {
    promises.push(
      pcManager.createOffer({
        receiveAudio: mediaDirection.receiveAudio,
        receiveVideo: mediaDirection.receiveVideo,
        peerConnection: mappedPCs.peerConnection
      })
    );
  }
  else {
    promises.push(undefined);
  }

  if (mediaDirection.receiveShare) {
    promises.push(
      pcManager.createOffer({
        // its for screen sharing but can change in future when user wants just share with audio
        receiveAudio: false,
        receiveVideo: mediaDirection.receiveShare,
        peerConnection: mappedPCs.sharePeerConnection
      })
    );
  }
  return Promise.all(promises);
};

/**
 * generates share streams (chrome)
 * @param {object} options parameter
 * @param {Object} options.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} options.sendScreen sendScreen: {Boolean} sendShare constraints
 * @returns {Object} {streams}
 */
Media.getDisplayMedia = (options) =>
  navigator.mediaDevices.getDisplayMedia({audio: options.sendAudio, video: options.sendScreen});

/**
 * generates audio and video using constraints (often called after getSupportedDevices)
 * @param {Object} audio audio: {Boolean} gum constraints
 * @param {Object} video video: {Boolean} gum constraints
 * @returns {Object} {streams}
 */
Media.getMedia = (audio, video) => {
  const mediaConfig = {
    audio,
    video
  };

  return new Promise((resolve, reject) => {
    navigator.mediaDevices
      .getUserMedia(mediaConfig)
      .then((stream) => {
        resolve(stream);
      })
      .catch((err) => {
        reject(
          new Error({
            name: err.name,
            localMediaFailed: true,
            cameraFailed: err === mediaConfig.permissionDenied
          })
        );
      });
  });
};

/**
 * Checks if the machine has at least one audio or video device (Dont use this for screen share)
 * @param {object} options optional parameter
 * {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 * }
 * @returns {Object} {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 *}
 */
Media.getSupportedDevice = ({sendAudio, sendVideo}) =>
  Promise.resolve().then(() => {
    if (!navigator.mediaDevices || navigator.mediaDevices.enumerateDevices === undefined) {
      return {
        sendAudio: true,
        sendVideo: true
      };
    }

    return navigator.mediaDevices.enumerateDevices().then((devices) => {
      const supported = {
        audio: devices.filter((device) => device.kind === AUDIO_INPUT).length > 0,
        video: devices.filter((device) => device.kind === VIDEO_INPUT).length > 0
      };
      return {
        sendAudio: (supported.audio && sendAudio) || true,
        sendVideo: (supported.video && sendVideo) || true
      };
    });
  });

/**
 *
 * Toggle a specific stream
 * @returns {null}
 */
Media.toggleStream = () => {};

/**
 *
 * Stop input stream
 * @param {Stream} stream A media stream
 * @returns {null}
 * @memberof Media
 */
Media.stopStream = (stream) => {
  if (!stream) {
    return Promise.resolve();
  }
  /*
   * To release local media
   * 1) Chrome requires all tracks to be stopped (stream.stop got deprecated)
   * 2) Firefox requires the stream to be stopped
   */
  return Promise.resolve().then(() => {
    if (stream.getTracks) {
      stream.getTracks().forEach((track) => {
        track.stop();
      });
    }
    else if (stream.stop) {
      stream.stop();
    }
  });
};

/**
 * generates streams for audio video and share
 * @param {object} mediaSetting parameter
 * @param {Object} mediaSetting.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} mediaSetting.sendVideo sendVideo: {Boolean} sendVideo constraints
 * @param {Object} mediaSetting.sendScreen sendScreen: {Boolean} sendShare constraints
 * @returns {Array} [localStream, shareStream]
 */
Media.getUserMedia = (mediaSetting) => Media.getLocalMedia({
  sendAudio: mediaSetting.sendAudio,
  sendVideo: mediaSetting.sendVideo
})
  .then((localStream) => Media.getLocalMedia({
    sendShare: mediaSetting.sendShare
  }).then((shareStream) => [localStream, shareStream]));

export default Media;
