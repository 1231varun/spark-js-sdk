import ChildEmitter from 'events';

import {isEqual} from 'lodash';

import Events from '../common/events';
import {EVENTS, LOCUSEVENT, USER, _CALL_, MEETING_STATE, WEBEX_MEETING, LOCUSINFO} from '../constants';
import InfoUtils from '../locus-info/infoUtils';
import FullState from '../locus-info/fullState';
import SelfUtils from '../locus-info/selfUtils';
import HostUtils from '../locus-info/hostUtils';
import MediaSharesUtils from '../locus-info/mediaSharesUtils';
import Parser from '../locus-info/parser';


/**
 * @description LocusInfo extends ChildEmitter to convert locusInfo info a private emitter to parent object
 * @export
 * @class LocusInfo
 */
export default class LocusInfo extends ChildEmitter {
  constructor(updateMeeting, locus = {}, spark) {
    super();
    this.updateMeeting = updateMeeting;
    this.controls = locus.controls || null;
    this.conversationUrl = locus.conversationUrl || null;
    this.created = locus.created || null;
    this.mediaShares = locus.mediaShares || null;
    this.participantsUrl = locus.participantsUrl || null;
    this.replaces = locus.replaces || null;
    this.aclUrl = locus.aclUrl || null;
    this.baseSequence = locus.baseSequence || null;
    this.sequence = locus.sequence || null;
    this.membership = locus.membership || null;
    this.identities = locus.identities || null;
    this.participants = locus.participants || null;
    this.emitChange = false;
    this.parsedLocus = {
      states: []
    };
    this.spark = spark;

    this.updateLocusUrl(locus.url);
    this.updateFullState(locus.fullState);
    this.updateMeetingInfo(locus.info);
    // self and participants generate sipUrl for 1:1 meeting
    this.updateSelf(locus.self, locus.participants);
    this.updateHostInfo(locus.host);
    // this.self = locus.self || null;
    // this.info = locus.info || null;
  }

  initialSetup(locus, meeting) {
    // meeting already exisits just do an update
    if (meeting) {
      // Its a new delta event fetch the whole meeting object
      Parser.updateWithDeltaLocus(locus, meeting);
    }
    else {
      this.onFullLocus(locus);
    }

    // Change it to true after it recives it first locus object
    this.emitChange = true;
  }

  parse(meeting, data) {
    const {eventType} = data;
    switch (eventType) {
      case LOCUSEVENT.PARTICIPANT_JOIN:
      case LOCUSEVENT.PARTICIPANT_LEFT:
      case LOCUSEVENT.CONTROLS_UPDATED:
      case LOCUSEVENT.PARTICIPANT_AUDIO_MUTED:
      case LOCUSEVENT.PARTICIPANT_AUDIO_UNMUTED:
      case LOCUSEVENT.PARTICIPANT_VIDEO_MUTED:
      case LOCUSEVENT.PARTICIPANT_VIDEO_UNMUTED:
      case LOCUSEVENT.SELF_CHANGED:
      case LOCUSEVENT.PARTICIPANT_UPDATED:
      case LOCUSEVENT.PARTICIPANT_CONTROLS_UPDATED:
      case LOCUSEVENT.PARTICIPANT_ROLES_UPDATED:
      case LOCUSEVENT.PARTICIPANT_DECLINED:
      case LOCUSEVENT.FLOOR_GRANTED:
      case LOCUSEVENT.FLOOR_RELEASED:
        this.onFullLocus(data.locus, eventType);
        break;
      case LOCUSEVENT.DIFFERENCE:
        Parser.updateWithDeltaLocus(data.locus, meeting);
        break;

      default:
        // Why will there be a event with no eventType ????
        // we may not need this, we can get full locus
        Parser.updateWithDeltaLocus(data.locus, meeting);
    }
  }

  emitChanges(type, object) {
    Events.emit(type, object);
    // TODO: This will get triggred all the time when there is a
    // Valid object change but we need to decide when to emit it

    // {MeetingInfo} ploicyChange and type change
    // this.policy //
    // this.type: //
  }

  /**
   * updates the locus with full locus object
   * @param {object} locus locus object
   * @param {sting} eventType particulat locus event
   * @returns {object} null
   */
  onFullLocus(locus, eventType) {
    if (!locus) {
      console.log('locus object undefined');
    }
    console.log('EVENTS', eventType);
    this.participants = locus.participants;
    this.updateLocusInfo(locus);
    this.updateParticipants(locus.participants);
    this.isMeetingActive();
    this.handleOneOnOneEvent(eventType);
  }

  // used for ringing stops on one on one
  handleOneOnOneEvent(eventType) {
    if (this.parsedLocus.info.type === _CALL_) {
    // for 1:1 bob calls alice and alice declines, notify the meeting state
      if (eventType === LOCUSEVENT.PARTICIPANT_DECLINED) {
      // trigger the event for stop ringing
        this.emit(EVENTS.REMOTE_ANSWERED_DECLINED, {
          remoteDeclined: true,
          remoteAnswered: false
        });
      }
      // for 1:1 bob calls alice and alice answers, notify the meeting state
      if (eventType === LOCUSEVENT.PARTICIPANT_JOIN) {
      // trigger the event for stop ringing
        this.emit(EVENTS.REMOTE_ANSWERED_DECLINED, {
          remoteDeclined: false,
          remoteAnswered: true
        });
      }
    }
  }

  onDeltaLocus(locus) {
    this.updateLocusInfo(locus);
    this.updateParticipants(locus.participants, true);
  }

  updateLocusInfo(locus) {
    this.updateControls(locus.controls);
    this.updateConversationUrl(locus.conversationUrl);
    this.updateCreated(locus.created);
    this.updateFullState(locus.fullState);
    this.updateHostInfo(locus.host);
    this.updateMeetingInfo(locus.info);
    this.updateMediaShares(locus.mediaShares);
    this.updateParticipantsUrl(locus.participantsUrl);
    this.updateReplace(locus.replace);
    this.updateSelf(locus.self, locus.participants);
    this.updateLocusUrl(locus.url);
    this.updateAclUrl(locus.aclUrl);
    this.updateBasequence(locus.baseSequence);
    this.updateSequence(locus.sequence);
    this.updateMemberShip(locus.membership);
    this.updateIdentifiers(locus.identities);
    // update which required to compare different objects from locus
  }


  getLocusPartner(participants, self) {
    if (!participants || participants.length === 0) {
      console.log('NO participants found ', participants);
      return null;
    }
    return participants.find((participant) =>
      (self && participant.identity !== self.identity)
  && (participants.length <= 2 || (participant.type === USER && !participant.removed))) || this.partner;
  }


  isMeetingActive() {
    if (this.parsedLocus.fullState.type === _CALL_) {
      const partner = this.getLocusPartner(this.participants, this.self);
      this.emit(LOCUSINFO.EVENTS.MEETING_UPDATE, {partner});
      console.log('ISMEETINGACTIVE', partner);

      // Check if guest user needs to be checked here

      // 1) when bob declines call from bob, (bob='DECLINED')
      // 2) When alice rejects call to bob , (bob='NOTIFIED')

      // When we dont add MEDIA for condition 2. The state of bob='IDLE'
      if (partner.state === MEETING_STATE.STATES.LEFT
        && this.parsedLocus.self
        && (this.parsedLocus.self.state === MEETING_STATE.STATES.DECLINED
        || this.parsedLocus.self.state === MEETING_STATE.STATES.NOTIFIED
        || this.parsedLocus.self.state === MEETING_STATE.STATES.JOINED)) {
        console.log('END the ONE ON ONE Call');
        this.emit(EVENTS.DESTROY_MEETING, {
          selfState: this.parsedLocus.self.state
        });
      }
      else
      if (this.parsedLocus.self
        && this.parsedLocus.self.state === MEETING_STATE.STATES.LEFT
      && (partner.state === MEETING_STATE.STATES.LEFT
      || partner.state === MEETING_STATE.STATES.DECLINED
      || partner.state === MEETING_STATE.STATES.NOTIFIED
      || partner.state === MEETING_STATE.STATES.IDLE) // Happens when user just joins and adds no Media
      ) {
        console.log('END the ONE ON ONE Call');
        this.emit(EVENTS.DESTROY_MEETING, {
          selfState: this.parsedLocus.self.state
        });
      }
    }
    else if (this.parsedLocus.info.type === WEBEX_MEETING) {
      if (this.fullState && this.fullState.state === 'INACTIVE') {
        // TODO: update the meeting state
        this.updateMeeting({state: 'ENDED'});
        this.emit(EVENTS.DESTROY_MEETING, {
          selfState: this.parsedLocus.self.state
        });
      }
      else if (this.fullState.removed) {
        // user has been dropped from a meeting
        this.emit(EVENTS.DESTROY_MEETING, {
          selfState: this.parsedLocus.self.state
        });
      }
    }
    else if (this.parsedLocus.info.type === WEBEX_MEETING) {
      if (this.fullState && this.fullState.state === 'INACTIVE') {
        // TODO: update the meeting state
        this.updateMeeting({state: 'ENDED'});
        this.emit(EVENTS.DESTROY_MEETING);
      }
      else if (this.fullState.removed) {
        // user has been dropped from a meeting
        this.emit(EVENTS.DESTROY_MEETING);
      }
    }
    else if (this.parsedLocus.info.type === WEBEX_MEETING) {
      if (this.fullState && this.fullState.state === 'INACTIVE') {
        // TODO: update the meeting state
        this.updateMeeting({state: 'ENDED'});
        this.emit(EVENTS.DESTROY_MEETING);
      }
      else if (this.fullState.removed) {
        // user has been dropped from a meeting
        this.emit(EVENTS.DESTROY_MEETING);
      }
    }
    else {
      console.log('UNKNOWN MEETING TYPE');
    }
  }

  /**
   *
   * @param {Object} participants new participants object
   * @param {boolen} deltaParticpantFlag  delta event
   * @returns {Array} updatedParticipants
   */
  updateParticipants(participants, deltaParticpantFlag) {
    if (deltaParticpantFlag) {
      console.log('Delta participants came through');
    }
    else {
      console.log('Full locus participants came through');
    }
    this.emitChanges(EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS, {
      participants,
      selfIdentity: this.parsedLocus.self.selfIdentity,
      selfId: this.parsedLocus.self.selfId,
      hostId: this.parsedLocus.host.hostId
    });
  }

  // // TODO: check if this causes any perfomance issue
  // findChangedParticipants(newParticipants) {
  //   // TODO: Handle case where if a user got added and removed then find the one added or removed
  //   if (newParticipants.length < 25) {
  //     const changedParticipants = [];
  //     this.participants.forEach((participant, index) => {
  //       // find if participant is in the array
  //       // find if any of the participant  got missed
  //       if (participant && !isEqual(participant, newParticipants[participant.id])) {
  //         this.participants[index] = newParticipants[participant.id];
  //         changedParticipants[participant.id] = participant;
  //       }
  //     });
  //     return changedParticipants;
  //   }
  //   // If more then 25 and we got fullLocus send Everything
  //   return this.participants;
  //   // TODO: find an alternate way or just replace the whole object
  //   // Tell customers that more then 25 we will just send an update
  // }

  updateControls(controls) {
    if (controls && !isEqual(this.controls, controls)) {
      this.controls = controls;
      console.info('LocusInfo:controls got updated');
    }
  }

  updateConversationUrl(conversationUrl) {
    if (conversationUrl && !isEqual(this.conversationUrl, conversationUrl)) {
      this.conversationUrl = conversationUrl;
      this.emitChanges(EVENTS.CONVERSATION_URL_UPDATE, conversationUrl);
      console.info('LocusInfo:conversationUrl got updated');
    }
  }

  updateCreated(created) {
    if (created && !isEqual(this.created, created)) {
      this.created = created;
      console.info('LocusInfo:created got updated');
    }
  }

  updateFullState(fullState) {
    if (fullState && !isEqual(this.fullState, fullState)) {
      // TODO: check what exactly is needed
      // active: true
      // count: 1
      // lastActive: "2019-02-01T16:52:26.764Z"
      // locked: false
      // sessionIds: []
      // state: "ACTIVE"
      // type: "CALL"

      // {
      //   'CALL'; // For 1:1 calls the type is CALL
      //   'MEETING'; // When Guest added the type is meeting
      //   'CALL'; // When guest user leaves
      // }

      const result = FullState.getFullState(this.fullState, fullState);
      // this.emit(LOCUSINFO.EVENTS.MEETING_UPDATE, result.current);
      this.updateMeeting(result.current);
      this.parsedLocus.fullState = result.current;
      if (result.updates.isMeetingEnded) {
        console.log('EMIT MEETING ENDED');
      }

      if (result.updates.isMeetingTerminating) {
        console.log('EMIT MEETING TERMINATED');
      }
      this.fullState = fullState;
      console.info('LocusInfo:fullState got updated', this.fullState);
    }
  }

  /**
   * handles when the locus.host is updated
   * @param {Object} host the locus.host property
   * @returns {undefined}
   * @memberof LocusInfo
   * emits internal event locus_info_update_host
   */
  updateHostInfo(host) {
    if (host && !isEqual(this.host, host)) {
      const parsedHosts = HostUtils.getHosts(this.host, host);
      this.emit(LOCUSINFO.EVENTS.MEETING_UPDATE, parsedHosts.current);
      this.parsedLocus.host = parsedHosts.current;
      if (parsedHosts.updates.isNewHost) {
        this.emitChanges(EVENTS.LOCUS_INFO_UPDATE_HOST, {newHost: parsedHosts.current, oldHost: parsedHosts.previous});
      }
      this.host = host;
      console.info('LocusInfo:host got updated');
    }
  }

  updateMeetingInfo(info) {
    if (info && !isEqual(this.info, info)) {
      this.info = info;
      const parsedInfo = InfoUtils.parse(info);
      this.parsedLocus.info = parsedInfo;
      // Parses the info and adds necessary values
      this.emit(LOCUSINFO.EVENTS.MEETING_UPDATE, parsedInfo);
      console.info('LocusInfo:info got updated', info);
      this.emitChanges('infoUpdated');
    }
  }

  /**
   * handles when the locus.mediaShares is updated
   * @param {Object} mediaShares the locus.mediaShares property
   * @returns {undefined}
   * @memberof LocusInfo
   * emits internal event locus_info_update_media_shares
   */
  updateMediaShares(mediaShares) {
    if (mediaShares && !isEqual(this.mediaShares, mediaShares)) {
      const parsedMediaShares = MediaSharesUtils.getMediaShares(this.mediaShares, mediaShares);
      this.emit(LOCUSINFO.EVENTS.MEETING_UPDATE, parsedMediaShares.current);
      this.emitChanges(EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES, {current: parsedMediaShares.current, previous: parsedMediaShares.previous});
      this.parsedLocus.mediaShares = parsedMediaShares.current;
      this.mediaShares = mediaShares;
      console.info('LocusInfo:mediaShares got updated');
    }
  }

  updateParticipantsUrl(participantsUrl) {
    if (participantsUrl && !isEqual(this.participantsUrl, participantsUrl)) {
      this.participantsUrl = participantsUrl;
      console.info('LocusInfo:participantsUrl got updated');
    }
  }

  updateReplace(replace) {
    if (replace && !isEqual(this.replace, replace)) {
      this.replace = replace;
      console.info('LocusInfo:replace got updated');
    }
  }

  /**
   * handles when the locus.self is updated
   * @param {Object} self the locus.mediaShares property
   * @param {Array} participants the locus.participants property
   * @returns {undefined}
   * @memberof LocusInfo
   * emits internal events self_admitted_guest, self_unadmitted_guest, locus_info_update_self
   */
  updateSelf(self, participants) {
    if (self && !isEqual(this.self, self)) {
      const parsedSelves = SelfUtils.getSelves(this.self, self, this.spark);
      this.emit(LOCUSINFO.EVENTS.MEETING_UPDATE, parsedSelves.current);
      this.parsedLocus.self = parsedSelves.current;

      const element = this.parsedLocus.states[this.parsedLocus.states.length - 1];
      if (element !== parsedSelves.current.state) {
        this.parsedLocus.states.push(parsedSelves.current.state);
      }

      // TODO: check if we need to save the sipUri here as well
      // this.emit(LOCUSINFO.EVENTS.MEETING_UPDATE, SelfUtils.getSipUrl(this.getLocusPartner(participants, self), this.parsedLocus.fullState.type, this.parsedLocus.info.sipUri));
      this.updateMeeting(SelfUtils.getSipUrl(this.getLocusPartner(participants, self), this.parsedLocus.fullState.type, this.parsedLocus.info.sipUri));

      if (parsedSelves.updates.isUnadmittedGuest) {
        this.emit(LOCUSINFO.EVENTS.SELF_UNADMITTED_GUEST, self);
      }
      if (parsedSelves.updates.isAdmittedGuest) {
        this.emit(LOCUSINFO.EVENTS.SELF_ADMITTED_GUEST, self);
      }
      this.emitChanges(EVENTS.LOCUS_INFO_UPDATE_SELF, {oldSelf: parsedSelves.previous, newSelf: parsedSelves.current});
      this.parsedLocus.self = parsedSelves.current;
      this.self = self;
      console.info('LocusInfo:self got updated', self);
    }
  }

  /**
   * handles when the locus.url is updated
   * @param {String} url
   * @returns {undefined}
   * emits internal event locus_info_update_url
   */
  updateLocusUrl(url) {
    if (url && this.url !== url) {
      this.url = url;
      this.emitChanges(EVENTS.LOCUS_INFO_UPDATE_URL, url);
      console.info('LocusInfo:url got updated');
    }
  }

  updateAclUrl(aclUrl) {
    if (aclUrl && !isEqual(this.aclUrl, aclUrl)) {
      this.aclUrl = aclUrl;
      console.info('LocusInfo:aclUrl got updated');
    }
  }

  updateBasequence(baseSequence) {
    if (baseSequence && !isEqual(this.baseSequence, baseSequence)) {
      this.baseSequence = baseSequence;
      console.info('LocusInfo:baseSequence got updated');
    }
  }

  updateSequence(sequence) {
    if (sequence && !isEqual(this.sequence, sequence)) {
      this.sequence = sequence;
      console.info('LocusInfo:sequence got updated');
    }
  }

  updateMemberShip(membership) {
    if (membership && !isEqual(this.membership, membership)) {
      this.membership = membership;
      console.info('LocusInfo:membership got updated');
    }
  }

  updateIdentifiers(identities) {
    if (identities && !isEqual(this.identities, identities)) {
      this.identities = identities;
      console.info('LocusInfo:identities got updated');
    }
  }
}
