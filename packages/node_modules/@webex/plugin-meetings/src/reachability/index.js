/* globals window */
import {StatelessSparkPlugin} from '@ciscospark/spark-core';
import moment from 'moment';
import peerConnectionManager from '../peer-connection-manager';
import {ICESTATE} from '../constants';

import RechabilityRequest from './request';


/* 1)Create a peer connection for each cluster and get Local SDP List.
   2) Once local SDP is got for all clusters, trigger Calliope REST API to get remote SDP for all clusters
   3) Set the remote description for associated peer connection ,trigger ice and capture reachability results
 */

/**
  * @class
  * returns the response time data for the locus cluster
  * @returns {object} rechability result
 */
// no need to pass the spark as already created in previous step


class Rechability extends StatelessSparkPlugin {
  constructor(attrs, options) {
    super({}, options);
    this.rechabilityRequest = new RechabilityRequest({}, options);
    this.orpheusCall();
  }

  orpheusCall = () => {
    // Reset reachability result to empty to ensure no stale data
    try {
      window.localStorage.setItem('reachability.result', JSON.stringify({}));
    }
    catch (error) {
      console.log('There was an error while accessing LocalStorage', error);
      return {};
    }

    // TODO: check if we always need to send the rechability data
    if (!true) {
      console.info('web-calliope-discovery is not enabled..returning.');
      return Promise.resolve({});
    }
    // Get clusters from Orpheus
    return this.rechabilityRequest.getClusters()
      .then((clusters) => {
        // Perform Reachability Check
        const startTime = moment();
        return this.performReachabilityCheck(clusters)
          .then((response) => {
            const endTime = moment();
            const duration = moment.duration(endTime.diff(startTime));
            console.info(`Total time taken for performing reachability check is ${duration.asSeconds()} seconds`);
            window.localStorage.setItem('reachability.result', JSON.stringify(response));
            return response;
          });
      })
      .catch((error) => {
        console.info(`Error in calling getClusters() :${error}`);
        return {};
      });
  };

  performReachabilityCheck = (clusterList) => {
    const iceResult = {};
    const processedClusterResults = [];
    let peerConnectionMap = {};
    let localSDPList = [];
    if (!clusterList || !clusterList.length) {
      return Promise.resolve({});
    }

    return new Promise(((resolve) => {
      this.getLocalSDPForClusters(clusterList)
        .then((localSDPData) => {
          if (!localSDPData || !Object.keys(localSDPData).length || !('localSDPList' in localSDPData) || !('peerConnection' in localSDPData)) {
            console.info('Local SDP is empty or has missing elements..returning.');
            resolve({});
          }

          peerConnectionMap = localSDPData.peerConnection;
          ({localSDPList} = localSDPData);
          return this.rechabilityRequest.remoteSDPForClusters(localSDPList)
            .then((remoteSDPResponse) => {
              const remoteSDPList = remoteSDPResponse.answers;
              if (!remoteSDPList || !remoteSDPList.length) {
                console.info('Remote SDP is empty ');
                this.cleanUpPeerConnections(peerConnectionMap);
                resolve({});
              }
              remoteSDPList.forEach((remoteSdp) => {
                const jsonObj = remoteSdp;
                const {clusterId} = jsonObj;

                if (Object.prototype.hasOwnProperty.call(jsonObj, 'sdp') && jsonObj.sdp) {
                  const pc = peerConnectionMap[clusterId];

                  this.setIceCallBackHandlers(pc)
                    .then((iceStatsResult) => {
                      iceStatsResult.clusterId = clusterId;
                      processedClusterResults.push(iceStatsResult.clusterId);
                      iceResult[iceStatsResult.clusterId] = {
                        start: iceStatsResult.iceStats.start,
                        stop: iceStatsResult.iceStats.stop
                      };

                      if (processedClusterResults.length === remoteSDPList.length) {
                        const reachabilityResult = this.parseIceResultToReachabilityResult(iceResult);
                        console.info(`Returning reachability result${JSON.stringify(reachabilityResult)}`);
                        resolve(reachabilityResult);
                      }
                    })
                    .catch((error) => {
                      console.error(`Error setIceCallBackHandlers : ${error}`);
                      this.cleanUpPeerConnections(peerConnectionMap);
                      resolve({});
                    });
                  peerConnectionManager.setRemoteSessionDetails(pc, 'answer', jsonObj.sdp);
                }
                else {
                  console.info(`${clusterId} : Error in getting remote sdp :Error  : `);
                  processedClusterResults.push(clusterId);
                  if (processedClusterResults.length === remoteSDPList.length) {
                    this.cleanUpPeerConnections(peerConnectionMap);
                    resolve({});
                  }
                }
              });
            })
            .catch((error) => {
              console.error(`Error in remoteSDPForClusters!:${error}`);
              this.cleanUpPeerConnections(peerConnectionMap);
              resolve({});
            });
        })
        .catch((error) => {
          console.error(`Error in getLocalSDPForClusters :${error}`);
          resolve({});
        });
    }));
  };

  getLocalSDPForClusters = (clusterList) => {
    const localSDPData = {};
    const localSDPList = [];
    const peerConnectionMap = {};

    return new Promise(((resolve, reject) => {
      clusterList.forEach((cluster) => {
        const clusterId = cluster;

        peerConnectionManager.createOffer({receiveAudio: true, receiveVideo: false})
          .then((peerConnection) => {
            peerConnectionMap[clusterId] = peerConnection;

            const localSDP = {
              sdp: peerConnection.sdp,
              clusterId
            };

            localSDPList.push(localSDP);

            if (localSDPList.length === clusterList.length) {
              localSDPData.peerConnection = peerConnectionMap;
              localSDPData.localSDPList = localSDPList;
              resolve(localSDPData);
            }
          })
          .catch((error) => {
            reject(new Error(`Error in getLocalSDP : ${error}`));
            console.error(`Error in getLocalSDP : ${error}`);
          });
      });
    }));
  };

  parseIceResultToReachabilityResult = (iceResult) => {
    if (!iceResult || !Object.keys(iceResult).length) {
      return {};
    }
    const result = {};
    for (const clusterId of Object.keys(iceResult)) {
      let reachability = {};
      if (iceResult[clusterId].start > 0 && iceResult[clusterId].stop > 0) {
        const latency = iceResult[clusterId].stop - iceResult[clusterId].start;
        reachability = {
          reachable: true,
          latencyInMilliseconds: latency
        };
      }
      else {
        reachability = {reachable: false};
      }
      result[clusterId] = {udp: reachability};
    }
    return result;
  };

  cleanUpPeerConnections = (peerConnectionMap) => {
    for (const key of Object.keys(peerConnectionMap)) {
      const pc = peerConnectionMap[key];
      if (pc) {
        console.info(`Cleaning up peer connection created for cluster : ${key}`);
        pc.close();
      }
    }
  };

  setIceCallBackHandlers = (pc) => {
    let timeout = null;
    const iceStats = {start: 0, stop: 0};
    return new Promise(((resolve) => {
      function iceComplete(isSuccessful, timeout, iceStats) {
        if (isSuccessful) {
          if (timeout) {
            window.clearTimeout(timeout);
            timeout = undefined;
          }
        }
        pc.close();
        resolve({iceStats});
      }

      timeout = window.setTimeout(() => {
        console.info(`${this.clusterId} : onTimer, ice timeout!`);
        iceComplete(false, timeout, iceStats);
      }, 5000);

      pc.oniceconnectionstatechange = () => {
        if (pc) {
          if (pc.iceConnectionState === ICESTATE.CHECKING) {
            iceStats.start = Date.now();
          }
          if (pc.iceConnectionState === ICESTATE.CONNECTED) {
            iceStats.stop = Date.now();
            iceComplete(true, timeout, iceStats);
          }
          if (pc.iceConnectionState === ICESTATE.FAILED) {
            iceComplete(false, timeout, iceStats);
          }
        }
      };
    }));
  };

  getClusters = () => this.rechabilityRequest.getClusters()
}
export default Rechability;
