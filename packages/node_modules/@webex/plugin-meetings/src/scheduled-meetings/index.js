import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import {MEETINGS, EVENT_TRIGGERS, CALENDAR_EVENTS} from '../constants';

import ScheduledMeetingsRequest from './request';
import ScheduledMeetingsCollection from './collection';

/**
 * @class ScheduledMeetings
 */
export default class ScheduledMeetings extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   */
  constructor(attrs, options) {
    super({}, options);
    this.scheduledMeetingsRequest = new ScheduledMeetingsRequest({}, options);
  }

  /**
   * TODO: when TTL or otherwise is done, add these in the appropriate spot in the ScheduledMeetingsCollection
   * registers mercury events and sends out calendar events to listeners
   * wrapper around the mercury calendar events
   * @returns {undefined}
   */
  registerCalendarEvents() {
    this.spark.internal.mercury.on(CALENDAR_EVENTS.CREATE, (envelope) => {
      this.trigger(EVENT_TRIGGERS.CALENDAR_CREATE, {
        data: envelope.data,
        type: CALENDAR_EVENTS.CREATE
      });
    });
    this.spark.internal.mercury.on(CALENDAR_EVENTS.UPDATE, (envelope) => {
      this.trigger(EVENT_TRIGGERS.CALENDAR_UPDATE, {
        data: envelope.data,
        type: CALENDAR_EVENTS.UPDATE_MINIMAL
      });
    });
    this.spark.internal.mercury.on(CALENDAR_EVENTS.CREATE_MINIMAL, (envelope) => {
      this.trigger(EVENT_TRIGGERS.CALENDAR_CREATE, {
        data: envelope.data,
        type: CALENDAR_EVENTS.CREATE_MINIMAL
      });
    });
    this.spark.internal.mercury.on(CALENDAR_EVENTS.UPDATE_MINIMAL, (envelope) => {
      this.trigger(EVENT_TRIGGERS.CALENDAR_UPDATE, {
        data: envelope.data,
        type: CALENDAR_EVENTS.UPDATE_MINIMAL
      });
    });
    this.spark.internal.mercury.on(CALENDAR_EVENTS.DELETE, (envelope) => {
      this.trigger(EVENT_TRIGGERS.CALENDAR_DELETE, {
        data: envelope.data,
        type: CALENDAR_EVENTS.DELETE
      });
    });
  }

  /**
   * unregisters mercury events and stops sending out listeners
   * @returns {undefined}
   */
  unRegisterCalendarEvents() {
    this.spark.internal.mercury.off(CALENDAR_EVENTS.CREATE);
    this.spark.internal.mercury.off(CALENDAR_EVENTS.UPDATE_MINIMAL);
    this.spark.internal.mercury.off(CALENDAR_EVENTS.CREATE_MINIMAL);
    this.spark.internal.mercury.off(CALENDAR_EVENTS.UPDATE_MINIMAL);
    this.spark.internal.mercury.off(CALENDAR_EVENTS.DELETE);
  }

  /**
   * TODO: implement TTL or otherwise, currently cached until fetched again
   * @param {Object} options options to fetch from the calendar service
   * @returns {Array} scheduled meeting entries
   */
  get(options = {max: this.config.maximumCalendarMeetings}) {
    return this.scheduledMeetingsRequest.fetchScheduledMeetings(options)
      .then((entries) => {
        ScheduledMeetingsCollection.setAll(entries);
        return ScheduledMeetingsCollection.getAll();
      });
  }

  /**
   * TODO: implement TTL or otherwise
   * currently cached until fetched again
   * @param {Array} ids
   * @returns {Array} scheduled meeting entries
   */
  getByIds(ids) {
    if (!ids || !ids.length) {
      return Promise.reject(new Error('Cannot get calendar meetings by id without an array of ids'));
    }
    return this.scheduledMeetingsRequest.fetchScheduledMeetingsByIds(ids)
      .then((entries) => {
        ScheduledMeetingsCollection.setAll(entries);
        return ScheduledMeetingsCollection.getAll();
      });
  }
}
