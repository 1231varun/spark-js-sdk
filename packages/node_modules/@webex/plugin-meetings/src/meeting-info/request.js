import {StatelessSparkPlugin} from '@ciscospark/spark-core';
import btoa from 'btoa';

import {
  SIP_URI,
  PERSONAL_ROOM,
  MEETING_ID,
  CONVERSATION_URL,
  LOCUS_ID,
  MEETING_LINK,
  WEBEX_DOT_COM,
  LOCUS,
  GET,
  PUT,
  USE_URI_LOOKUP_FALSE,
  TYPE,
  LOCI,
  MEETINGINFO,
  MEETINGS,
  ALTERNATE_REDIRECT_TRUE
} from '../constants';

/**
 * Helper function to check if a string matches a known meeting link pattern
 * @param {String} value  string to parse and see if it matches a meeting link
 * @returns {String} returns a sipURL
 * @returns {null} returns null if it's not a valid meeting link
 */
function getMeetingLink(value) {
  // eslint-disable-next-line no-warning-comments
  const regex = /\/\/(.*).webex.com\/meet\/(.*)/; // TODO lets remove regex from this equation and user URI matchers and such
  const m = regex.exec(value);
  let sipUrl = null;

  if (m !== null && m.length === 3) {
    // The result can be accessed through the `m`-variable.
    sipUrl = `${m[2]}@${m[1]}.${WEBEX_DOT_COM}`;
  }

  return sipUrl;
}

/**
 * Helper function to build up a correct locus url depending on the value passed
 * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]
 * @param {Object} value ?? value.value
 * @returns {Object} returns an object with {resource, method}
 */
function getResourceUrl(type, value) {
  let resource = `/${LOCI}/${MEETINGINFO}`;
  let method = GET;
  switch (type) {
    case SIP_URI:
    case PERSONAL_ROOM:
    case MEETING_ID:
      resource = `/${LOCI}/${MEETINGINFO}/${value}?${TYPE}=${type}&${USE_URI_LOOKUP_FALSE}`;
      break;
    case CONVERSATION_URL:
      method = PUT;
      break;
    case LOCUS_ID:
      // if locus id just send PUT request
      resource = `/${LOCI}/${value.value}/${MEETINGINFO}`;
      method = PUT;
      break;
    case MEETING_LINK:
      resource = `$/${LOCI}/${MEETINGINFO}/${btoa(value)}?${TYPE}=${MEETING_LINK}&${USE_URI_LOOKUP_FALSE}`;
      break;
    default:
  }
  return {
    resource,
    method
  };
}

function getRequestParams(resourceOptions, type, value, api) {
  const requestParams = {
    method: resourceOptions.method,
    api,
    resource: resourceOptions.resource
  };
  if (resourceOptions.method === GET) {
    // for handling URL redirections
    requestParams.resource = requestParams.resource.concat(`&${ALTERNATE_REDIRECT_TRUE}`);
  }
  else if (type !== LOCUS_ID) {
    // locus id check is a PUT not sure why
    requestParams.body = {
      value,
      lookupType: type,
      alternateRedirect: true
    };
  }
  return requestParams;
}

function getMeetingInfoTypeValue(options) {
  let value = options.destination;
  // if it's a sip URL, it may need to be rewritten
  const sipUrl = getMeetingLink(value);
  if (sipUrl) {
    value = sipUrl;
  }
  return {
    type: options.type,
    value
  };
}
/**
 * @class MeetingInfoRequest
 */
export default class MeetingInfoRequest extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   *
   * @param {Object} options
   * @returns {Promise} returns a promise that resolves/rejects the result of the request
   */
  fetchMeetingInfo(options) {
    if (!options || !options.type || !options.destination) {
      throw new Error('MeetingInfo should be fetched with a type and destination specified, see list of valid types and their corresponding values in constants');
    }
    const typeValue = getMeetingInfoTypeValue(options);
    return this.request(getRequestParams(getResourceUrl(typeValue.type, typeValue.value), typeValue.type, typeValue.value, LOCUS));
  }
}
