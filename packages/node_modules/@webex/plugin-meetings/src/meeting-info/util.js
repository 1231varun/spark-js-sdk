import btoa from 'btoa';

import {
  SIP_URI,
  PERSONAL_ROOM,
  MEETING_ID,
  CONVERSATION_URL,
  CONVERSATIONS,
  LOCUS_ID,
  MEETING_LINK,
  GET,
  PUT,
  USE_URI_LOOKUP_FALSE,
  TYPE,
  LOCI,
  MEETINGINFO,
  ALTERNATE_REDIRECT_TRUE,
  DIALER_REGEX
} from '../constants';

const MeetingInfoUtil = {};

/**
 * Helper function to check if a string matches a known meeting link pattern
 * @param {String} value  string to parse and see if it matches a meeting link
 * @returns {String} returns a sipURL
 * @returns {null} returns null if it's not a valid meeting link
 */
MeetingInfoUtil.isMeetingLink = (value) => {
  // eslint-disable-next-line no-warning-comments
  // TODO: lets remove regex from this equation and user URI matchers and such
  const regex = /(.*).webex.com\/(?:meet|m)\/(.*)/;
  const m = regex.exec(value);
  if (m !== null && m.length === 3) {
    return true;
  }
  return false;
};


MeetingInfoUtil.isSipUri = (sipString) => {
  // TODO: lets remove regex from this equation and user URI matchers and such
  const sipUri = DIALER_REGEX.SIP_ADDRESS.exec(sipString);
  return sipUri;
};

MeetingInfoUtil.isPhoneNumber = (phoneNumber) => {
  const isValidNumber = DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);
  return isValidNumber;
};

MeetingInfoUtil.generateOptions = (from) => {
  const {destination, type, conversationServiceUrl} = from;
  if (type) {
    return {
      destination,
      type
    };
  }
  const options = {};
  // TODO: convert to sip URI?
  if (MeetingInfoUtil.isMeetingLink(destination)) {
    options.type = MEETING_LINK;
    options.destination = destination;
  }
  else if (MeetingInfoUtil.isSipUri(destination)) {
    options.type = SIP_URI;
    options.destination = destination;
  }
  else if (MeetingInfoUtil.isPhoneNumber(destination)) {
    options.type = SIP_URI;
    options.destination = destination;
  }
  else {
    options.type = CONVERSATION_URL;
    options.destination = `${conversationServiceUrl}/${CONVERSATIONS}/${destination}`;
  }
  return options;
};

/**
 * Helper function to build up a correct locus url depending on the value passed
 * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]
 * @param {Object} value ?? value.value
 * @returns {Object} returns an object with {resource, method}
 */
MeetingInfoUtil.getResourceUrl = (type, value) => {
  let resource = `/${LOCI}/${MEETINGINFO}`;
  let method = GET;
  switch (type) {
    case SIP_URI:
    case PERSONAL_ROOM:
    case MEETING_ID:
      resource = `/${LOCI}/${MEETINGINFO}/${value}?${TYPE}=${type}&${USE_URI_LOOKUP_FALSE}`;
      break;
    case CONVERSATION_URL:
      method = PUT;
      break;
    case LOCUS_ID:
      resource = `/${LOCI}/${value}/${MEETINGINFO}`;
      method = PUT;
      break;
    case MEETING_LINK:
      resource = `$/${LOCI}/${MEETINGINFO}/${btoa(value)}?${TYPE}=${MEETING_LINK}&${USE_URI_LOOKUP_FALSE}`;
      break;
    default:
  }
  return {
    resource,
    method
  };
};

MeetingInfoUtil.getRequestParams = (resourceOptions, type, value, api) => {
  const requestParams = {
    method: resourceOptions.method,
    api,
    resource: resourceOptions.resource
  };
  if (resourceOptions.method === GET) {
    // for handling URL redirections
    requestParams.resource = requestParams.resource.concat(`&${ALTERNATE_REDIRECT_TRUE}`);
  }
  else if (type !== LOCUS_ID) {
    // locus id check is a PUT not sure why
    requestParams.body = {
      value,
      lookupType: type,
      alternateRedirect: true
    };
  }
  return requestParams;
};

MeetingInfoUtil.getMeetingInfoAPIFormat = (options) => ({
  type: options.type,
  value: options.destination
});

export default MeetingInfoUtil;
