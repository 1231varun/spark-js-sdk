import {forEach} from 'lodash';

import {
  PUT,
  CONTROLS,
  IN_LOBBY,
  IN_MEETING,
  NOT_IN_MEETING,
  USER,
  RESOURCE_ROOM,
  JOINED,
  NONE,
  IDLE,
  WAIT,
  OBSERVE,
  LEFT
} from '../constants';

import Member from './member';

const MembersUtil = {};

MembersUtil.extractHostOwner = (locus) =>
  (locus && locus.owner && locus.owner.info ? locus.owner.info : null);

MembersUtil.extractSelfUserId = (locus) =>
  (locus && locus.self && locus.self.person && locus.self.person.id ? locus.self.person.id : null);

MembersUtil.isUser = (member) =>
  (member && member.type === USER);

MembersUtil.isDevice = (member) =>
  (member && member.type === RESOURCE_ROOM);

MembersUtil.getMemberStatus = (member) => {
  if (!(member && member.devices && member.devices.length)) {
    return NOT_IN_MEETING;
  }
  const device = member && member.devices ? member.devices[0] : null;
  if (device) {
    if (device.state === JOINED && (!device.intent || device.intent.type === NONE)) {
      return IN_MEETING;
    }
    if (device.state === IDLE && device.intent && (device.intent.type === WAIT || device.intent.type === OBSERVE)) {
      return IN_LOBBY;
    }
    if (device.state === LEFT || (device.state === IDLE && (!device.intent || device.intent.type === NONE))) {
      return NOT_IN_MEETING;
    }
  }
  return NOT_IN_MEETING;
};

MembersUtil.handledAddToLobbyMeetingUnjoinedLists = (members, member) => {
  switch (MembersUtil.getMemberStatus(member)) {
    case IN_LOBBY:
      return members.inLobbyList.push(new Member(member, {isInLobby: true}));
    case IN_MEETING:
      return members.inMeetingList.push(new Member(member, {isInMeeting: true}));
    case NOT_IN_MEETING:
      return members.notInMeetingList.push(new Member(member, {isNotInMeeting: true}));
    default:
      return members.notInMeetingList.push(new Member(member, {isNotInMeeting: true}));
  }
};

MembersUtil.handleAddToHostList = (members, member, hostIdentity, selfUserIdentity) => {
  if (hostIdentity
  && hostIdentity !== selfUserIdentity) {
    if (MembersUtil.isUser(member)
    && member.identity === hostIdentity) {
      return members.hostList.push(new Member(member, {isHost: true}));
    }
    if (MembersUtil.isDevice(member)
    && member.associatedUsers && member.associatedUsers.some((user) => (user.identity === hostIdentity))
    ) {
      return members.hostList.push(new Member(member, {isHost: true}));
    }
  }
  return null;
};

MembersUtil.handleAddToSelfList = (members, member, selfUserIdentity) => {
  if (MembersUtil.isUser(member)
  && member.identity === selfUserIdentity) {
    return members.selfList.push(new Member(member, {isSelf: true}));
  }
  if (MembersUtil.isDevice(member)
  && member.associatedUsers && member.associatedUsers.some((u) => (u.identity === selfUserIdentity))) {
    return members.selfList.push(new Member(member, {isSelf: true}));
  }
  return null;
};

MembersUtil.handleSetFullList = (members, participants) => {
  // eslint-disable-next-line
  members.fullList = participants;
};

MembersUtil.handleAddToFullList = (members, participant) => {
  members.fullList.push(participant);
};

MembersUtil.constructMembers = (locus, members, selfUserIdentity, hostIdentity) => {
  if (!(locus && locus.participants && locus.participants.length && members)) {
    throw new Error('Could not construct meeting member list. Some value is not present');
  }
  MembersUtil.handleSetFullList(locus.participants, members);
  forEach(locus.participants, (locusParticipant) => {
    if (locusParticipant.hideInRoster) {
      return;
    }
    if (MembersUtil.handleAddToSelfList(members, locusParticipant, selfUserIdentity)) {
      return;
    }
    if (MembersUtil.handleAddToHostList(members, locusParticipant, hostIdentity, selfUserIdentity)) {
      return;
    }
    MembersUtil.handledAddToLobbyMeetingUnjoinedLists(members, locusParticipant);
  });
};

// MembersUtil.extractAddedMembers = (members, participants) => {
//   const addedMembers = [];
//   forEach(participants, (participant) => {
//     forEach(members, (member) => {
//     });
//   });
// };

// MembersUtil.extractRemovedMembers = (members, participants) => {

// };

// MembersUtil.extractUpdatedParticipants = (members, participants) => {

// };

/**
 * @param {Object} invitee with emailAddress or email
 * @param {String} locusUrl
 * @param {Boolean} alertIfActive
 * @returns {Object} the format object
 */
MembersUtil.generateAddMemberOptions = (invitee, locusUrl, alertIfActive) => ({
  invitee,
  locusUrl,
  alertIfActive
});

/**
 * @param {Array} memberIds
 * @param {String} locusUrl
 * @returns {Object} the format object
 */
MembersUtil.generateAdmitMemberOptions = (memberIds, locusUrl) => ({
  locusUrl,
  memberIds
});

/**
 * @param {Object} options with {invitee: {emailAddress, email}, alertIfActive}
 * @returns {Object} with {invitees: [{address}], alertIfActive}
 */
MembersUtil.getAddMemberBody = (options) => ({
  invitees: [
    {
      address: options.invitee.emailAddress || options.invitee.email
    }
  ],
  alertIfActive: options.alertIfActive
});

/**
 * @param {Object} options with {memberIds}
 * @returns {Object} admit with {memberIds}
 */
MembersUtil.getAdmitMemberRequestBody = (options) => ({
  admit: {memberIds: options.memberIds}
});

/**
 * @param {Object} format with {memberIds, locusUrl}
 * @returns {Object} the request parameters (method, uri, body) needed to make a admitMember request
 */
MembersUtil.getAdmitMemberRequestParams = (format) => {
  const body = MembersUtil.getAdmitMemberRequestBody(format);
  return {
    method: PUT,
    uri: `${format.locusUrl}/${CONTROLS}`,
    body
  };
};

/**
 * @param {Object} format with {invitee {emailAddress, email}, locusUrl, alertIfActive}
 * @returns {Object} the request parameters (method, uri, body) needed to make a addMember request
 */
MembersUtil.getAddMemberRequestParams = (format) => {
  const body = MembersUtil.getAddMemberBody(format);
  const requestParams = {
    method: PUT,
    uri: format.locusUrl,
    body
  };
  return requestParams;
};

export default MembersUtil;
