/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */
import {isEmpty} from 'lodash';
import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import Events from '../events';
import {MEETINGS, EVENT_TRIGGERS, EVENTS} from '../constants';

import MembersCollection from './collection';
import MembersRequest from './request';
import MembersUtil from './util';

/**
 * @class Members
 */
export default class Members extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   * @memberof Members
   */
  constructor(attrs, options) {
    super({}, options);
    this.membersRequest = new MembersRequest({}, options);
    this.membersCollection = new MembersCollection();
    this.locusUrl = null;
    this.setUpLocusInfoListeners();
  }

  /**
   * @returns {undefined}
   */
  setUpLocusInfoListeners() {
    this.setUpLocusUrlListener();
    this.setUpLocusParticipantsListener();
  }

  /**
   * @returns {undefined}
   */
  setUpLocusParticipantsListener() {
    Events.on('LOCUS_INFO_FULL_PARTICIPANTS', (payload) => {
      if (payload) {
        this.handleLocusInfoFullParticipants(payload);
      }
    });
    Events.on('LOCUS_INFO_DELTA_PARTICIPANTS', (payload) => {
      if (payload) {
        this.handleLocusInfoUpdatedParticipants(payload);
      }
    });
  }

  /**
   * @returns {undefined}
   */
  setUpLocusUrlListener() {
    Events.on(EVENTS.LOCUS_URL_UPDATE, (payload) => {
      if (payload) {
        this.setLocusUrl(null, payload);
      }
    });
  }

  /**
   * @param {Object} payload
   * @returns {Object}
   */
  handleLocusInfoUpdatedParticipants(payload) {
    const membersUpdate = this.membersCollection.update(payload);
    if (membersUpdate) {
      this.trigger('MEMBERS_UPDATE', membersUpdate);
    }
    return membersUpdate;
  }

  /**
   * @param {Object} payload
   * @returns {Object}
   */
  handleLocusInfoFullParticipants(payload) {
    const membersFull = this.membersCollection.refresh(payload);
    if (membersFull) {
      this.trigger('MEMBERS_FULL', membersFull);
    }
    return membersFull;
  }

  /**
   * update the locus Url
   * @param {Object} locus
   * @param {String} locusUrl optional, takes precedence
   * @throws {Error}
   * @returns {undefined}
   * @memberof Members
   */
  setLocusUrl(locus, locusUrl = null) {
    if (locusUrl) {
      this.locusUrl = locusUrl;
    }
    else if (locus && (locus.locusUrl || locus.url)) {
      this.locusUrl = locus.locusUrl || locus.url;
    }
    else {
      throw new Error('Setting locusUrl for the Members module should be done with a locus object or locusUrl');
    }
  }

  /**
   * @param {Object} locus the locus object for the meeting at join time
   * @returns {Members} post construction
   * @throws {Error} if there is no locus object to work on
   * @memberof Members
   */
  set(locus) {
    if (!locus) {
      throw new Error('Cannot set up an initial members object without a locus');
    }
    this.setLocusUrl(locus);
    const members = this.membersCollection.create(locus);
    this.trigger(EVENT_TRIGGERS.MEMBERS_CREATED, members);
  }

  /**
   * adds a guest Member to the associated meeting
   * @param {String} invitee
   * @param {Boolean} alertIfActive optional parameter
   * @returns {Promise}
   * @memberof Members
   */
  addMember(invitee, alertIfActive) {
    if (!(!invitee || (!invitee.emailAddress || !invitee.email) || !this.locusUrl)) {
      return Promise.reject(new Error('invitee must be passed and the associated locus url for this meeting object must be defined.'));
    }
    const options = MembersUtil.generateAddMemberOptions(invitee, this.locusUrl, alertIfActive);
    return this.membersRequest.addMember(options).then((res) => res).catch((error) => error); // TODO:
  }

  /**
   * admits waiting members (invited guests to meeting)
   * @param {Array} memberIds
   * @returns {Promise}
   * @memberof Members
   */
  admitMembers(memberIds) {
    if (isEmpty(memberIds)) {
      return Promise.reject(new Error('No member ids provided to admit.'));
    }
    const options = MembersUtil.generateAdmitMemberOptions(memberIds, this.locusUrl);
    return this.membersRequest.admitMember(options).then((res) => res).catch((error) => error); // TODO:
  }
}
