/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */
import {isEmpty} from 'lodash';
import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import Events from '../events';
import {MEETINGS, EVENT_TRIGGERS, EVENTS, FLOOR_ACTION, CONTENT} from '../constants';
import Member from '../member';

import MembersCollection from './collection';
import MembersRequest from './request';
import MembersUtil from './util';

/**
 * @class Members
 */
export default class Members extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   * @memberof Members
   */
  constructor(attrs, options) {
    super({}, options);
    this.membersRequest = new MembersRequest({}, options);
    this.membersCollection = new MembersCollection();
    this.locusUrl = null;
    this.hostId = null;
    this.selfId = null;
    this.mediaShareContentId = null;
    this.lastParticipants = null;
    this.setUpLocusInfoListeners();
  }

  /**
   * @returns {undefined}
   */
  setUpLocusInfoListeners() {
    this.setUpLocusUrlListener();
    this.setUpLocusHostListener();
    this.setUpLocusSelfListener();
    this.setUpLocusParticipantsListener();
    this.setUpLocusMediaSharesListener();
  }

  /**
   * @returns {undefined}
   */
  setUpLocusSelfListener() {
    Events.on(EVENTS.LOCUS_INFO_UPDATE_SELF, (payload) => {
      let newSelfId = null;
      let oldSelfId = null;
      if (payload) {
        if (payload.newSelf) {
          newSelfId = payload.newSelf.id;
        }
        if (payload.oldSelf) {
          oldSelfId = payload.oldSelf.id;
        }
      }
      if (newSelfId) {
        const theSelf = this.membersCollection.get(newSelfId);
        if (theSelf) {
          theSelf.setIsSelf(true);
        }
      }
      if (oldSelfId) {
        const notSelf = this.membersCollection.get(oldSelfId);
        if (notSelf) {
          notSelf.setIsSelf(false);
        }
      }
      this.selfId = newSelfId;
      this.trigger(EVENT_TRIGGERS.MEMBERS_SELF_UPDATE, {
        activeSelfId: newSelfId,
        endedSelfId: oldSelfId
      });
    });
  }

  /**
   * @returns {undefined}
   */
  setUpLocusHostListener() {
    Events.on(EVENTS.LOCUS_INFO_UPDATE_HOST, (payload) => {
      let newHostId = null;
      let oldHostId = null;
      if (payload) {
        if (payload.newHost) {
          newHostId = payload.newHost.id;
        }
        if (payload.oldHost) {
          oldHostId = payload.oldHost.id;
        }
      }
      if (newHostId) {
        const theHost = this.membersCollection.get(newHostId);
        if (theHost) {
          theHost.setIsHost(true);
        }
      }
      if (oldHostId) {
        const notHost = this.membersCollection.get(oldHostId);
        if (notHost) {
          notHost.setIsHost(false);
        }
      }
      this.hostId = newHostId;
      this.trigger(EVENT_TRIGGERS.MEMBERS_HOST_UPDATE, {
        activeHostId: newHostId,
        endedHostId: oldHostId
      });
    });
  }

  /**
   * @returns {undefined}
   */
  setUpLocusParticipantsListener() {
    Events.on(EVENTS.LOCUS_INFO_FULL_PARTICIPANTS, (payload) => {
      if (payload) {
        const membersFull = this.handleLocusInfoFullParticipants(payload);
        this.trigger(EVENT_TRIGGERS.MEMBERS_FULL, membersFull);
      }
    });
    Events.on(EVENTS.LOCUS_INFO_DELTA_PARTICIPANTS, (payload) => {
      if (payload) {
        const delta = this.handleLocusInfoUpdatedParticipants(payload);
        const full = this.handleMembersUpdate(delta);
        this.trigger(EVENT_TRIGGERS.MEMBERS_UPDATE, {delta, full});
      }
    });
  }

  handleMembersUpdate(membersUpdate) {
    if (membersUpdate) {
      if (membersUpdate.updated) {
        membersUpdate.updated.forEach((member) => {
          this.membersCollection.set(member.id, member);
        });
      }
      if (membersUpdate.added) {
        membersUpdate.added.forEach((member) => {
          this.membersCollection.set(member.id, member);
        });
      }
    }
    return this.membersCollection.getAll();
  }

  /**
   * @returns {undefined}
   */
  setUpLocusMediaSharesListener() {
    Events.on(EVENTS.LOCUS_INFO_MEDIA_SHARES_UPDATE, (payload) => {
      const currentContent = payload.current;
      let whoSharing = null;
      let whoStopped = null;
      if (currentContent && currentContent.contentId) {
        if (currentContent.disposition === FLOOR_ACTION.GRANTED) {
          whoSharing = currentContent.contentId;
        }
        else if (currentContent.disposition === FLOOR_ACTION.RELEASED) {
          whoStopped = currentContent.contentId;
        }
      }
      if (whoSharing) {
        const shareMember = this.membersCollection.get(whoSharing);
        if (shareMember) {
          shareMember.setIsContentSharing(true);
        }
      }
      if (whoStopped) {
        const stopMember = this.membersCollection.get(whoStopped);
        if (stopMember) {
          stopMember.setIsContentSharing(false);
        }
      }
      this.mediaShareContentId = whoSharing;
      this.trigger(EVENT_TRIGGERS.MEMBERS_CONTENT_UPDATE, {
        activeContentSharingId: whoSharing,
        endedContentSharingId: whoStopped
      });
    });
  }

  /**
   * @returns {undefined}
   */
  setUpLocusUrlListener() {
    Events.on(EVENTS.LOCUS_INFO_URL_UPDATE, (payload) => {
      if (payload) {
        this.setLocusUrl(null, payload);
      }
    });
  }

  /**
   * @param {Object} payload
   * @returns {Object}
   */
  handleLocusInfoUpdatedParticipants(payload) {
    this.hostId = payload.hostId || this.hostId;
    this.selfId = payload.selfId || this.selfId;
    const memberUpdate = this.update(payload.participants || this.lastParticipants);
    return memberUpdate;
  }

  /**
   * @param {Object} payload
   * @returns {Object}
   */
  handleLocusInfoFullParticipants(payload) {
    this.hostId = payload.hostId || this.hostId;
    this.selfId = payload.selfId || this.selfId;
    this.populate({participants: payload.participants || this.lastParticipants});
    return this.membersCollection.getAll();
  }

  /**
   * update the locus Url
   * @param {Object} locus
   * @param {String} locusUrl optional, takes precedence
   * @throws {Error}
   * @returns {undefined}
   * @memberof Members
   */
  setLocusUrl(locus, locusUrl = null) {
    if (locusUrl) {
      this.locusUrl = locusUrl;
    }
    else if (locus && (locus.locusUrl || locus.url)) {
      this.locusUrl = locus.locusUrl || locus.url;
    }
    else {
      throw new Error('Setting locusUrl for the Members module should be done with a locus object or locusUrl');
    }
  }

  /**
   * update the locus Url
   * @param {Object} locus
   * @param {String} hostId optional, takes precedence
   * @throws {Error}
   * @returns {undefined}
   * @memberof Members
   */
  setHostId(locus, hostId = null) {
    if (hostId) {
      this.hostId = hostId;
    }
    else if (locus) {
      this.hostId = locus && locus.owner && locus.owner.info ? locus.owner.info : null;
    }
    else {
      throw new Error('Setting hostid for the Members module should be done with a locus object or hostId');
    }
  }

  /**
   * update the locus Url
   * @param {Object} locus
   * @param {String} selfId optional, takes precedence
   * @throws {Error}
   * @returns {undefined}
   * @memberof Members
   */
  setSelfId(locus, selfId = null) {
    if (selfId) {
      this.selfId = selfId;
    }
    else if (locus) {
      this.selfId = locus && locus.self && locus.self.person && locus.self.person.id ? locus.self.person.id : null;
    }
    else {
      throw new Error('Setting selfid for the Members module should be done with a locus object or selfId');
    }
  }

  /**
   * update the locus Url
   * @param {Object} locus
   * @param {String} contentId optional, takes precedence
   * @throws {Error}
   * @returns {undefined}
   * @memberof Members
   */
  setMediaShareContentId(locus, contentId) {
    if (contentId) {
      this.mediaShareContentId = contentId;
    }
    else if (locus) {
      this.mediaShareContentId = locus
      && locus.mediaShares && locus.mediaShares.length && locus.mediaShares[0] && locus.mediaShares[0].name === CONTENT
      && locus.mediaShares[0].floor && locus.mediaShares[0].floor.beneficiary ? locus.mediaShares[0].floor.beneficiary.id
        : null;
    }
    else {
      throw new Error('Setting hostid for the Members module should be done with a locus object or hostId');
    }
  }

  /**
   * @param {Object} locus the locus object for the meeting at join time
   * @returns {Members} post construction
   * @throws {Error} if there is no locus object to work on
   * @memberof Members
   */
  create(locus) {
    if (!locus) {
      throw new Error('Cannot set up an initial members object without a locus');
    }
    // not sure we need all these, have to check after delta
    this.setLocusUrl(locus);
    this.setHostId(locus);
    this.setSelfId(locus);
    this.setMediaShareContentId(locus);
    const members = this.populate(locus);
    this.trigger(EVENT_TRIGGERS.MEMBERS_CREATED, members);
  }

  populate(locus) {
    if (!(locus && locus.participants && locus.participants.length)) {
      throw new Error('Could not construct meeting member list. Some value is not present');
    }
    this.membersCollection.initialize();
    this.lastParticipants = locus.participants;
    locus.participants.forEach((participant) => {
      if (participant.hideInRoster) {
        return;
      }
      const member = new Member(participant, {selfId: this.selfId, hostId: this.hostId, contentSharingId: this.mediaShareContentId});
      this.membersCollection.set(member.id, member);
    });
    return this.membersCollection.getAll();
  }

  update(participants) {
    const membersUpdate = {added: [], updated: []};
    if (participants) {
      participants.forEach((participant) => {
        if (participant.hideInRoster) {
          return;
        }
        if (this.membersCollection.get(participant.id)) {
          membersUpdate.updated.push(new Member(participant, {selfId: this.selfId, hostId: this.hostId, contentSharingId: this.mediaShareContentId}));
        }
        else {
          membersUpdate.added.push(new Member(participant, {selfId: this.selfId, hostId: this.hostId, contentSharingId: this.mediaShareContentId}));
        }
      });
    }
    return membersUpdate;
  }

  /**
   * adds a guest Member to the associated meeting
   * @param {String} invitee
   * @param {Boolean} alertIfActive optional parameter
   * @returns {Promise}
   * @memberof Members
   */
  addMember(invitee, alertIfActive) {
    if (!(!invitee || (!invitee.emailAddress || !invitee.email) || !this.locusUrl)) {
      return Promise.reject(new Error('invitee must be passed and the associated locus url for this meeting object must be defined.'));
    }
    const options = MembersUtil.generateAddMemberOptions(invitee, this.locusUrl, alertIfActive);
    return this.membersRequest.addMember(options).then((res) => res).catch((error) => error);
  }

  /**
   * admits waiting members (invited guests to meeting)
   * @param {Array} memberIds
   * @returns {Promise}
   * @memberof Members
   */
  admitMembers(memberIds) {
    if (isEmpty(memberIds)) {
      return Promise.reject(new Error('No member ids provided to admit.'));
    }
    const options = MembersUtil.generateAdmitMemberOptions(memberIds, this.locusUrl);
    return this.membersRequest.admitMember(options).then((res) => res).catch((error) => error);
  }
}
