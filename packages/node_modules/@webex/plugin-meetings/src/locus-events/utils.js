import {min, max} from 'lodash';

import {DELTAEVENT} from '../constants';

const ParseUtils = {};

ParseUtils.compareLocus = (newSequence, currentSequence) => {
  const newMin = Math.min(newSequence.rangeStart, min(newSequence.entries));
  const newMax = Math.max(newSequence.rangeEnd, max(newSequence.entries));
  const curMin = Math.min(currentSequence.rangeStart, min(currentSequence.entries));
  const curMax = Math.max(currentSequence.rangeEnd, max(currentSequence.entries));

  const newUniqueCurrent = ParseUtils.calculateUnique(newSequence, currentSequence);
  const currentUniqueNew = ParseUtils.calculateUnique(currentSequence, newSequence);

  const newHasRange = !(newSequence.rangeStart === 0 && newSequence.rangeEnd === 0);
  const curHasRange = !(currentSequence.rangeStart === 0 && currentSequence.rangeEnd === 0);

  if (newMin > curMax) {
    return DELTAEVENT.GT;
  }
  if (newMax < curMin) {
    return DELTAEVENT.LT;
  }
  if (!newUniqueCurrent.length && !currentUniqueNew.length) {
    if ((newSequence.rangeEnd - newMin) > (currentSequence.rangeEnd - curMin)) {
      return DELTAEVENT.GT;
    }
    if ((newSequence.rangeEnd - newMin) < (currentSequence.rangeEnd - curMin)) {
      return DELTAEVENT.LT;
    }

    return DELTAEVENT.EQ;
  }
  if (newUniqueCurrent.length && !currentUniqueNew.length) {
    return DELTAEVENT.GT;
  }
  if (currentUniqueNew.length && !newUniqueCurrent.length) {
    return DELTAEVENT.LT;
  }

  if ((!newHasRange && !curHasRange) || ParseUtils.hasUniqueButInRange(newUniqueCurrent, curMin, curMax)
    || ParseUtils.hasUniqueButInRange(currentUniqueNew, newMin, newMax)) {
    return DELTAEVENT.CF;
  }
  if (min(newUniqueCurrent) > min(currentUniqueNew)) {
    return DELTAEVENT.GT;
  }

  return DELTAEVENT.LT;
};


ParseUtils.generateSyncDebugFlag = (meeting, deltaLocus) => {
  const {baseSequence} = deltaLocus;
  const workingSequence = meeting.locus.sequence;
  const targetSequence = deltaLocus.sequence;
  const flags = ['', '', '', '', '', ''];

  const setFlag = (sequence) => {
    if (!sequence) {
      return 'undef';
    }
    return (ParseUtils.isEmptySequence(sequence)) ? 'empty' : 'def';
  };
  flags[0] = setFlag(baseSequence);
  flags[1] = setFlag(workingSequence);
  flags[2] = setFlag(targetSequence);

  flags[3] = (baseSequence && workingSequence) ? ParseUtils.compareLocus(baseSequence, workingSequence).toLowerCase() : 'na';
  flags[4] = (workingSequence && targetSequence) ? ParseUtils.compareLocus(workingSequence, targetSequence).toLowerCase() : 'na';
  flags[5] = (baseSequence && targetSequence) ? ParseUtils.compareLocus(baseSequence, targetSequence).toLowerCase() : 'na';


  // TODO: check where it is used
  meeting.desyncFlagString = flags.toString();
};

ParseUtils.calculateUnique = (s1, s2) => {
  const res = [];
  s1.entries.forEach((entry) => {
    /* istanbul ignore else */
    if ((entry < s2.rangeStart || entry > s2.rangeEnd) && (s2.entries.indexOf(entry) === -1)) {
      res.push(entry);
    }
  });
  return res;
};


ParseUtils.isEmptySequence = (sequence) => {
  if (Object.prototype.hasOwnProperty.call(sequence, 'rangeStart') && sequence.rangeStart === 0
    && Object.prototype.hasOwnProperty.call(sequence, 'rangeEnd') && sequence.rangeEnd === 0
    && sequence.entries && sequence.entries.length === 0) {
    return true;
  }
  return false;
};

ParseUtils.hasUniqueButInRange = (uniqueEntries, minimum, maximum) =>
  uniqueEntries.some((entry) => ((entry > minimum) && (entry < maximum)));

export default ParseUtils;
