import {isEmpty} from 'lodash';

import Media from '../media';
import LoggerProxy from '../common/logs/logger-proxy';
import {INTENT_TO_JOIN, MODERATOR_TRUE, MODERATOR_FALSE} from '../constants';
import IntentToJoinError from '../common/errors/intent-to-join';
import JoinMeetingError from '../common/errors/join-meeting';

const MeetingUtil = {};

MeetingUtil.parseLocusJoin = (response) => {
  const parsed = {};

  // First todo: add check for existance
  parsed.locus = response.body.locus;
  parsed.mediaConnections = response.body.mediaConnections;
  parsed.locusUrl = parsed.locus.url;
  parsed.locusId = parsed.locus.url.split('/').pop();
  parsed.selfId = parsed.locus.self.id;

  // we need mediaId before making roap calls
  parsed.mediaConnections.forEach((mediaConnection) => {
    if (mediaConnection.mediaId) {
      parsed.mediaId = mediaConnection.mediaId;
    }
  });

  return parsed;
};

MeetingUtil.remoteUpdateAudioVideo = (audio, video, meeting) => {
  if (!meeting) {
    return Promise.reject(new Error('You need a meeting object.'));
  }
  const localMedias = Media.generateLocalMedias(meeting.mediaId, audio, video);

  if (isEmpty(localMedias)) {
    return Promise.reject(new Error('You need a media id on the meeting to change remote audio.'));
  }

  return meeting.meetingRequest.remoteAudioVideoToggle({
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    localMedias,
    deviceUrl: meeting.deviceUrl,
    correlationId: meeting.correlationId
  });
};

// TODO: have locus ignore hostPin if they find out it's my claimed PMR
/*
for my claimed PMR
passing an "undefined" hostPin was causing the issue.
if I don't include hostPin in the first request, locus figures out it's my PMR
and sends a 200 after the first request
so we must clean up the hostPin to stop the double request
*/
MeetingUtil.cleanOptions = (options, info, owner, userId) => {
  if (MeetingUtil.hasOwner(info)) {
    if (MeetingUtil.isOwnerSelf(owner, userId)) {
      if (options.hostPin) {
        delete options.hostPin;
      }
      options.moderator = MODERATOR_TRUE;
    }
    else {
      options.moderator = MODERATOR_FALSE;
    }
  }

  return options;
};

MeetingUtil.hasOwner = (info) => info && info.owner;

MeetingUtil.isOwnerSelf = (owner, selfId) => owner === selfId;

MeetingUtil.isPinOrGuest = (err) => {
  if (err && err.body && err.body.errorCode === INTENT_TO_JOIN) {
    return true;
  }

  return false;
};

MeetingUtil.joinMeeting = (meeting, options) => {
  if (!meeting) {
    return Promise.reject(new Error('You need a meeting object.'));
  }

  // eslint-disable-next-line no-warning-comments
  // TODO: check if the meeting is in JOINING state
  // if Joining state termintate the request as user might click multiple times
  return meeting.meetingRequest
    .joinMeeting({
      sipUri: meeting.sipUri,
      deviceUrl: meeting.deviceUrl,
      locusUrl: meeting.locusUrl,
      correlationId: meeting.id,
      resourceId: meeting.resourceId,
      moderator: options.moderator,
      hostPin: options.hostPin
    })
    .then((res) => MeetingUtil.parseLocusJoin(res));
};

MeetingUtil.getSdps = (meeting) => {
  const sdps = [];

  if (meeting.mediaProperties.mediaPeerConnection) {
    sdps.push(meeting.mediaProperties.mediaPeerConnection.sdp);
  }
  if (meeting.mediaProperties.sharePeerConnection) {
    sdps.push(meeting.mediaProperties.sharePeerConnection.sdp);
  }

  return sdps;
};

MeetingUtil.leaveMeeting = (meeting) => meeting.meetingRequest
  .leaveMeeting({
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    correlationId: meeting.correlationId,
    resourceId: null,
    deviceUrl: meeting.deviceUrl
  })
  .then((response) => meeting.locusInfo.onFullLocus(response.body.locus))
  .then(() => meeting.closeLocalStream())
  .then(() => meeting.closeLocalShare())
  .then(() => meeting.closePeerConnections())
  .then(() => {
    meeting.unsetLocalStream();
    meeting.unsetLocalShare();
    meeting.unsetRemoteStream();
    meeting.unsetPeerConnections();
  })
  .then(() => meeting.roap.stop(meeting.correlationId, meeting.roapSeq))
  .then(() => Promise.resolve())
  .catch((err) => {
    LoggerProxy.logger.error(`An error occured while trying to leave meeting with an id of ${meeting.id}`, err);

    return Promise.reject(err);
  });

MeetingUtil.declineMeeting = (meeting, reason) => meeting.meetingRequest
  .declineMeeting({
    locusUrl: meeting.locusUrl,
    deviceUrl: meeting.deviceUrl,
    reason
  });

MeetingUtil.joinMeetingOptions = (meeting, options) => {
  meeting.resourceId = meeting.resourceId || options.resourceId;
  meeting.setCorrelationId(meeting.id);
  // TODO: this should be removed following locus changes.
  options = MeetingUtil.cleanOptions(options, meeting.meetingInfo, meeting.owner, meeting.userId);

  // normal join meeting, scenario A, D
  return MeetingUtil.joinMeeting(meeting, options)
    .then((response) => {
      meeting.setLocus(response);

      return Promise.resolve();
    })
    .catch((err) => {
      // joining a claimed PMR that is not my own, scenario B
      if (MeetingUtil.isPinOrGuest(err)) {
        if (MeetingUtil.hasOwner(meeting.meetingInfo)) {
          return MeetingUtil.joinMeeting(meeting, options).then((response) => {
            meeting.setLocus(response);

            return Promise.resolve();
          });
        }

        // request host pin or non host for unclaimed PMR, start of Scenario C
        // see https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-Lobby-and--IVR-Feature
        return Promise.reject(new IntentToJoinError(err));
      }
      LoggerProxy.logger.log('Meeting:index#join --> Error joining the call on getLocalMedia, ', err);

      return Promise.reject(new JoinMeetingError(err, options));
    });
};

export default MeetingUtil;
