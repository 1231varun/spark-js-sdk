import StateMachine from 'javascript-state-machine';
import StateMachineHistory from 'javascript-state-machine/lib/history';

import Media from '../media';
import MeetingUtil from '../meeting/util';
import {MEETING_VIDEO_STATE_MACHINE, EVENT_TRIGGERS, EVENT_TYPES} from '../constants';

const handleTransition = (value, video, meeting) => {
  if (video.mute && video.self) {
    value = MEETING_VIDEO_STATE_MACHINE.STATES.MUTE_SELF;
  }
  if (!video.mute && video.self) {
    value = MEETING_VIDEO_STATE_MACHINE.STATES.UNMUTE_SELF;
  }
  return value;
};

const VideoStateMachine = {
  create() {
    return new StateMachine({
      transitions: [
        {
          name: MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.INIT,
          from: '*',
          to: function (video, meeting) {
            return handleTransition(this.state, video, meeting);
          }
        },
        {
          name: MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.TOGGLE,
          from: '*',
          to: function (video, meeting) {
            return handleTransition(this.state, video, meeting);
          }
        }
      ],
      data: {
        muted: undefined,
        self: undefined
      },
      methods: {
        getMuted() {
          return this.muted;
        },
        getSelf() {
          return this.self;
        },
        onAfterInit(transition, video, meeting) {
          this.muted = video.mute;
          this.self = video.self;
          meeting.trigger(EVENT_TRIGGERS.MEDIA_VIDEO, {
            type: EVENT_TYPES.local,
            status: this.state,
            muted: this.muted,
            from: MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.INIT
          });
          console.log(`roap:state#onAfterToggle->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}''.`);
        },
        onAfterHistoryBack(transition, meeting, error) {
          meeting.trigger(EVENT_TRIGGERS.MEDIA_VIDEO, {
            type: EVENT_TYPES.ERROR,
            status: this.state,
            muted: this.muted,
            from: MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.TOGGLE,
            error
          });
          console.log(`roap:state#onAfterToggle->${transition.event} fired! State failed to change with transition '${transition.transition}''. State has been reset to ${this.history[this.history.length - 1]} and toggling has been reversed.`);
        },
        onAfterToggle(transition, video, meeting) {
          if (video.self) {
            this.self = true;
          }
          if (transition.from !== transition.to) {
            MeetingUtil.remoteUpdateAudioVideo({mute: meeting.audio.muted}, video, meeting)
              .then((resolution) => {
                Media.localTracks({mute: meeting.audio.muted}, video, meeting.localMediaStream);
                this.muted = video.mute;
                meeting.trigger(EVENT_TRIGGERS.MEDIA_VIDEO, {
                  type: EVENT_TYPES.local,
                  status: this.state,
                  muted: this.muted,
                  from: MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.TOGGLE,
                  resolution
                });
                console.log(`roap:state#onAfterToggle->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}''.`);
              }).catch((err) => {
                this.historyBack(meeting, err);
              });
          }
        },
        plugins: [
          new StateMachineHistory({max: 2})
        ]
      }
    });
  }
};

export default VideoStateMachine;
