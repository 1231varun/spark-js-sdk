import StateMachine from 'javascript-state-machine';
import StateMachineHistory from 'javascript-state-machine/lib/history';

import Media from '../media';
import MeetingUtil from '../meeting/util';
import {MEETING_VIDEO_STATE_MACHINE, EVENT_TRIGGERS, EVENT_TYPES} from '../constants';

const handleTransition = (value, video, meeting) => {
  if (video.mute && video.self) {
    value = MEETING_VIDEO_STATE_MACHINE.STATES.MUTE_SELF;
  }
  if (!video.mute && video.self) {
    value = MEETING_VIDEO_STATE_MACHINE.STATES.UNMUTE_SELF;
  }
  return value;
};

const triggerEvent = (meeting, state, result, trigger, type) => {
  meeting.trigger(trigger, {
    type,
    status: state.state,
    muted: state.muted,
    result
  });
};

const doToggle = (state, transition, video, meeting) => {
  MeetingUtil.remoteUpdateAudioVideo({mute: meeting.audio.muted}, video, meeting)
    .then((resolution) => {
      try {
        Media.setLocalTracks({mute: meeting.audio.muted}, video, meeting.localMediaStream);
      }
      catch (error) {
        MeetingUtil.remoteUpdateAudioVideo({mute: meeting.audio.muted}, {mute: state.muted}, meeting).catch((error) => {
          console.log(
            `video:state#onBeforeTogglek->${transition.event} fired! State failed to change with transition '${
              transition.transition
            }''. After local video toggle failed, resetting remote also failed, meeting video in bad state with error: ${error}.`
          );
        });
        triggerEvent(meeting, state, error, EVENT_TRIGGERS['MEDIA:VIDEO_CHANGED'], EVENT_TYPES.ERROR);
        console.log(
          `video:state#onBeforeTogglek->${transition.event} fired! State failed to change with transition '${
            transition.transition
          }''. State has been reset and toggling has been reversed.`
        );
        return Promise.reject(error);
      }
      triggerEvent(meeting, state, resolution, EVENT_TRIGGERS['MEDIA:VIDEO_CHANGED'], EVENT_TYPES.LOCAL);
      console.log(
        `video:state#onAfterToggle->${transition.event} fired! State changed from '${transition.from}' to '${
          transition.to
        }' with transition '${transition.transition}''.`
      );
      return Promise.resolve(resolution);
    })
    .catch((error) => {
      triggerEvent(meeting, state, error, EVENT_TRIGGERS['MEDIA:VIDEO_CHANGED'], EVENT_TYPES.ERROR);
      console.log(
        `video:state#onAfterHistoryBack->${transition.event} fired! State failed to change with transition '${
          transition.transition
        }''. State has been reset and toggling has been reversed.`
      );
      return Promise.reject(error);
    });
};

const VideoStateMachine = {
  create(mediaDirection) {
    if (!mediaDirection.sendVideo) {
      return undefined;
    }
    return new StateMachine({
      transitions: [
        {
          name: MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.TOGGLE,
          from: '*',
          to(video, meeting) {
            return handleTransition(this.state, video, meeting);
          }
        }
      ],
      data: {
        muted: false,
        self: true
      },
      methods: {
        isMuted() {
          return this.muted;
        },
        isSelf() {
          return this.self;
        },
        setData(video) {
          this.muted = video.mute;
          this.self = video.self;
        },
        // if fails, return false will cancel the transition and the state will remain unchanged, else true and keep going
        onBeforeToggle(transition, video, meeting) {
          if (transition.from !== transition.to) {
            doToggle(this, transition, video, meeting);
          }
          return Promise.resolve(this.data);
        },
        onAfterToggle(transition, video, meeting) {
          this.setData(video);
          return Promise.resolve(this.data);
        },
        plugins: [new StateMachineHistory({max: 5})]
      }
    });
  }
};

export default VideoStateMachine;
