import uuid from 'uuid';
import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import Roap from '../roap/index';
import Media from '../media';
import LocusUtil from '../locus-events/utils';
import MeetingStateMachine from '../meeting/state';
import AudioStateMachine from '../meeting/audio';
import VideoStateMachine from '../meeting/video';
import PeerConnectionManager from '../peer-connection-manager';
import MeetingRequest from '../meeting/request';
import Participants from '../participants/index';
import MeetingUtil from '../meeting/util';
import WebRTCStats from '../stats/index';
import IntentToJoinError from '../errors/intent-to-join';
import JoinMeetingError from '../errors/join-meeting';
import { MEETINGS, EVENT_TRIGGERS, EVENT_TYPES, FLOOR_ACTION, BUSY, OUTGOING, DELTAEVENT} from '../constants';

/**
 * @export
 * @class Meeting
 */
export default class Meeting extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   * Create an instance of Meeting
   *
   * @param {Object} attrs
   * @param {Object} options
   * @memberof Meeting
   */
  constructor(attrs, options) {
    super({}, options);
    this.attrs = attrs;
    this.options = options;
    this.id = uuid.v4();
    this.userId = attrs.userId;
    this.resource = attrs.resource;
    this.deviceUrl = attrs.deviceUrl;
    this.roapSeq = 0;
    this.meetingInfo = attrs.meetingInfo || {};
    this.meetingRequest = new MeetingRequest({}, options);
    this.participants = new Participants({}, {parent: this.spark});
    this.roap = new Roap({}, options);
    this.audio = null;
    this.video = null;
    this.state = MeetingStateMachine.create(this);
    this.stats = null;
    this.convoId = null;
    this.locusUrl = null;
    this.sipUri = null;
    this.partner = null;
    this.type = null;
    this.owner = null;
    this.hostId = null;
  }

  /**
   * invite a guest to the call that isn't normally part of this call
   * @param {Object} invitee with {emailAddress or email}
   * @param {Boolean} alertIfActive optional
   * @returns {Promise}
   * @memberof Meeting
   */
  invite(invitee, alertIfActive = true) {
    return this.participants.addParticipant(invitee, alertIfActive);
  }

  /**
   * admit the guest(s) to the call once they are waiting
   * @param {Array} participantIds
   * @returns {Promise}
   * @memberof Meeting
   */
  admit(participantIds) {
    return this.participants.admitParticipants(participantIds);
  }

  /**
   * Reference to the Participants object
   * @returns {Participants}
   * @memberof Meeting
   */
  getParticipants() {
    return this.participants;
  }

  /**
   * Reference to the stats builder object
   * @param {Object} options - optional {media: {}, screen: {}} see stats/index
   * @returns {MeetingStats}
   * @memberof Meeting
   */
  getStats(options) {
    if (!this.stats) {
      return this.createStats(options);
    }
    return this.stats;
  }

  /**
   * Overwrite the stats builder object
   * @param {Object} options - optional {media: {}, screen: {}} see stats/index
   * @returns {MeetingStats}
   * @memberof Meeting
   */
  createStats(options) {
    this.stats = new WebRTCStats(this.attrs, this.options, options);
    return this.stats;
  }

  /**
   * Convenience function to tell whether a meeting is muted
   * @returns {Boolean} if meeting audio muted or not
   * @memberof Meeting
   */
  isAudioMuted() {
    return this.audio.isMuted();
  }

  /**
   * Convenience function to tell if the end user last changed the audio state
   * @returns {Boolean} if audio was manipulated by the end user
   * @memberof Meeting
   */
  isAudioSelf() {
    return this.audio.isSelf();
  }

  /**
   * Convenience function to tell whether video is muted
   * @returns {Boolean} if meeting video is muted or not
   * @memberof Meeting
   */
  isVideoMuted() {
    return this.video.isMuted();
  }

  /**
   * Convenience function to tell whether the end user changed the video state
   * @returns {Boolean} if meeting video is muted or not
   * @memberof Meeting
   */
  isVideoSelf() {
    return this.video.isSelf();
  }

  /**
   * Sets the meeting info on the class instance
   * @param {Object} meetingInfo
   * @returns {null}
   * @memberof Meeting
   */
  parseMeetingInfo(meetingInfo) {
    // MeetingInfo will be undefined for 1:1 calls
    if (meetingInfo && !(this.meetingInfo.errors && this.meetingInfo.errors.length > 0)) {
      this.convoId = this.meetingInfo.convoId || this.convoId;
      this.locusUrl = this.meetingInfo.locusUrl || this.locusUrl;
      this.sipUri = this.meetingInfo.sipMeetingUri || this.sipUri;
      this.owner = this.meetingInfo.owner || this.owner;
    }
  }

  /**
   * Sets the first locus info on the class instance
   * @param {Object} locus
   * @returns {null}
   * @memberof Meeting
   */
  parseLocus(locus) {
    if (locus) {
      this.locusUrl = locus.url;
      if (locus.info) {
        this.type = MeetingUtil.getLocusType(locus.info.locusTags);
      }
      if (locus.participants && locus.self) {
        this.partner = MeetingUtil.getLocusPartner(locus.participants, locus.self);
      }
      if (this.partner) {
        this.sipUri = this.partner.person.sipUrl || this.partner.person.emailAddress || this.partner.person.email;
      }
      this.setLocus(locus);
    }
  }

  /**
   * Sets the sip uri on the class instance
   * uses meeting info as precedence
   * @param {String} sipUri
   * @returns {null}
   * @memberof Meeting
   */
  setSipUri(sipUri) {
    // This can be tel no, device id or a sip uri, user Id
    this.sipUri = sipUri;
  }

  /**
   * Set the roap seq on the class instance
   * @param {Number} seq
   * @returns {null}
   * @memberof Meeting
   */
  setRoapSeq(seq) {
    if (seq) {
      this.roapSeq = seq;
    }
  }

  /**
   * // TODO: change name to genertic parser
   * Set the locus info the class instance
   * @param {Object} locus
   * @returns {null}
   * @memberof Meeting
   */
  setLocus(locus) {
    const mtgLocus = locus.locus || locus;
    this.locus = mtgLocus;
    this.mediaConnections = locus.mediaConnections;
    this.locusUrl = locus.locusUrl || locus.url;
    this.locusId = locus.locusId;
    this.selfId = locus.selfId;
    this.mediaId = locus.mediaId;
    this.hostId = mtgLocus.host ? mtgLocus.host.id : this.hostId;
    this.participants.set(mtgLocus);
  }

  /**
   * Sets the remote stream on the class instance and emits and
   * event do developers
   * @param {Object} pc The remote stream peer connection
   * @returns {null}
   * @memberof Meeting
   */
  setRemoteStream(pc) {
    if (!pc) {
      return;
    }
    // eslint-disable-next-line no-param-reassign
    pc.ontrack = (event) => {
      [this.remoteStream] = event.streams;

      // eslint-disable-next-line no-warning-comments
      // TODO: It's possible for media to not be present
      // so we might need to either
      // A) wait until we have media flowing
      // B) trigger a second event when video is flowing
      this.trigger(EVENT_TRIGGERS.MEDIA_READY, {
        type: EVENT_TYPES.REMOTE,
        stream: this.remoteStream
      });
    };
  }

  /**
   * Removes the remote stream on the class instance and triggers an event
   * to developers
   * @returns {null}
   * @memberof Meeting
   */
  unsetRemoteStream() {
    this.remoteStream = null;
  }

  /**
   * Removes the remote stream on the class instance and triggers an event
   * to developers
   * @returns {null}
   * @memberof Meeting
   */
  closeRemoteStream() {
    return Media.stopStream(this.remoteStream).then(() => {
      this.trigger(EVENT_TRIGGERS.MEDIA_STOPPED, {
        type: EVENT_TYPES.REMOTE
      });
    });
  }

  /**
   * Sets the sceen stream on the class instance and triggers and event to developers
   * @param {Object} pc a peer connection instance for the screen
   * @returns {null}
   * @memberof Meeting
   */
  setShareStream(pc) {
    if (!pc) {
      return;
    }
    // eslint-disable-next-line no-param-reassign
    pc.ontrack = (event) => {
      [this.remoteShare] = event.streams;

      this.trigger(EVENT_TRIGGERS.MEDIA_READY, {
        type: EVENT_TYPES.REMOTE_SHARE,
        stream: this.remoteShare
      });
    };
  }

  /**
   * Sets the local media stream on the class and emits an event to the developer
   * @param {Steam} localStream the local media stream
   * @returns {null}
   * @memberof Meeting
   */
  setLocalStream(localStream) {
    if (localStream) {
      this.localStream = localStream;

      this.trigger(EVENT_TRIGGERS.MEDIA_READY, {
        type: EVENT_TYPES.LOCAL,
        stream: this.localStream
      });
    }
  }

  /**
 * Sets the local media stream on the class and emits an event to the developer
 * @param {Steam} localShare the local media stream
 * @returns {null}
 * @memberof Meeting
 */
  setLocalShare(localShare) {
    if (localShare) {
      this.localShare = localShare;

      this.trigger(EVENT_TRIGGERS.MEDIA_READY, {
        type: EVENT_TYPES.LOCAL_SHARE,
        stream: this.localShare
      });
    }
  }

  /**
   * Closes the local stream from the class and emits an event to the developer
   * @returns {null}
   * @memberof Meeting
   */
  closeLocalStream() {
    return Media.stopStream(this.localStream).then(() => {
      this.trigger(EVENT_TRIGGERS.MEDIA_STOPPED, {
        type: EVENT_TYPES.LOCAL
      });
    });
  }

  /**
 * Closes the local stream from the class and emits an event to the developer
 * @returns {null}
 * @memberof Meeting
 */
  closeLocalShare() {
    return Media.stopStream(this.localShare).then(() => {
      this.trigger(EVENT_TRIGGERS.MEDIA_STOPPED, {
        type: EVENT_TYPES.LOCAL_SHARE
      });
    });
  }

  /**
   * Removes the local stream from the class and emits an event to the developer
   * @returns {null}
   * @memberof Meeting
   */
  unsetLocalStream() {
    this.localStream = null;
  }

  /**
  * Removes the local share from the class and emits an event to the developer
  * @returns {null}
  * @memberof Meeting
  */
  unsetLocalShare() {
    this.localShare = null;
  }

  /**
   * Sets the peer connections on the class
   * @param {PeerConnection} mediaPeerConnection
   * @param {PeerConnection} sharePeerConnection
   * @returns {null}
   * @memberof Meeting
   */
  setPeerConnections(mediaPeerConnection, sharePeerConnection) {
    this.mediaPeerConnection = mediaPeerConnection;
    this.sharePeerConnection = sharePeerConnection;
  }

  /**
   * Close the peer connections and remove them from the class. Triggers an event
   * when each is closed.
   * @returns {Promise} returns a resolved promise with an array of closed peer connections
   * @memberof Meeting
   */
  closePeerConnections() {
    return Promise.all([
      PeerConnectionManager.close(this.mediaPeerConnection),
      PeerConnectionManager.close(this.sharePeerConnection)
    ]);
  }

  /**
   * Unsets the peer connections on the class
   * @param {PeerConnection} mediaPeerConnection
   * @param {PeerConnection} sharePeerConnection
   * @returns {null}
   * @memberof Meeting
   */
  unsetPeerConnections() {
    this.mediaPeerConnection = null;
    this.sharePeerConnection = null;
  }

  /**
   * Convenience method to set the correlation id for the Meeting
   * @param {String} id correlation id to set on the class
   * @returns {null}
   * @memberof Meeting
   */
  setCorrelationId(id) {
    this.correlationId = id;
  }

  /**
   * Mute the audio for a meeting
   * @returns {Promise} resolves the data from muting audio {mute, self}
   * @returns {Error} an error if there is no audio state machine
   * @memberof Meeting
   */
  muteAudio() {
    if (!this.audio || (this.audio && !this.audio.toggle)) {
      return Promise.reject(new Error('no audio control associated to the meeting'));
    }
    return this.audio.toggle({
      mute: true,
      self: true
    });
  }

  /**
   * Unmute meeting audio
   * @returns {Promise} resolves data from muting audio {mute, self}
   * @returns {Error} an error if there is no audio state machine
   * @memberof Meeting
   */
  unmuteAudio() {
    if (!this.audio || (this.audio && !this.audio.toggle)) {
      return Promise.reject(new Error('no audio control associated to the meeting'));
    }
    return this.audio.toggle({
      mute: false,
      self: true
    });
  }

  /**
   * Mute the video for a meeting
   * @returns {Promise} resolves data from muting video {mute, self}
   * @returns {Error} an error if there is no video state machine
   * @memberof Meeting
   */
  muteVideo() {
    if (!this.video || (this.video && !this.video.toggle)) {
      return Promise.reject(new Error('no video control associated to the meeting'));
    }
    return this.video.toggle({
      mute: true,
      self: true
    });
  }

  /**
   * Unmute meeting video
   * @returns {Promise} resolves data from muting video {mute, self}
   * @returns {Error} an error if there is no video state machine
   * @memberof Meeting
   */
  unmuteVideo() {
    if (!this.video || (this.video && !this.video.toggle)) {
      return Promise.reject(new Error('no audio control associated to the meeting'));
    }
    const options = {};
    options.mute = false;
    options.self = true;
    return this.video.toggle({
      mute: false,
      self: true
    });
  }

  /**
   *
   * Specify joining via audio (option: pstn), video, screenshare
   * @exports
   * @param {object} options A configurable options object for joining a meeting
   * @param {String} options.resourceId pass the deviceId
   * @param {Number} options.hostPin pass the host pin
   * @param {Boolean} options.moderator pass the moderator flag
   * @returns {Promise}
   * @memberof Meeting
   * Scenario A: Joining own claimed personal meeting room, don't pass hostPin, do pass moderator
   * Scenario B: Joining other's claimed personal meeting room, do pass hostPin (if desired to join as host, or nullify), do pass moderator
   * Scenario C: Joining an unclaimed personal meeting room, -do not- pass hostPin or moderator on first try, -do- pass hostPin and moderator
   *             if joining as host on second loop, -do not- pass hostPin do pass moderator if joining as guest on second loop
   * Scenario D: Joining any other way (sip, pstn, convoId, link just need to specify resourceId)
   */
  join(options = {}) {
    this.resourceId = options.resourceId;
    this.setCorrelationId(this.id);
    // this.state.join();
    this.spark.meetings.notifyRinging(this, OUTGOING);
    // TODO: this should be removed following locus changes.
    options = MeetingUtil.cleanOptions(options, this.meetingInfo, this.owner, this.userId);
    // normal join meeting, scenario A, D
    return MeetingUtil.joinMeeting(this, options)
      .then((response) => {
        this.setLocus(response);
        this.spark.meetings.notifyRinging(this, null, false);
        return response;
        // this.state.connect();
      })
      .catch((err) => {
        this.spark.meetings.notifyRinging(this, null, false);
        // joining a claimed PMR that is not my own, scenario B
        if (MeetingUtil.isPinOrGuest(err)) {
          if (MeetingUtil.hasOwner(this.meetingInfo)) {
            return MeetingUtil.joinMeeting(this, options)
              .then((response) => {
                this.setLocus(response);
                return response;
                // this.state.connect();
              });
          }
          // request host pin or non host for unclaimed PMR, start of Scenario C
          // see https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-Lobby-and--IVR-Feature
          return Promise.reject(new IntentToJoinError(err));
        }
        this.logger.log('Meeting:index#join --> Error joining the call on getLocalMedia, ', err);
        return Promise.reject(new JoinMeetingError(err, options));
      });
  }

  /**
   *
   * get local media streams based on options passed
   * @exports
   * @param {object} mediaDirection A configurable options object for joining a meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  getMediaStreams = (mediaDirection) => Media.getUserMedia(mediaDirection)

  /**
   *
   * Specify joining via audio (option: pstn), video, screenshare
   * @exports
   * @param {object} options A configurable options object for joining a meeting
   * @param {Object } options.resourceId pass the deviceId
   * @returns {Promise}
   * @memberof Meeting
   */
  addMedia(options = {}) {
    const {localStream, localShare} = options;
    // eslint-disable-next-line no-warning-comments
    // TODO wire into default config. There's currently an issue with the stateless plugin or how we register
    const mediaDirection = Object.assign(this.config.mediaSettings, options.mediaSettings);

    // add a setup a function move the create and setup media in future
    this.audio = AudioStateMachine.create(mediaDirection, this);
    this.video = VideoStateMachine.create(mediaDirection, this);

    // this.state.local();
    this.setLocalStream(localStream);
    this.setLocalShare(localShare);
    return Media.attachMedia(mediaDirection, PeerConnectionManager, localStream, localShare)
      .then(([mediaPeerConnection, sharePeerConnection]) => {
        const updatedsharePeerConnection = PeerConnectionManager.setContentSlides(sharePeerConnection);

        this.setPeerConnections(mediaPeerConnection, updatedsharePeerConnection);
        this.setRemoteStream(this.mediaPeerConnection);
        this.setShareStream(this.sharePeerConnection);
        return this.roap.start();
      })
      .catch((err) => {
        this.logger.log('Meeting:index#join --> Error joining the call on roap initialization, ', err);
        throw err;
      })
      .then(() =>
        this.roap
          .sendRoapMediaRequest({
            sdps: MeetingUtil.getSdps(this),
            roapSeq: this.roapSeq,
            meeting: this // or can pass meeting ID
          })
          .catch((err) => {
            this.logger.error('Meeting:index#join --> Error joining the call on send roap media request, ', err);
            throw err;
          }))
      .then(() => {
        // this.state.establish();
      });
  }

  /**
   * acknowledge the incoming meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  acknowledge() {
    return this.meetingRequest
      .acknowledgeMeeting({
        locusUrl: this.locusUrl,
        deviceUrl: this.deviceUrl,
        id: this.id
      })
      .then((response) => {
        this.trigger(EVENT_TRIGGERS.MEETING_ALERTED, this);
        return response;
      });
  }

  /**
   *
   * Decline this meeting
   * @param {String} reason
   * @returns {Promise}
   * @memberof Meeting
   */
  decline(reason = BUSY) {
    return this.meetingRequest
      .declineMeeting({
        locusUrl: this.locusUrl,
        deviceUrl: this.deviceUrl,
        reason
      })
      .then((response) => this.spark.meetings.destroy(this, response));
  }

  /**
   *
   * Leave the current meeting
   * @param {Object} options An object of options
   * @param {Boolean} options.keepLocalMedia Whether to tear down the local media connections or not.
   * @returns {Promise}
   * @memberof Meeting
   */
  leave() {
    // this.state.leave();
    return this.meetingRequest
      .leaveMeeting({
        locusUrl: this.locusUrl,
        selfId: this.selfId,
        correlationId: this.correlationId,
        resourceId: null,
        deviceUrl: this.deviceUrl
      })
      .then(() => this.closeLocalStream())
      .then(() => this.closeLocalShare())
      .then(() => this.closePeerConnections())
      .then(() => {
        this.unsetLocalStream();
        this.unsetLocalShare();
        this.unsetRemoteStream();
        this.unsetPeerConnections();
      })
      .then(() => {
        this.roap.stop(this.correlationId, this.roapSeq);
      })
      .then(() => {
        this.state.end();
      })
      .catch((err) => {
        this.state.error();
        this.logger.error(`An error occured while trying to leave meeting with an id of ${this.id}`, err);
      })
      .finally(() => {
        this.state.clean();
      });
  }


  // https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events
  updateWithDeltaLocus(deltaLocus, isNewMeeting) {
    // /* istanbul ignore else */
    // if (!(deltaLocus.sequence && (deltaLocus.sequence.rangeStart <= deltaLocus.sequence.rangeEnd) && (deltaLocus.sequence.rangeEnd <= min(deltaLocus.sequence.entries)))) {
    //   return null;
    // }
    // /* istanbul ignore else */

    // THIS IS A NEW MEETING OBJECT
    // // If meeting has no sequence, it means just initialized and will apply whatever in locus DTO
    // if (isNewMeeting || !this.locus.sequence) {
    //   this._updateWithDeltaLocus(deltaLocus, emitter);
    //   this.locusDesync = false;
    //   this.needToGetFullLocus = false;
    //   return DELTAEVENT.GT;
    // }

    if (!deltaLocus.sequence) {
      // TODO: FORce update
    }

    // TODO: If this was the first event, the client will not have a syncURL
    // in its working copy to do a GET on. In this case clients should do a GET on locusUrl contained in the DTO

    let res;
    let resBase;
    res = LocusUtil.compareLocus(deltaLocus.sequence, this.locus.sequence);
    // In-coming locus is greater than working copy, need to compare with base if there
    // is base sequence except the first delta locus event
    if (res === DELTAEVENT.GT && deltaLocus.baseSequence && this.locus.syncUrl) {
      resBase = LocusUtil.compareLocus(this.locus.sequence, deltaLocus.baseSequence);
      if (resBase === DELTAEVENT.LT || resBase === DELTAEVENT.CF) {
        res = DELTAEVENT.CF;
      }
    }
    // Special case for OBTP with meeting size equal or over 5. Locus might change this later
    // This is a temporary fix. I will find a better solution later.
    if (!deltaLocus.baseSequence && res === DELTAEVENT.EQ && deltaLocus.fullState.state === 'INITIALIZING'
      && deltaLocus.sequence.rangeStart === 0 && deltaLocus.sequence.rangeEnd === 0
      && deltaLocus.sequence.entries.length === 0) {
      res = DELTAEVENT.GT;
    }
    console.log('RESULT :', res);
    switch (res) {
      case DELTAEVENT.LT:
      case DELTAEVENT.EQ:
        this.locusDesync = false;
        this.needToGetFullLocus = false;
        break;
      case DELTAEVENT.CF:
        LocusUtil.generateSyncDebugFlag(this, deltaLocus);
        if (this.locusDesync) {
          this.needToGetFullLocus = true;
        }
        this.locusDesync = true;
        break;
      case DELTAEVENT.GT:
        console.info('MeetingAmpstate#updateWithDeltaLocus: MeetingConstants.deltaLocusResult.GT');
        this._updateWithDeltaLocus(deltaLocus);
        // Turn off desync in case this delta locus comes from a sync request
        this.locusDesync = false;
        this.needToGetFullLocus = false;
        break;
      default:
    }
    return res;
  }

  _updateWithDeltaLocus(deltaLocus) {
    console.log('updated the locus Object');

    // Update Metrics
    // UpdateMeetingInfo ?? not sure if we need to
    // updatePstnStatus
    // updateParticipantList
    // updateMeetingStatus
    // update Meeting Controls
    // update share Status
    // Update DisplayHint ?  not sure if needed


    // Update latest sequence and syncUrl
    // // Update sequence
    // if (this.status !== MeetingConstants.meetingStatus.IDLE) {
    //   this.locus.sequence = deltaLocus.sequence;
    //   this.locus.syncUrl = deltaLocus.syncUrl;
    // }
  }

  // /**
  //  *
  //  * Move this meeting to a given device
  //  * only possible if you are paired with the given device
  //  * @param {string} deviceID
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // moveToDevice(deviceID) {
  //   return new Promise((resolve) => resolve(deviceID));
  // }

  // /**
  //  *
  //  * Move this meeting back to the current client device, e.g., personal laptop.
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // moveToClient() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Update the audio options of this meeting
  //  * @param {string} status
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // updateAudio(status) {
  //   return new Promise((resolve) => resolve(status));
  // }

  // /**
  //  *
  //  * Update the video option of this meeting
  //  * @param {string} status
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // updateVideo(status) {
  //   return new Promise((resolve) => resolve(status));
  // }

  // /**
  //  *
  //  * Update screen sharing preference of this meeting
  //  * @param {string} shareType
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // updateShare(shareType) {
  //   return new Promise((resolve) => resolve(shareType));
  // }

  /**
   *
   * Alias of updateShare
   * @param {*} args
   * @returns {updateShare}
   * @memberof Meeting
   */
  share() {
    const content = this.locus.mediaShares.find((element) => element.name === 'content');
    this.meetingRequest.changeMeetingFloor({
      disposition: FLOOR_ACTION.GRANTED,
      personUrl: this.locus.self.url,
      deviceUrl: this.deviceUrl,
      uri: content.url,
      resourceUrl: this.resourceUrl
    });
  }

  // /**
  //  *
  //  * Send this meeting to the phone system
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // sendDtmf() {
  //   return new Promise((resolve) => resolve({}));
  // }
  // /**
  //  *
  //  * Get statistics of the current meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // getStats() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Lock this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // lock() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Unlock this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // unlock() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Intiate a recording of this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // startRecording() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * End the recording of this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // stopRecording() {
  //   return new Promise((resolve) => resolve({}));
  // }
}
