import uuid from 'uuid';
import {StatelessSparkPlugin} from '@ciscospark/spark-core';
import StateMachine from 'javascript-state-machine';

import Roap from '../roap/index';
import Media from '../media';
import AudioStateMachine from '../meeting/audio';
import VideoStateMachine from '../meeting/video';
import PeerConnectionManager from '../peer-connection-manager';
import MeetingRequest from '../meeting/request';
import MeetingUtil from '../meeting/util';
import {MEETING_STATE_MACHINE, MEETINGS, EVENT_TRIGGERS, EVENT_TYPES} from '../constants';

/**
 * @export
 * @class Meeting
 */
export default class Meeting extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   * Create an instance of Meeting
   *
   * @param {Object} attrs
   * @param {Object} options
   */
  constructor(attrs, options) {
    super({}, options);

    this.id = uuid.v4();
    this.userId = attrs.userId;
    this.resource = attrs.resource;
    this.sipUri = attrs.sipUri;
    this.deviceUrl = attrs.deviceUrl;
    this.roapSeq = 0;
    this.meetingInfo = attrs.meetingInfo || {};
    this.meetingRequest = new MeetingRequest({}, options);
    this.roap = new Roap({}, options);

    this.state = new StateMachine({
      init: MEETING_STATE_MACHINE.STATES.IDLE,
      transitions: [
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.START,
          from: MEETING_STATE_MACHINE.STATES.IDLE,
          to: MEETING_STATE_MACHINE.STATES.ON_GOING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.START,
          from: MEETING_STATE_MACHINE.STATES.IDLE,
          to: MEETING_STATE_MACHINE.STATES.INCOMING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.JOIN,
          from: MEETING_STATE_MACHINE.STATES.IDLE,
          to: MEETING_STATE_MACHINE.STATES.DIALING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.JOIN,
          from: MEETING_STATE_MACHINE.STATES.ON_GOING,
          to: MEETING_STATE_MACHINE.STATES.DIALING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.JOIN,
          from: MEETING_STATE_MACHINE.STATES.INCOMING,
          to: MEETING_STATE_MACHINE.STATES.DIALING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.LOCAL,
          from: MEETING_STATE_MACHINE.STATES.DIALING,
          to: MEETING_STATE_MACHINE.STATES.CONNECTING_MEDIA_LOCAL
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.CONNECT,
          from: MEETING_STATE_MACHINE.STATES.CONNECTING_MEDIA_LOCAL,
          to: MEETING_STATE_MACHINE.STATES.CONNECTING_MEDIA_REMOTE
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.ESTABLISH,
          from: MEETING_STATE_MACHINE.STATES.CONNECTING_MEDIA_REMOTE,
          to: MEETING_STATE_MACHINE.STATES.ESTABLISHED_MEDIA
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.LEAVE,
          from: MEETING_STATE_MACHINE.STATES.ESTABLISHED_MEDIA,
          to: MEETING_STATE_MACHINE.STATES.TERMINATING
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.END,
          from: MEETING_STATE_MACHINE.STATES.TERMINATING,
          to: MEETING_STATE_MACHINE.STATES.ENDED
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.CLEAN,
          from: MEETING_STATE_MACHINE.STATES.ENDED,
          to: MEETING_STATE_MACHINE.STATES.IDLE
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.CLEAN,
          from: MEETING_STATE_MACHINE.STATES.ERROR,
          to: MEETING_STATE_MACHINE.STATES.IDLE
        },
        {
          name: MEETING_STATE_MACHINE.TRANSITIONS.ERROR,
          from: '*',
          to: MEETING_STATE_MACHINE.STATES.ERROR
        }
      ],
      methods: {
        onInit: (transition) => {
          this.logger.log(
            `Meeting:index#onInit->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onError: (transition) => {
          this.logger.log(
            `Meeting:index#onError->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onClean: (transition) => {
          this.logger.log(
            `Meeting:index#onClean->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onJoin: (transition) => {
          this.logger.log(
            `Meeting:index#onJoin->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onLocal: (transition) => {
          this.logger.log(
            `Meeting:index#onLocal->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onConnect: (transition) => {
          this.logger.log(
            `Meeting:index#onConnect->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        },
        onEstablish: (transition) => {
          this.logger.log(
            `Meeting:index#onEstablish->${transition.event} fired! State changed from '${transition.from}' to '${
              transition.to
            }' with transition '${transition.transition}' on Meeting Object: '${this.id}'.`
          );
        }
      }
    });
  }

  /**
   * Convenience function to tell whether a meeting is muted
   * @returns {Boolean} if meeting audio muted or not
   */
  isAudioMuted() {
    return this.audio.isMuted();
  }

  /**
   * Convenience function to tell if the end user last changed the audio state
   * @returns {Boolean} if audio was manipulated by the end user
   */
  isAudioSelf() {
    return this.audio.isSelf();
  }

  /**
   * Convenience function to tell whether video is muted
   * @returns {Boolean} if meeting video is muted or not
   */
  isVideoMuted() {
    return this.video.isMuted();
  }

  /**
   * Convenience function to tell whether the end user changed the video state
   * @returns {Boolean} if meeting video is muted or not
   */
  isVideoSelf() {
    return this.video.isSelf();
  }

  /**
   * Sets the meeting info on the class instance
   * @param {Object} meetingInfo
   * @returns {null}
   */
  setMeetingInfo(meetingInfo) {
    // MeetingInfo will be undefined for 1:1 calls
    if (meetingInfo) {
      this.convoId = this.meetingInfo.convoId;
      this.locusUrl = this.meetingInfo.locusUrl;
      this.sipUri = this.meetingInfo.sipMeetingUri;
    }
  }

  /**
   * Set the roap seq on the class instance
   * @param {Number} seq
   * @returns {null}
   */
  setRoapSeq(seq) {
    if (seq) {
      this.roapSeq = seq;
    }
  }

  /**
   * Set the locus info the class instance
   * @param {Object} locus
   * @returns {null}
   */
  setLocusJoin(locus) {
    this.locus = locus.locus;
    this.mediaConnections = locus.mediaConnections;
    this.locusUrl = locus.locusUrl;
    this.locusId = locus.locusId;
    this.selfId = locus.selfId;
    this.mediaId = locus.mediaId;
  }

  /**
   * Sets the remote stream on the class instance and emits and
   * event do developers
   * @param {Object} pc The remote stream peer connection
   * @returns {null}
   */
  setRemoteStream(pc) {
    // eslint-disable-next-line no-param-reassign
    pc.ontrack = (event) => {
      [this.remoteStream] = event.streams;

      // eslint-disable-next-line no-warning-comments
      // TODO: It's possible for media to not be present
      // so we might need to either
      // A) wait until we have media flowing
      // B) trigger a second event when video is flowing
      this.trigger(EVENT_TRIGGERS['MEDIA:READY'], {
        type: EVENT_TYPES.REMOTE,
        stream: this.remoteStream
      });
    };
  }

  /**
   * Removes the remote stream on the class instance and triggers an event
   * to developers
   * @returns {null}
   */
  unsetRemoteStream() {
    return Media.stopStream(this.remoteStream).then(() => {
      this.remoteStream = null;

      this.trigger(EVENT_TRIGGERS['MEDIA:STOPPED'], {
        type: 'remote'
      });
    });
  }

  /**
   * Sets the sceen stream on the class instance and triggers and event to developers
   * @param {Object} pc a peer connection instance for the screen
   * @returns {null}
   */
  setScreenStream(pc) {
    // eslint-disable-next-line no-param-reassign
    pc.ontrack = (event) => {
      [this.screenStream] = event.streams;

      this.trigger(EVENT_TRIGGERS['MEDIA:READY'], {
        type: EVENT_TYPES.SCREEN,
        stream: this.screenStream
      });
    };
  }

  /**
   * Sets the local media stream on the class and emits an event to the developer
   * @param {Steam} stream the local media stream
   * @returns {null}
   */
  setLocalStream(stream) {
    [this.localStream] = stream;

    this.trigger(EVENT_TRIGGERS['MEDIA:READY'], {
      type: EVENT_TYPES.LOCAL,
      stream: this.localStream
    });
  }

  /**
   * Removes the local stream from the class and emits an event to the developer
   * @returns {null}
   */
  unsetLocalStream() {
    return Media.stopStream(this.localStream).then(() => {
      this.localStream = null;

      this.trigger(EVENT_TRIGGERS['MEDIA:STOPPED'], {
        type: 'local'
      });
    });
  }

  /**
   * Sets the peer connections on the class
   * @param {PeerConnection} mediaPeerConnection
   * @param {PeerConnection} screenPeerConnection
   * @returns {null}
   */
  setPeerConnections(mediaPeerConnection, screenPeerConnection) {
    this.mediaPeerConnection = mediaPeerConnection;
    this.screenPeerConnection = screenPeerConnection;
  }

  /**
   * Close the peer connections and remove them from the class. Triggers an event
   * when each is closed.
   * @returns {Promise} returns a resolved promise with an array of closed peer connections
   */
  unsetPeerConnections() {
    return Promise.all([
      PeerConnectionManager.close(this.mediaPeerConnection).then(() => {
        this.trigger(EVENT_TRIGGERS['PEERCONNECTION:CLOSED'], {
          type: 'media'
        });

        this.mediaPeerConnection = null;
      }),

      PeerConnectionManager.close(this.screenPeerConnection).then(() => {
        this.trigger(EVENT_TRIGGERS['PEERCONNECTION:CLOSED'], {
          type: 'screen'
        });

        this.screenPeerConnection = null;
      })
    ]);
  }

  /**
   * Convenience method to set the correlation id for the Meeting
   * @param {String} id correlation id to set on the class
   * @returns {null}
   */
  setCorrelationId(id) {
    this.correlationId = id;
  }

  /**
   * Mute the audio for a meeting
   * @returns {Promise} resolves the data from muting audio {mute, self}
   * @returns {Error} an error if there is no audio state machine
   */
  muteAudio() {
    if (!this.audio || (this.audio && !this.audio.toggle)) {
      return Promise.reject(new Error('no audio control associated to the meeting'));
    }

    return this.audio.toggle(
      {
        mute: true,
        self: true
      },
      this
    );
  }

  /**
   * Unmute meeting audio
   * @returns {Promise} resolves data from muting audio {mute, self}
   * @returns {Error} an error if there is no audio state machine
   */
  unmuteAudio() {
    if (!this.audio || (this.audio && !this.audio.toggle)) {
      return Promise.reject(new Error('no audio control associated to the meeting'));
    }
    return this.audio.toggle(
      {
        mute: false,
        self: true
      },
      this
    );
  }

  /**
   * Mute the video for a meeting
   * @returns {Promise} resolves data from muting video {mute, self}
   * @returns {Error} an error if there is no video state machine
   */
  muteVideo() {
    if (!this.video || (this.video && !this.video.toggle)) {
      return Promise.reject(new Error('no video control associated to the meeting'));
    }
    return this.video.toggle(
      {
        mute: true,
        self: true
      },
      this
    );
  }

  /**
   * Unmute meeting video
   * @returns {Promise} resolves data from muting video {mute, self}
   * @returns {Error} an error if there is no video state machine
   */
  unmuteVideo() {
    if (!this.video || (this.video && !this.video.toggle)) {
      return Promise.reject(new Error('no audio control associated to the meeting'));
    }
    const options = {};
    options.mute = false;
    options.self = true;
    return this.video.toggle(
      {
        mute: false,
        self: true
      },
      this
    );
  }

  /**
   *
   * Specify joining via audio (option: pstn), video, screenshare
   * @exports
   * @param {object} options A configurable options object for joining a meeting
   * @param {Object } options.mediaSettings overrides for the default media direction
   * @returns {Promise}
   * @memberof Meeting
   */
  join({mediaSettings}) {
    const mediaDirection = Object.assign(
      {
        sendAudio: true,
        sendVideo: true,
        receiveAudio: true,
        receiveVideo: true,
        pstn: false,
        sendShare: false,
        receiveShare: false
      },
      mediaSettings
    );

    this.audio = AudioStateMachine.create(mediaDirection);
    this.video = VideoStateMachine.create(mediaDirection);
    this.setCorrelationId(this.id);

    this.state.join();
    return MeetingUtil.joinMeeting(this)
      .then((response) => {
        this.setLocusJoin(response);
        this.state.local();
        return Media.getLocalMedia({
          sendAudio: mediaDirection.sendAudio,
          sendVideo: mediaDirection.sendVideo,
          sendShare: mediaDirection.sendShare
        });
      })
      .catch((err) => {
        this.logger.log('Meeting:index#join --> Error joining the call on getLocalMedia, ', err);
        throw err;
      })
      .then((streams) => {
        this.state.connect();
        this.setLocalStream(streams);
        return Media.addMedia(mediaDirection, PeerConnectionManager, streams);
      })
      .catch((err) => {
        this.logger.log('Meeting:index#join --> Error joining the call on addMedia, ', err);
        throw err;
      })
      .then(([mediaPeerConnection, screenPeerConnection]) => {
        const updatedScreenPeerConnection = PeerConnectionManager.setContentSlides(screenPeerConnection);
        this.setPeerConnections(mediaPeerConnection, updatedScreenPeerConnection);
        this.setRemoteStream(this.mediaPeerConnection);
        this.setScreenStream(this.screenPeerConnection);
        return this.roap.start();
      })
      .catch((err) => {
        this.logger.log('Meeting:index#join --> Error joining the call on roap initialization, ', err);
        throw err;
      })
      .then(() =>
        this.roap
          .sendRoapMediaRequest({
            sdps: [this.mediaPeerConnection.sdp, this.screenPeerConnection.sdp],
            roapSeq: this.roapSeq,
            meeting: this // or can pass meeting ID
          })
          .catch((err) => {
            this.logger.error('Meeting:index#join --> Error joining the call on send roap media request, ', err);
            throw err;
          }))
      .then(() => {
        this.state.establish();
      });
  }

  /**
   *
   * Leave the current meeting
   * @param {Object} options An object of options
   * @param {Boolean} options.keepLocalMedia Whether to tear down the local media connections or not.
   * @returns {Promise}
   * @memberof Meeting
   */
  leave() {
    return this.meetingRequest
      .leaveMeeting({
        locusUrl: this.locusUrl,
        selfId: this.selfId,
        correlationId: this.correlationId,
        resourceId: null,
        deviceUrl: this.deviceUrl
      })
      .then(() => {
        this.unsetLocalStream();
        this.unsetRemoteStream();
        this.unsetPeerConnections();
      })
      .then(() => {
        this.logger.log('this.roapSeq', this.roapSeq);
        this.roap.stop(this.correlationId, this.roapSeq);
      })
      .catch((err) => {
        this.logger.error(`An error occured while trying to leave meeting with an id of ${this.id}`, err);
      });
  }

  // /**
  //  *
  //  * Move this meeting to a given device
  //  * only possible if you are paired with the given device
  //  * @param {string} deviceID
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // moveToDevice(deviceID) {
  //   return new Promise((resolve) => resolve(deviceID));
  // }

  // /**
  //  *
  //  * Move this meeting back to the current client device, e.g., personal laptop.
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // moveToClient() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Update the audio options of this meeting
  //  * @param {string} status
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // updateAudio(status) {
  //   return new Promise((resolve) => resolve(status));
  // }

  // /**
  //  *
  //  * Update the video option of this meeting
  //  * @param {string} status
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // updateVideo(status) {
  //   return new Promise((resolve) => resolve(status));
  // }

  // /**
  //  *
  //  * Update screen sharing preference of this meeting
  //  * @param {string} shareType
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // updateShare(shareType) {
  //   return new Promise((resolve) => resolve(shareType));
  // }

  // /**
  //  *
  //  * Alias of updateShare
  //  * @param {*} args
  //  * @returns {updateShare}
  //  * @memberof Meeting
  //  */
  // share(...args) {
  //   this.updateShare(args);
  // }

  // /**
  //  *
  //  * Decline this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // decline() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Send this meeting to the phone system
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // sendDtmf() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Get statistics of the current meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // getStats() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Lock this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // lock() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Unlock this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // unlock() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Intiate a recording of this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // startRecording() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * End the recording of this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // stopRecording() {
  //   return new Promise((resolve) => resolve({}));
  // }
}
