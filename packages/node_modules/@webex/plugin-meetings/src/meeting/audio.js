import StateMachine from 'javascript-state-machine';
import StateMachineHistory from 'javascript-state-machine/lib/history';

import Media from '../media';
import MeetingUtil from '../meeting/util';
import {MEETING_AUDIO_STATE_MACHINE, EVENT_TRIGGERS, EVENT_TYPES} from '../constants';

const handleTransition = (value, audio, meeting) => {
  if (audio.mute && audio.self) {
    value = MEETING_AUDIO_STATE_MACHINE.STATES.MUTE_SELF;
  }
  if (!audio.mute && audio.self) {
    value = MEETING_AUDIO_STATE_MACHINE.STATES.UNMUTE_SELF;
  }
  return value;
};

const AudioStateMachine = {
  create() {
    return new StateMachine({
      transitions: [
        {
          name: MEETING_AUDIO_STATE_MACHINE.TRANSITIONS.INIT,
          from: '*',
          to: function (audio, meeting) {
            return handleTransition(this.state, audio, meeting);
          }
        },
        {
          name: MEETING_AUDIO_STATE_MACHINE.TRANSITIONS.TOGGLE,
          from: '*',
          to: function (audio, meeting) {
            return handleTransition(this.state, audio, meeting);
          }
        }
      ],
      data: {
        muted: undefined,
        self: undefined
      },
      methods: {
        getMuted() {
          return this.muted;
        },
        getSelf() {
          return this.self;
        },
        onAfterInit(transition, audio, meeting) {
          this.muted = audio.mute;
          this.self = audio.self;
          meeting.trigger(EVENT_TRIGGERS.MEDIA_AUDIO, {
            type: EVENT_TYPES.local,
            status: this.state,
            muted: this.muted,
            from: MEETING_AUDIO_STATE_MACHINE.TRANSITIONS.INIT
          });
          console.log(`roap:state#onAfterToggle->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}''.`);
        },
        onAfterHistoryBack(transition, meeting, error) {
          meeting.trigger(EVENT_TRIGGERS.MEDIA_AUDIO, {
            type: EVENT_TYPES.ERROR,
            status: this.state,
            muted: this.muted,
            from: MEETING_AUDIO_STATE_MACHINE.TRANSITIONS.TOGGLE,
            error
          });
          console.log(`roap:state#onAfterToggle->${transition.event} fired! State failed to change with transition '${transition.transition}''. State has been reset to ${this.history[this.history.length - 1]} and toggling has been reversed.`);
        },
        onAfterToggle(transition, audio, meeting) {
          if (audio.self) {
            this.self = true;
          }
          if (transition.from !== transition.to) {
            MeetingUtil.remoteUpdateAudioVideo(audio, {mute: meeting.video.muted}, meeting)
              .then((resolution) => {
                Media.localTracks(audio, {mute: meeting.video.muted}, meeting.localMediaStream);
                this.muted = audio.mute;
                meeting.trigger(EVENT_TRIGGERS.MEDIA_AUDIO, {
                  type: EVENT_TYPES.local,
                  status: this.state,
                  muted: this.muted,
                  from: MEETING_AUDIO_STATE_MACHINE.TRANSITIONS.TOGGLE,
                  resolution
                });
                console.log(`roap:state#onAfterToggle->${transition.event} fired! State changed from '${transition.from}' to '${transition.to}' with transition '${transition.transition}''.`);
              }).catch((err) => {
                this.historyBack(meeting, err);
              });
          }
        },
        plugins: [
          new StateMachineHistory({max: 2})
        ]
      }
    });
  }
};

export default AudioStateMachine;
