import PeerConnectionManager from '../peer-connection-manager';
import {
  _ANSWER_,
  _ERROR_,
  _CONFLICT_,
  ROAP,
  SDP,
  _IN_
} from '../constants';

const RoapUtil = {};
const ROAP_ANSWER = _ANSWER_.toLowerCase();

RoapUtil.shouldHandleMedia = (meeting) => {
  const mediaOffer
    = meeting.mediaProperties.mediaPeerConnection
    && meeting.mediaProperties.mediaPeerConnection.signalingState === SDP.HAVE_LOCAL_OFFER;
  const screenOffer
    = meeting.mediaProperties.sharePeerConnection
    && meeting.mediaProperties.sharePeerConnection.signalingState === SDP.HAVE_LOCAL_OFFER;
  if (mediaOffer || screenOffer) {
    return false;
  }
  return true;
};

RoapUtil.handleError = (pc) =>
  PeerConnectionManager.rollBackLocalDescription({mediaPeerConnection: pc})
    .then(() => Promise.resolve(true))
    .catch((err) => Promise.reject(err));

RoapUtil.findError = (messageType, errorType, type) =>
  (type === ROAP.RECEIVE_ROAP_MSG || type === ROAP.SEND_ROAP_MSG) && messageType === _ERROR_ && errorType === _CONFLICT_;

RoapUtil.ensureMeeting = (meeting, type) => {
  if (type === ROAP.RECEIVE_ROAP_MSG || type === ROAP.SEND_ROAP_MSG || type === ROAP.SEND_ROAP_MSG_SUCCESS) {
    if (!meeting) {
      return false;
    }
  }
  return true;
};

RoapUtil.compareLastRemoteOffer = (currentOffer, previousOffer) => {
  let index1, index2;
  let difference = false;

  if (previousOffer.length > 0 && previousOffer.length === currentOffer.length) {
    previousOffer.forEach((sdp, index) => {
      index1 = sdp.indexOf(_IN_);
      index2 = currentOffer[index].indexOf(_IN_);

      if (sdp.substring(index1) !== currentOffer[index].substring(index2)) {
        difference = true;
      }
    });
  }
  return difference;
};

RoapUtil.updatePeerConnection = (meeting, session) => {
  const res = RoapUtil.compareLastRemoteOffer(session.OFFER.sdps, meeting.roap.lastRoapOffer);
  if (!res) {
    const sdpPromises = [];
    if (meeting.mediaProperties.mediaPeerConnection) {
      sdpPromises.push(meeting.mediaProperties.mediaPeerConnection.sdp);
    }
    if (meeting.mediaProperties.sharePeerConnection) {
      sdpPromises.push(meeting.mediaProperties.sharePeerConnection.sdp);
    }
    return Promise.resolve(sdpPromises);
  }
  return PeerConnectionManager.updatePeerConnection({
    offerSdp: session.OFFER.sdps,
    pc: meeting.mediaProperties.mediaPeerConnection,
    sharePeerConnection: meeting.mediaProperties.sharePeerConnection,
    offerToReceiveAudio: true,
    offerToReceiveVideo: true
  })
    .then((res) => {
      meeting.roap.lastRoapOffer = session.OFFER.sdps;
      return res;
    });
};


RoapUtil.setRemoteDescription = (meeting, session) => {
  if (!(meeting && (meeting.mediaProperties.mediaPeerConnection || meeting.mediaProperties.sharePeerConnection))) {
    return Promise.reject(new Error('Must provide a media or screen peer connection'));
  }
  let promise;
  if (meeting.mediaProperties.mediaPeerConnection && meeting.mediaProperties.sharePeerConnection) {
    promise = Promise.all([
      PeerConnectionManager.setRemoteSessionDetails(
        meeting.mediaProperties.mediaPeerConnection,
        ROAP_ANSWER,
        session.ANSWER.sdps[0],
        meeting.clientIdentifiers
      ),
      PeerConnectionManager.setRemoteSessionDetails(
        meeting.mediaProperties.sharePeerConnection,
        ROAP_ANSWER,
        session.ANSWER.sdps[1],
        meeting.clientIdentifiers
      )
    ]);
  }
  else if (meeting.mediaProperties.sharePeerConnection) {
    promise = PeerConnectionManager.setRemoteSessionDetails(
      meeting.mediaProperties.sharePeerConnection,
      ROAP_ANSWER,
      session.ANSWER.sdps[0],
      meeting.clientIdentifiers
    );
  }
  return promise
    .then(() => ({
      seq: session.ANSWER.seq,
      locusId: meeting.locusId,
      locusSelfId: meeting.locusInfo.self.id,
      mediaId: meeting.mediaId,
      correlationId: meeting.correlationId
    }))
    .catch((err) => {
      throw err;
    });
};

export default RoapUtil;
