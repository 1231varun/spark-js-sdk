import {Readable} from 'stream';
import {EventEmitter} from 'events';

import {safeSetTimeout} from '@ciscospark/common-timers';

import {ERROR, DATA, CLOSED, DEFAULT_STATS_INTERVAL} from '../constants';

const pcsByRTCRtpDirection = new WeakMap();
const emittersByRTCRtpDirection = new WeakMap();
const RTCRtpDirectionByEmitter = new WeakMap();
const emittersByStream = new WeakMap();
const timersByEmitter = new WeakMap();

/**
 * Helper function that ensures no matter how many stats streams we create, we
 * don't poll the PeerConnection more than once per interval.
 * @param {EventEmitter} emitter
 * @private
 * @returns {undefined}
 */
const schedule = (emitter) => {
  const timer = safeSetTimeout(() => {
    const direction = RTCRtpDirectionByEmitter.get(emitter);
    const pc = pcsByRTCRtpDirection.get(direction);

    if (direction) {
      direction.getStats()
        .then((stats) => {
          emitter.emit(DATA, stats);
          // TODO: Remove on 1.0 spec adoption
          // "closed" is supposed to be part of the {@link RTCPeerConnectionState}
          // enum according to spec, but at time of writing, was still implemented
          // in the {@link RTCSignalingState} enum.
          if (!(pc.signalingState === CLOSED || pc.connectionState === CLOSED)) {
            schedule(emitter);
          }
        })
        .catch((err) => {
          emitter.emit(ERROR, err);
        });
    }
  }, DEFAULT_STATS_INTERVAL);

  timersByEmitter.set(emitter, timer);
};

/**
 * Polls an {@link RTCPeerConnection} once per second and emits its {@link RTCStatsReport}
 * {@link RTCStatsReport}
 */
export default class StatsStream extends Readable {
  /**
   * @private
   * @param {RTCRtpSender|RTCRtpReceiver} rTCRtpDirection
   * @param {RTCPeerConnection} peerConnection
   */
  constructor(rTCRtpDirection, peerConnection) {
    super({objectMode: true});

    if (!emittersByRTCRtpDirection.has(rTCRtpDirection)) {
      emittersByRTCRtpDirection.set(rTCRtpDirection, new EventEmitter());
    }
    const emitter = emittersByRTCRtpDirection.get(rTCRtpDirection);

    if (!emittersByStream.has(this)) {
      emittersByStream.set(this, emitter);
    }
    if (!RTCRtpDirectionByEmitter.has(emitter)) {
      RTCRtpDirectionByEmitter.set(emitter, rTCRtpDirection);
    }

    if (!pcsByRTCRtpDirection.has(rTCRtpDirection)) {
      pcsByRTCRtpDirection.set(rTCRtpDirection, peerConnection);
    }

    emitter.once(ERROR, (err) => {
      this.emit(ERROR, err);
    });
  }

  /**
   * See NodeJS Docs
   * @private
   * @returns {undefined}
   */
  _read() {
    const emitter = emittersByStream.get(this);

    emitter.once(DATA, (data) => {
      if (!this.isPaused()) {
        this.push(data);
      }
    });

    if (!timersByEmitter.has(emitter)) {
      schedule(emitter);
    }
  }
}

