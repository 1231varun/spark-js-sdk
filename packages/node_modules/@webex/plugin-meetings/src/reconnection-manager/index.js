/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */

import {ACTIVE, RECONNECTION} from '../constants';
import ReconnectionError from '../errors/reconnection';
import PeerConnectionManager from '../peer-connection-manager';

const ReconnectionManager = {};

ReconnectionManager.status = RECONNECTION.STATE.DEFAULT_STATUS;
ReconnectionManager.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;

ReconnectionManager.configure = (meeting) => {
  ReconnectionManager.backOff = meeting.config.reconnection.retry.backOff.start;
};

ReconnectionManager.reset = () => {
  ReconnectionManager.status = RECONNECTION.STATE.DEFAULT_STATUS;
  ReconnectionManager.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;
};

ReconnectionManager.validate = (meeting) => {
  if (meeting.config.reconnection.enabled) {
    if (
      meeting.locusInfo
        && meeting.locusInfo.fullState
        && (
          meeting.locusInfo.fullState.state === ACTIVE
          && meeting.locusInfo.fullState.active
        )
    ) {
      if (meeting.spark.internal.mercury.connected) {
        if (
          ReconnectionManager.status !== RECONNECTION.STATE.DEFAULT_STATUS
          || ReconnectionManager.status !== RECONNECTION.STATE.COMPLETE
        ) {
          return true;
        }
        return new ReconnectionError(new Error('Multiple reconnections cannot occur concurrently'));
      }
      return new ReconnectionError(new Error('mercury is not connected, cannot reconnect'));
    }
    return new ReconnectionError(new Error('locus server for this call is not active, cannot reconnect'));
  }
  return new ReconnectionError(new Error('Reconnection is not enabled.'));
};

ReconnectionManager.reconnect = (meeting) => {
  ReconnectionManager.configure(meeting);
  const validatedReconnect = ReconnectionManager.validate(meeting);
  return validatedReconnect === true ? ReconnectionManager.execute(meeting) : Promise.reject(validatedReconnect);
};

ReconnectionManager.execute = (meeting) => {
  ReconnectionManager.status = RECONNECTION.STATE.IN_PROGRESS;
  return ReconnectionManager.media(meeting)
    .then((media) => {
      console.info(`Reconnection->Media reestablished at: ${new Date()}`);
      ReconnectionManager.status = RECONNECTION.STATE.COMPLETE;
      return Promise.resolve(media);
    })
    .catch((err) => { // eslint-disable-line
      console.info(`Reconnection->Media reestablishment failed at: ${new Date()}`);
      if (ReconnectionManager.tryCount > meeting.config.reconnection.retry.times) {
        ReconnectionManager.status = RECONNECTION.STATE.FAILURE;
        return Promise.reject(new ReconnectionError(err));
      }
      // exponential backoff and retry logic
      setTimeout(() =>
        ReconnectionManager.reconnect(meeting),
      ReconnectionManager.backOff *= meeting.config.reconnection.retry.backOff.rate);
    });
};

ReconnectionManager.media = (meeting) => {
  ReconnectionManager.tryCount += 1;
  console.info(`Reconnection->Re-establishing media at: ${new Date()}`);
  // create an offer
  return meeting.addMedia({
    mediaSettings: meeting.mediaDirection
  }).then((media) => Promise.resolve(media))
    .catch((err) => {
      console.error('Could not re use peer connections for the media.', err);
      // TODO: test getting to this scenario
      ReconnectionManager.cleanup(meeting);
      return meeting.addMedia({
        mediaSettings: meeting.mediaDirection,
        localStream: meeting.localStream,
        localShare: meeting.localShare
      });
    });
};

ReconnectionManager.cleanup = (meeting) => {
  // close pcs, unset to null and reuse the streams with new pcs
  PeerConnectionManager.close(meeting.mediaPeerConnection);
  PeerConnectionManager.close(meeting.sharePeerConnection);
  meeting.unsetPeerConnections();
};

export default ReconnectionManager;
