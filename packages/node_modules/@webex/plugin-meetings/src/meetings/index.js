/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */
import '@ciscospark/internal-plugin-mercury';

import {SparkPlugin} from '@ciscospark/spark-core';

import {MEETINGS, EVENT_TRIGGERS} from '../constants';
import MeetingInfo from '../meeting-info';
import Meeting from '../meeting';
import PersonalMeetingRoom from '../personal-meeting-room';
import LocusEvents from '../locus-events';

import MeetingCollection from './collection';
import MeetingsUtil from './util';

/**
 * Maintain a cache of meetings and sync with services.
 * Developers should not have to worry about syncing.
 *
 * Events to emit
 * ==============
 *
 * - create
 * - ready
 * - statusChange: {
 *   connection (string): connecting | connected | disconnecting | disconnected
 *   // NOTE: /calls API had: initializing |lobby | connected | terminating | disconnected
 * }
 * @class
 */
export default class Meetings extends SparkPlugin {
  namespace = MEETINGS;

  /**
   * Initializes the Meetings Plugin
   *
   * @returns {null}
   * @memberof Meetings
   */
  constructor(...args) {
    super(...args);
    this.meetingInfo = new MeetingInfo({}, {parent: this.spark});
    this.personalMeetingRoom = new PersonalMeetingRoom({}, {parent: this.spark});
    this.locusEvents = new LocusEvents({}, {parent: this.spark}).start();
  }

  /**
   * gets the personal meeting room instance, for saved PMR values for this user
   * @returns {PersonalMeetingRoom}
   */
  getPersonalMeetingRoom() {
    return this.personalMeetingRoom;
  }

  /**
   * Create a meeting.
   * @param {string} destination - sipURL, spaceId, phonenumber, meeting link, or locus object}
   * @param {string} type - the optional specified type, such as locusId
   * @returns {Promise} A new Meeting.
   */
  create(destination, type = null) {
    return this.meetingInfo
      .fetchMeetingInfo(MeetingsUtil.extractDestination(destination, type), type)
      .then((info) => info)
      .catch((err) => {
        console.error(err); // TODO:
        return err;
      })
      .then((info) => this.createMeeting(info, destination, type))
      .catch((err) => {
        console.error(err); // TODO:
        return err;
      });
  }

  /**
   * @param {String} info see create()
   * @param {String} destination see create()
   * @param {String} type see create()
   * @returns {Meeting} a new meeting instance complete with meeting info and destination
   */
  createMeeting(info, destination, type = null) {
    const mtgInfo = info ? info.body : null;
    const meeting = new Meeting(
      {
        userId: this.spark.internal.device.userId,
        deviceUrl: this.spark.internal.device.url,
        roapSeq: 0,
        meetingInfo: mtgInfo || {}
      },
      {
        parent: this.spark
      }
    );
    MeetingsUtil.setUpMeeting(meeting, mtgInfo, destination, type);
    this.trigger(EVENT_TRIGGERS.MEETING_ADDED, {
      meeting,
      type: MeetingsUtil.getMeetingAddedType(type)
    });
    return MeetingCollection.set(meeting);
    // Create the meeting calling the necessary service endpoints.

    // Internally, there are many more destinations:
    //
    // - locusID
    // - meetingURL
    // - globalMeetingID, e.g, *00*meetingID
    // - meetingID
    // - meetingURL
    // - PSTN
    // - phone number
    //
    // Our job is to determine the appropriate one
    // and its corresponding service so that developers
    // need only sipURL or spaceID to get a meeting
    // and its ID, but have the option to use createWithType()
    // and specify those types to get meetingInfo
  }

  /**
   * get a specifc meeting given it's type matched to the value, i.e., locus url
   * @param {String} type
   * @param {Object} value
   * @returns {Meeting}
   * @memberof Meetings
   */
  static getMeetingByType(type, value) {
    return MeetingCollection.getByKey(type, value);
  }

  /**
   * Get all meetings.
   * @param {object} options
   * @param {object} options.startDate - get meetings after this start date
   * @param {object} options.endDate - get meetings before this end date
   * @returns {Object} All active and scheduled meetings.
   * @memberof Meetings
   */
  static getAll() {
    // Options may include other parameters to filter this collection
    // of meetings.
    return MeetingCollection.getAll({});
  }

  /**
   * Get all active meetings.
   * @returns {Object} All active meetings.
   * @memberof Meetings
   */
  static getActiveMeetings() {
    return MeetingCollection.getAll({active: true});
  }

  /**
   * Get all scheduled meetings.
   * @param {object} options
   * @param {object} options.startDate - get meetings after this start date
   * @param {object} options.endDate - get meetings before this end date
   * @returns {Object} All scheduled meetings.
   * @memberof Meetings
   */
  static getScheduledMeetings() {
    return MeetingCollection.getAll({scheduled: true});
  }
}
