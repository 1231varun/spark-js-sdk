import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import {MEETINGS, PERSONAL_ROOM} from '../constants';
import MeetingInfoRequest from '../meeting-info/request';

/**
 * @class PersonalMeetingRoom
 */
export default class PersonalMeetingRoom extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   */
  constructor(attrs, options) {
    super({}, options);
    this.pmr = undefined;
    this.sipUri = undefined;
    this.link = undefined;
    this.userId = undefined;
    this.name = undefined;
    this.MeetingInfoRequest = new MeetingInfoRequest({}, options);
  }

  /**
   * @param {Object} body the response body from meeting info request
   * @returns {undefined}
   * @memberof PersonalMeetingRoom
   */
  setPersonalMeetingRoom(body) {
    this.pmr = body;
    this.sipUri = body.sipMeetingUri;
    this.meetingLink = body.webExMeetingLink;
    this.userId = body.owner;
    this.name = body.meetingName;
    this.number = body.meetingNumber;
  }

  /**
   * TODO: implement TTL for syncing and caching so to not request again and again
   * @param {Object} options
   * @returns {Promise}
   * @memberof PersonalMeetingRoom
   */
  getPersonalMeetingRoom() {
    const options = {
      type: PERSONAL_ROOM,
      destination: this.spark.internal.device.userId
    };
    return this.MeetingInfoRequest.fetchMeetingInfo(options).then((pmr) => {
      if (pmr.body && pmr.body.isPmr) {
        this.setPersonalMeetingRoom(pmr.body);
      }
      else {
        return Promise.reject(new Error('The PMR requested is NOT a PMR'));
      }
      return pmr;
    });
  }
}
