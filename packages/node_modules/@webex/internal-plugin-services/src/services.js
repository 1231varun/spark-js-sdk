import Url from 'url';

import {base64} from '@webex/common';
import {WebexPlugin} from '@webex/webex-core';

import ServiceUrl from './service-url';

/* eslint-disable no-underscore-dangle */
/**
 * @class
 */
const Services = WebexPlugin.extend({
  namespace: 'Services',

  status: {
    ready: false
  },

  _serviceUrls: [],
  _serviceUrlsLimited: [],
  _serviceUrlsDiscovery: [
    new ServiceUrl({
      name: 'u2c',
      defaultUrl: process.env.U2C_SERVICE_URL ||
        'https://u2c.wbx2.com/u2c/api/v1',
      hosts: []
    })
  ],

  /**
   * **Internal**
   * Creates an object where the keys are the service
   * names and the values are the service urls.
   * @param {boolean} [priorityHost]
   * @param {string} [serviceGroup]
   * @returns {object}
   */
  _generateServicesList(priorityHost, serviceGroup = '') {
    const output = {};

    this[`_serviceUrls${serviceGroup}`].forEach((serviceUrl) => {
      output[serviceUrl.name] = serviceUrl.get(priorityHost);
    });

    return output;
  },

  /**
   * Generate a service catalog in the shape of an object.
   * @param {boolean} [priorityHost]
   * @param {string} [serviceGroup]
   * @returns {object}
   */
  services(priorityHost, serviceGroup) {
    if (serviceGroup) {
      return this._generateServicesList(priorityHost, serviceGroup);
    }

    return {
      ...this._generateServicesList(priorityHost, 'Discovery'),
      ...this._generateServicesList(priorityHost, 'Limited'),
      ...this._generateServicesList(priorityHost)
    };
  },

  /**
   * **Internal**
   * Search the service url array to locate a `ServiceUrl`
   * class object based on its name.
   * @param {string} name
   * @param {string} [serviceGroup]
   * @returns {ServiceUrl}
   */
  _getUrl(name, serviceGroup = '') {
    return this[`_serviceUrls${serviceGroup}`].find(
      (serviceUrl) => serviceUrl.name === name
    );
  },

  /**
   * Get a service url from the current services list by name.
   * @param {string} name
   * @param {boolean} priorityHost
   * @param {string} serviceGroup
   * @returns {string|undefined}
   */
  get(name, priorityHost, serviceGroup) {
    let serviceUrl;

    if (serviceGroup) {
      serviceUrl = this._getUrl(name, serviceGroup);
    }
    else {
      serviceUrl = this._getUrl(name) ||
        this._getUrl(name, 'Limited') ||
        this._getUrl(name, 'Discovery');
    }

    return (serviceUrl) ? serviceUrl.get(priorityHost) : undefined;
  },

  /**
   * Update a list of `serviceUrls` to the most current
   * catalog via the defined `discoveryUrl` then returns the current
   * list of services.
   * @param {string} by This accepts `email`, `orgId` or `userId`
   * @param {string} value This accepts an email, orgId, or userId
   * @returns {Promise<Array<string>>}
   */
  updateServices(by, value) {
    const params = [];

    if (by && value) {
      params.push(
        true,
        `${by}=${(by === 'email') ? base64.encode(value) : value}`
      );
    }

    const limited = params.length > 0;

    return this._fetchNewServiceHostmap(...params)
      .then((serviceHostMap) => {
        this._updateServiceUrls(
          serviceHostMap,
          limited ? 'Limited' : undefined
        );

        this.trigger('servicesUpdated');

        return Promise.resolve({
          ...this.services(false, (limited) ? 'Limited' : undefined)
        });
      });
  },

  /**
   * Wait until this plugin is ready
   * @returns {Promise<void>}
   */
  waitUntilReady() {
    return new Promise((resolve) => {
      if (this.status.ready) {
        resolve();
      }

      this.once('ready', () => resolve());
    });
  },

  /**
   * **Internal**
   * Safely load one or more `ServiceUrl`s into this `Services` instance.
   * @param {string} serviceGroup
   * @param  {Array<ServiceUrl>} services
   * @returns {Services}
   */
  _loadServiceUrls(serviceGroup, ...services) {
    services.forEach((service) => {
      // Validate a service was found in the service catalog.
      // and that service is an instance of `ServiceUrl`
      if (service instanceof ServiceUrl &&
        !this[`_serviceUrls${serviceGroup}`].includes(service)) {
        this[`_serviceUrls${serviceGroup}`].push(service);
      }
    });

    return this;
  },

  /**
   * **Internal**
   * Safely unload one or more `ServiceUrl`s into this `Services` instance
   * @param {string} serviceGroup
   * @param  {Array<ServiceUrl>} services
   * @returns {Services}
   */
  _unloadServiceUrls(serviceGroup, ...services) {
    let s;

    services.forEach((service) => {
      s = service;

      // Confirm that the service param is a string or object.
      if (typeof service === 'string') {
        s = this._getUrl(s, serviceGroup);
      }

      // Validate a service was found in the service catalog.
      if (s && this[`_serviceUrls${serviceGroup}`].includes(service)) {
        this[`_serviceUrls${serviceGroup}`]
          .splice(this[`_serviceUrls${serviceGroup}`].indexOf(s), 1);
      }
    });

    return this;
  },

  /**
   * **Internal**
   * Update the current list of `ServiceUrl`s against a provided
   * service hostmap.
   * @param {object} serviceHostmap
   * @param {string} [catalog]
   * @returns {Services}
   */
  _updateServiceUrls(serviceHostmap, catalog = '') {
    const targetUrls = this[`_serviceUrls${catalog}`];

    // Clean up current service urls.
    targetUrls.forEach((serviceUrl) => {
      const service = serviceHostmap.find(
        (item) => item.name === serviceUrl.name
      );

      if (!service) { this._unloadServiceUrls(catalog, serviceUrl); }
    });

    serviceHostmap.forEach((serviceObj) => {
      const service = this._getUrl(serviceObj.name, catalog);

      if (service) {
        service.defaultUrl = serviceObj.defaultUrl;
        service.hosts = serviceObj.hosts;
      }
      else {
        this._loadServiceUrls(catalog, new ServiceUrl({
          ...serviceObj
        }));
      }
    });

    return this;
  },

  /**
   *  **Internal**
   * Organize a received hostmap from a service
   * catalog endpoint.
   * @param {object} serviceHostmap
   * @returns {object}
   */
  _formatReceivedHostmap(serviceHostmap) {
    const output = [];
    let item = {};

    Object.keys(serviceHostmap.serviceLinks).forEach((key) => {
      item = {};

      item.name = key;
      item.defaultUrl = serviceHostmap.serviceLinks[key];
      item.hosts = serviceHostmap.hostCatalog[Url.parse(item.defaultUrl).host];

      output.push(item);
    });

    return output;
  },

  /**
   * **Internal**
   * Simplified method wrapper for sending a request to get
   * an updated service hostmap.
   * @param {boolean} [limited]
   * @param {string} [query]
   * @returns {Promise<object>}
   */
  _fetchNewServiceHostmap(limited, query) {
    const service = 'u2c';
    const limStr = (limited) ? '/limited' : '';
    const queryStr = (query) ? `&${query}` : '';

    return this.request({
      method: 'GET',
      service,
      resource: `${limStr}/catalog?format=hostmap${queryStr}`
    })
      .then(({body}) => Promise.resolve(this._formatReceivedHostmap(body)))
      .catch((e) => Promise.reject(e));
  },

  /**
   * Initializer
   *
   * @emits Services#ready
   * @emits Services#servicesUpdated
   * @emits Services#pulse
   * @instance
   * @memberof Services
   * @returns {Services}
   */
  initialize() {
    this.listenToOnce(this.webex, 'ready', () => {
      this.updateServices();
    });

    this.once('servicesUpdated', () => {
      this.status.ready = true;
      this.trigger('ready');
    });
  }
});
/* eslint-enable no-underscore-dangle */

export default Services;
