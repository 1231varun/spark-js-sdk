import Url from 'url';

import {WebexPlugin} from '@webex/webex-core';

import ServiceUrl from './service-url';

/* eslint-disable no-underscore-dangle */
/**
 * @class
 */
const Services = WebexPlugin.extend({
  namespace: 'Services',

  status: {
    ready: false
  },

  _serviceUrls: [],

  _preDiscoveryServiceUrls: [
    new ServiceUrl({
      name: 'u2c',
      defaultUrl: process.env.U2C_SERVICE_URL ||
        'https://u2c.wbx2.com/u2c/api/v1',
      hosts: []
    })
  ],

  /**
   * Generate a service catalog in the shape of an object.
   * @returns {object}
   */
  services() {
    const output = {};

    this._serviceUrls.forEach((su) => {
      output[su.name] = su.get();
    });

    return output;
  },

  /**
   * **Internal**
   * Search the service url array to locate a `ServiceUrl`
   * class object based on its name.
   * @param {string} name
   * @returns {ServiceUrl}
   */
  _getUrl(name) {
    return this._serviceUrls.find((su) => su.name === name);
  },

  /**
   * Get a service url from the current services list by name.
   * @param {string} name
   * @returns {string|void}
   */
  get(name) {
    const serviceUrl = this._getUrl(name);

    return (serviceUrl) ? serviceUrl.get() : undefined;
  },

  /**
   * Update the current list of services to the most current
   * catalog via the defined `discoveryUrl`.
   * @returns {Promise<void>}
   */
  updateServices() {
    return this._fetchNewServiceHostmap()
      .then((shm) => {
        this._updateServiceUrls(shm);

        this.trigger('servicesUpdated');

        return Promise.resolve();
      });
  },

  /**
   * Wait until this plugin is ready
   * @returns {Promise<void>}
   */
  waitUntilReady() {
    return new Promise((resolve) => {
      if (this.status.ready) { resolve(); }
      this.once('ready', () => { resolve(); });
    });
  },

  /**
   * **Internal**
   * Safely load one or more `ServiceUrl`s into this `Services` instance.
   * @param  {...ServiceUrl} services
   * @returns {Services}
   */
  _loadServiceUrls(...services) {
    services.forEach((service) => {
      // Validate a service was found in the service catalog.
      // and that service is an instance of `ServiceUrl`
      if (service instanceof ServiceUrl &&
        !this._serviceUrls.includes(service)) {
        this._serviceUrls.push(service);
      }
    });

    return this;
  },

  /**
   * **Internal**
   * Safely unload one or more `ServiceUrl`s into this `Services` instance
   * @param  {...ServiceUrl} services
   * @returns {Services}
   */
  _unloadServiceUrls(...services) {
    let s;

    services.forEach((service) => {
      s = service;

      // Confirm that the service param is a string or object.
      if (typeof service === 'string') {
        s = this._getUrl(s);
      }

      // Validate a service was found in the service catalog.
      if (s && this._serviceUrls.includes(service)) {
        this._serviceUrls.splice(this._serviceUrls.indexOf(s), 1);
      }
    });

    return this;
  },

  /**
   * **Internal**
   * Update the current list of `ServiceUrl`s against a provided
   * service hostmap.
   * @param {object} shm
   * @returns {Services}
   */
  _updateServiceUrls(shm) {
    // Clean up current service urls.
    this._serviceUrls.forEach((su) => {
      const service = shm.find((item) => item.name === su.name);

      if (!service) { this._unloadServiceUrls(su); }
    });

    shm.forEach((s) => {
      const service = this._getUrl(s.name);

      if (service) {
        service.defaultUrl = s.defaultUrl;
        service.hosts = s.hosts;
      }
      else {
        this._loadServiceUrls(new ServiceUrl({
          ...s
        }));
      }
    });

    return this;
  },

  /**
   * **Internal**
   * Simplified method wrapper for sending a request to get
   * an updated service hostmap.
   * @returns {Promise<void>}
   */
  _fetchNewServiceHostmap() {
    const service = 'u2c';

    return this.request({
      method: 'GET',
      service,
      resource: '/catalog?format=hostmap'
    })
      .then(({body}) => {
        const output = [];
        let item = {};

        Object.keys(body.serviceLinks).forEach((key) => {
          item = {};

          item.name = key;
          item.defaultUrl = body.serviceLinks[key];
          item.hosts = body.hostCatalog[Url.parse(item.defaultUrl).host];

          output.push(item);
        });

        return Promise.resolve(output);
      })
      .catch((e) => Promise.reject(e));
  },

  /**
   * Initializer
   *
   * @emits Services#ready
   * @emits Services#servicesUpdated
   * @emits Services#pulse
   * @instance
   * @memberof Services
   * @returns {Services}
   */
  initialize() {
    this._loadServiceUrls(...this._preDiscoveryServiceUrls);

    this.listenToOnce(this.webex, 'ready', () => {
      this.updateServices();
    });

    this.once('servicesUpdated', () => {
      this.status.ready = true;
      this.trigger('ready');
    });
  }
});
/* eslint-enable no-underscore-dangle */

export default Services;
