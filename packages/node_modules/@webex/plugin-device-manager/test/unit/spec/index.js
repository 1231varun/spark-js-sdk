import {doesNotReject} from 'assert';

import {assert} from '@ciscospark/test-helper-chai';

require('dotenv').config();

const sparkTestUsers = require('./sparkTestUsers.js');

const startMeeting = (meeting) => {
  meeting.on('media:ready', (media) => {
    if (!media) {
      return;
    }
    if (media.type === 'local') {
      console.log('localvideo');
    }
    if (media.type === 'remote') {
      console.log('remotevideo');
    }
    if (media.type === 'remoteShare') {
      console.log('sharevideo');
    }
    if (media.type === 'localShare') {
      console.log('localshare');
    }
  });
  meeting.on('media:stopped', (media) => {
    if (media.type === 'local') {
      console.log('localvideo');
    }
    if (media.type === 'remote') {
      console.log('remotevideo');
    }
    if (media.type === 'localShare') {
      console.log('localshare');
    }
    if (media.type === 'remoteShare') {
      console.log('sharevideo');
    }
  });
};

let userSet, alice, bob;
describe('plugin-meeting', () => {
  before(() => sparkTestUsers.generateTestUsers({count: 2})
    .then((users) => {
      userSet = users;
      alice = userSet[0];
      bob = userSet[1];
    })
    .catch((error) => {
      console.log(error);
    }));

  after(() => {
    const promise = [];
    userSet.forEach((user) => {
      promise.push(user.spark.internal.mercury.disconnect());
    });

    return Promise.all(promise)
      .then(() => sparkTestUsers.remove(userSet));
    // TODO: end is not a function on browser object
  });

  it('create a space with 3 participants', () =>
    alice.spark.internal.conversation.create({participants: [bob.emailAddress]})
      .then((conversation) => {
        assert.lengthOf(conversation.participants.items, 2);
        console.log(conversation);
      }));


  it('should login on kitchen sink app', () => {
    assert.equal(typeof alice.spark.meetings, 'object');
    assert.equal(alice.spark.internal.mercury.connected, true);
    assert.equal(typeof bob.spark.meetings, 'object');
    assert.equal(bob.spark.internal.mercury.connected, true);
    assert.equal(alice.spark.internal.device.registered, true);
    assert.equal(bob.spark.internal.device.registered, true);

    return Promise.all([alice.spark.meetings.syncMeetings(),
      bob.spark.meetings.syncMeetings()]);
  });

  describe('events', () => {
    it('obtp for space meeting', () => {
      // create a space and trigger from alice and bob should get obtp event
    });
    it('`meeting:ended after participants left meeting', () => {
      // alice bob left chris should not see any obtp
    });

    it('user starts own PMR gets event', () => {
      // TODO
    });
  });

  // The event was coming but incomplete
  // 1) Test user doesnt have locus tag information

  describe('incoming call', () => {
    let newMeeting;
    before(() => {
      setTimeout(() => {

      }, 20000);
    });
    after(() => {
      bob.meeting.leave();
    });

    it('alice dials a call to bob ', () => {
      assert.equal(Object.keys(alice.spark.meetings.getAll()), 0);
      assert.equal(Object.keys(alice.spark.meetings.getAll()), 0);
      console.log('step 1');
      alice.spark.meetings.on('meeting:added', (m) => {
        console.log('step 4');
        const type = m.type;
        if (type === 'INCOMING') {
          newMeeting = m.meeting;
          alice.meeting = m.meeting;
          console.log('DANGER');
          // newMeeting.acknowledge(type);
        }
      });

      bob.spark.meetings.on('meeting:added', (m) => {
        console.log('step 5', m);
      });

      console.log('step 2');
      return bob.spark.meetings.create(alice.emailAddress)
        .then((m) => {
          startMeeting(m);
          bob.meeting = m;
          m.join();
          console.log('JOINED THE ACTUAL MEETING');
        })
        .catch((err) => {
          console.log('ERROR JOIN ', err);
        });
    });

    it(' bob receives an event from alice for 1:1 call', () => {
      assert.equal(Object.keys(bob.spark.meetings.getAll()).length, 1);
      // assert.equal(typeof newMeeting, 'object');
      setInterval(() => {
        console.log('New Meeting', newMeeting);
        // assert.equal(Object.keys(alice.spark.meetings.getAll().length), 1);
      }, 4000);
    });

    it('alice gets alerted notification', () => {
        setTimeout(() => {
          console.log("DONE ENDED")
        }, 60000)
    });

    it('alice ends the call, bob receives a notification', () => {

    });
  });

  xit('Bob should register for meeting', () => {
    bob.spark.meetings.on('meeting:self:lobbyWaiting', () => {
      console.log('bob is in lobby');
    });
    bob.spark.meetings.create('arungane@go.webex.com')
      .then((m) => {
        console.log(m);
        bob.meeting = m;
        m.join({
          moderator: false
        });
        startMeeting(m);
      });
  });

  xit('should create a call', () => {
    console.log('Device Url 1', alice.spark.internal.device.url);
    alice.spark.meetings.on('meeting:self:lobbyWaiting', () => {
      console.log('alice is in lobby');
    });
    alice.spark.meetings.create('arungane@go.webex.com')
      .then((m) => {
        alice.meeting = m;
        console.log(m);
        m.join({
          moderator: false
        });
        startMeeting(m);
      });
  });

  // it('wait for the call to connect', () => {
  //   assert.equal(typeof (window), 'object')
  //     browser.pause(60000)
  // })
});
