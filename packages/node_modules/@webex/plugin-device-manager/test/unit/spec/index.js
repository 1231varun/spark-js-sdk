import {doesNotReject} from 'assert';

import {assert} from '@ciscospark/test-helper-chai';

require('dotenv').config();

const sparkTestUsers = require('./sparkTestUsers.js');

let userSet, alice, bob, space;
const startMeeting = (meeting) => {
  meeting.on('media:ready', (media) => {
    if (!media) {
      return;
    }
    if (media.type === 'local') {
      console.log('ready-localvideo');
    }
    if (media.type === 'remote') {
      console.log('ready-remotevideo');
    }
    if (media.type === 'remoteShare') {
      console.log('ready-sharevideo');
    }
    if (media.type === 'localShare') {
      console.log('ready-localshare');
    }
  });
  meeting.on('media:stopped', (media) => {
    if (media.type === 'local') {
      console.log('stopped-localvideo');
    }
    if (media.type === 'remote') {
      console.log('stopped-remotevideo');
    }
    if (media.type === 'localShare') {
      console.log('stopped-localshare');
    }
    if (media.type === 'remoteShare') {
      console.log('stopped-sharevideo');
    }
  });
};


describe('plugin-meeting', () => {
  before(() => sparkTestUsers.generateTestUsers({count: 2})
    .then((users) => {
      userSet = users;
      alice = userSet[0];
      bob = userSet[1];
    })
    .catch((error) => {
      console.log(error);
    }));

  after(() => {
    const promise = [];
    userSet.forEach((user) => {
      promise.push(user.spark.internal.mercury.disconnect());
    });

    return Promise.all(promise)
      .then(() => sparkTestUsers.remove(userSet));
    // TODO: end is not a function on browser object
  });

  it('create a space with 3 participants', () =>
    alice.spark.internal.conversation.create({participants: [bob.emailAddress]})
      .then((conversation) => {
        assert.lengthOf(conversation.participants.items, 2);
        console.log('CONVERSATIOn', conversation);
        space = conversation;
      }));


  it('should login on kitchen sink app', () => {
    assert.equal(typeof alice.spark.meetings, 'object');
    assert.equal(alice.spark.internal.mercury.connected, true);
    assert.equal(typeof bob.spark.meetings, 'object');
    assert.equal(bob.spark.internal.mercury.connected, true);
    assert.equal(alice.spark.internal.device.registered, true);
    assert.equal(bob.spark.internal.device.registered, true);

    return Promise.all([alice.spark.meetings.syncMeetings(),
      bob.spark.meetings.syncMeetings()]);
  });

  describe('events', () => {
    it('obtp for space meeting', () => {
      // create a space and trigger from alice and bob should get obtp event
    });
    it('`meeting:ended after participants left meeting', () => {
      // alice bob left chris should not see any obtp
    });

    it('user starts own PMR gets event', () => {
      // TODO
    });
  });

  // The event was coming but incomplete
  // 1) Test user doesnt have locus tag information

  describe('Join incoming call', () => {
    let newMeeting;
    before(() => {
    });
    after(() => {
      if (bob.meeting) {
        bob.meeting.leave();
      }
      if (alice.meeting) {
        alice.meeting.leave();
      }
    });

    it('bob dials a call to alice ', () => {
      assert.equal(Object.keys(alice.spark.meetings.getAll()), 0);
      assert.equal(Object.keys(bob.spark.meetings.getAll()), 0);

      alice.spark.meetings.on('meeting:added', (m) => {
        console.log('step 4 meeting-added alice', m);
        const type = m.type;
        if (type === 'INCOMING') {
          newMeeting = m.meeting;
          alice.meeting = m.meeting;
          // newMeeting.acknowledge(type);
        }
      });

      bob.spark.meetings.on('meeting:added', (m) => {
        console.log('step 3 meeting-added bob');
      });

      return bob.spark.meetings.create(alice.emailAddress)
        .then((m) => {
          console.log('step 1 dial', m);
          console.log('alice addess', alice.emailAddress);
          startMeeting(m);
          bob.meeting = m;
          return m.join()
            .then(() => {
              console.log('step 2 join');
            });
        })
        .catch((err) => {
          console.log('ERROR JOIN ', err);
        });
    });

    it(' bob receives an event from alice for 1:1 call', (done) => {
      const x = bob.spark.meetings.getMeetingByType('sipUri', alice.emailAddress);
      assert.equal(x.sipUri, alice.emailAddress);
      setInterval(() => {
        if (alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress)) {
          console.log('MEETING FOUND');
          done();
        }
        else {
          console.log('MEETING NOT FOUND');
        }
      }, 1000);
    }).timeout(20000);

    it('alice joins the incoming call', () => {
      newMeeting = alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress);
      alice.meeting = newMeeting;
      console.log('ALICE ', newMeeting);
      assert(newMeeting.sipUri, bob.emailAddress);
      newMeeting.members.on('members:update', (members) => {
        console.log('ALICE MEMBER ', members);
      });

      return newMeeting.join()
        .then(() => {
          console.log('JOINED meeting by alice');
        });
    });

    it('check for participants length', () => {
      const members = newMeeting.getMembers();
      console.log('memebers ', members);
      assert(Object.keys(newMeeting.members).length, 2);
    });

    it('check for meeting state', () => {
      console.log('DONE', newMeeting);
      assert(newMeeting.type, 'ONE_ON_ONE');
      assert(newMeeting.state, 'JOINED');
    });

    it('leave the meeting ', (done) => Promise.all([
      alice.meeting.leave(),
      bob.meeting.leave()
    ])
      .then(() => {
        assert(alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress), undefined);
        assert(bob.spark.meetings.getMeetingByType('sipUri', alice.emailAddress), undefined);
        done();
      }));
  });

  describe('reject Incoming Call', () => {

  });
});
