
import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';

import testUtils from './testUtils';

require('dotenv').config();

const sparkTestUsers = require('./sparkTestUsers.js');

let userSet, alice, bob;
const startMeeting = (meeting) => {
  meeting.on('media:ready', (media) => {
    if (!media) {
      return;
    }
    if (media.type === 'local') {
      console.log('ready-localvideo');
    }
    if (media.type === 'remote') {
      console.log('ready-remotevideo');
    }
    if (media.type === 'remoteShare') {
      console.log('ready-sharevideo');
    }
    if (media.type === 'localShare') {
      console.log('ready-localshare');
    }
  });
  meeting.on('media:stopped', (media) => {
    if (media.type === 'local') {
      console.log('stopped-localvideo');
    }
    if (media.type === 'remote') {
      console.log('stopped-remotevideo');
    }
    if (media.type === 'localShare') {
      console.log('stopped-localshare');
    }
    if (media.type === 'remoteShare') {
      console.log('stopped-sharevideo');
    }
  });
};


describe('plugin-meeting', () => {
  before(() => sparkTestUsers.generateTestUsers({count: 2})
    .then((users) => {
      userSet = users;
      alice = userSet[0];
      bob = userSet[1];
    })
    .catch((error) => {
      console.log(error);
    }));

  after(() => {
    const promise = [];
    userSet.forEach((user) => {
      promise.push(user.spark.internal.mercury.disconnect());
    });

    return Promise.all(promise)
      .then(() => sparkTestUsers.remove(userSet));
    // TODO: end is not a function on browser object
  });

  // beforeEach((done) => {
  //   if (alice.spark.meetings && bob.spark.meetings) {
  //     return Promise.all([alice.spark.meetings.syncMeetings(), bob.spark.meetings.syncMeetings()])
  //       .then(([loci1, loci2]) => {
  //         console.log('SYNCE MEETING', loci2);
  //       }).then(() => {
  //         done();
  //         console.log('END THESE MEETING', alice.spark.meetings.getAll());
  //         console.log('END THESE MEETING', bob.spark.meetings.getAll());
  //         console.log('END THESE MEETING-alice', alice.spark.meetings.getMeetingByType(bob.emailAddress));
  //         console.log('END THESE MEETING-bob', bob.spark.meetings.getMeetingByType(alice.emailAddress),);
  //       });
  //   }
  // });

  // afterEach(() => {
  //   if (bob.meeting) {
  //     bob.meeting.leave();
  //   }
  //   if (alice.meeting) {
  //     alice.meeting.leave();
  //   }
  // });

  describe('events', () => {
    it('obtp for space meeting', () => {
      // create a space and trigger from alice and bob should get obtp event
    });
    it('`meeting:ended after participants left meeting', () => {
      // alice bob left chris should not see any obtp
    });

    it('user starts own PMR gets event', () => {
      // TODO
    });
  });

  // The event was coming but incomplete
  // 1) Test user doesnt have locus tag information

  // Alice calls bob and bob rejects it
  describe('reject Incoming Call', () => {
    const aliceMeetingAdded = sinon.spy();
    const bobMeetingAdded = sinon.spy();
    it('alice dials bob and bob receives meeting added', () => {
      bob.spark.meetings.on('meeting:added', bobMeetingAdded);
      alice.spark.meetings.on('meeting:added', aliceMeetingAdded);
      return alice.spark.meetings.create(bob.emailAddress)
        .then((m) => {
          startMeeting(m);
          alice.meeting = m;
          return m.join()
            .then(() => testUtils.waitForSpy(aliceMeetingAdded, 'meeting:added'))
            .then((m) => {
              alice.meeting = m.meeting;
              console.log('alice dialed');
            });
        })
        .then(() => testUtils.waitForSpy(bobMeetingAdded, 'meeting:added'))
        .then((m) => {
          bob.meeting = m.meeting;
        })
        .catch((err) => {
          console.log('ERROR JOIN ', err);
          throw err;
        });
    });

    it('bob and alice have meeting object', () => {
      assert.equal(bob.meeting.sipUri, alice.emailAddress);
      assert.equal(alice.meeting.sipUri, bob.emailAddress);
      assert.equal(bob.meeting.state, 'IDLE');
      assert.equal(alice.meeting.state, 'JOINED');
    }).timeout(20000);

    it('bob rejects the meeting', () => {
      bob.meeting.acknowledge('INCOMING');
      return bob.meeting.decline('BUSY')
        .then(() => testUtils.waitForStateChange(bob.meeting, 'DECLINED'));
    });

    it('alice leaves the meeting', () => {
      assert.equal(alice.meeting.state, 'JOINED');

      return alice.meeting.leave()
        .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT'))
        .then(() => testUtils.waitForStateChange(bob.meeting, 'DECLINED'));
    });

    it('alice and bob meeting object deleted', () => Promise.all([
      testUtils.waitForCallEnded(alice, bob.emailAddress),
      testUtils.waitForCallEnded(bob, alice.emailAddress)
    ])
      .then(() => {
        assert.equal(alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress), null);
        assert.equal(bob.spark.meetings.getMeetingByType('sipUri', alice.emailAddress), null);
      }));
  });

  describe('successfull 1:1 call', () => {
    const aliceMeetingAdded = sinon.spy();
    const bobMeetingAdded = sinon.spy();
    it('No previous call', () => {
      assert.equal(Object.keys(alice.spark.meetings.getAll()), 0);
      assert.equal(Object.keys(bob.spark.meetings.getAll()), 0);
    });

    it('alice dials bob and bob receives meeting added', () => {
      bob.spark.meetings.on('meeting:added', bobMeetingAdded);
      alice.spark.meetings.on('meeting:added', aliceMeetingAdded);
      return alice.spark.meetings.create(bob.emailAddress)
        .then((m) => {
          startMeeting(m);
          alice.meeting = m;
          return m.join()
            .then(() => testUtils.waitForSpy(aliceMeetingAdded, 'meeting:added'))
            .then((m) => {
              alice.meeting = m.meeting;
              console.log('alice dialed');
            });
        })
        .then(() => testUtils.waitForSpy(bobMeetingAdded, 'meeting:added'))
        .then((m) => {
          bob.meeting = m.meeting;
          bob.meeting.acknowledge('INCOMING');
          return bob.meeting.join()
            .then(() => testUtils.waitForStateChange(bob.meeting, 'JOINED'));
        })
        .catch((err) => {
          console.log('ERROR JOIN ', err);
          throw err;
        });
    });

    it('bob and alice have meeting object', () => {
      assert.equal(bob.meeting.sipUri, alice.emailAddress);
      assert.equal(alice.meeting.sipUri, bob.emailAddress);
      assert.equal(bob.meeting.state, 'JOINED');
      assert.equal(alice.meeting.state, 'JOINED');
      assert.equal(alice.meeting.type, 'ONE_ON_ONE');
      assert.equal(bob.meeting.type, 'ONE_ON_ONE');
    }).timeout(20000);

    it('leave on the meeting object', () => Promise.all([alice.meeting.leave(), bob.meeting.leave()])
      .then(() => testUtils.waitForStateChange(alice.meeting, 'LEFT'))
      .then(() => testUtils.waitForStateChange(bob.meeting, 'LEFT')));

    it('alice and bob meeting object deleted', () => Promise.all([
      testUtils.waitForCallEnded(alice, bob.emailAddress),
      testUtils.waitForCallEnded(bob, alice.emailAddress)
    ])
      .then(() => {
        assert.equal(alice.spark.meetings.getMeetingByType('sipUri', bob.emailAddress), null);
        assert.equal(bob.spark.meetings.getMeetingByType('sipUri', alice.emailAddress), null);
      }));
  });
});
